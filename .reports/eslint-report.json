[{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\collaboration\\CollaborativeSessionManager.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'SessionStatus' is defined but never used.","line":15,"column":3,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"SessionStatus"},"fix":{"range":[456,475],"text":""},"desc":"Remove unused variable 'SessionStatus'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'llmManager' is defined but never used.","line":35,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"llmManager"},"fix":{"range":[1147,1169],"text":""},"desc":"Remove unused variable 'llmManager'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'vectorDB' is defined but never used.","line":36,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":31,"suggestions":[{"messageId":"removeVar","data":{"varName":"vectorDB"},"fix":{"range":[1184,1202],"text":""},"desc":"Remove unused variable 'vectorDB'."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'startSession' has too many lines (58). Maximum allowed is 50.","line":48,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":105,"endColumn":4},{"ruleId":"no-unused-vars","severity":2,"message":"'sessionTimerId' is assigned a value but never used.","line":78,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":78,"endColumn":27,"suggestions":[{"messageId":"removeVar","data":{"varName":"sessionTimerId"},"fix":{"range":[2524,2766],"text":""},"desc":"Remove unused variable 'sessionTimerId'."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'executeRounds' has too many lines (57). Maximum allowed is 50.","line":110,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":166,"endColumn":4},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'executeCritiqueRound' has too many lines (52). Maximum allowed is 50.","line":265,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":316,"endColumn":4},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'executeValidationRound' has too many lines (53). Maximum allowed is 50.","line":374,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":426,"endColumn":4},{"ruleId":"no-unused-vars","severity":2,"message":"'_roundNumber' is defined but never used.","line":528,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":528,"endColumn":64,"suggestions":[{"messageId":"removeVar","data":{"varName":"_roundNumber"},"fix":{"range":[18094,18116],"text":""},"desc":"Remove unused variable '_roundNumber'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":552,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":552,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19101,19104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19101,19104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":557,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":557,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19450,19453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19450,19453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":562,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":562,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19797,19800],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19797,19800],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'session' is defined but never used.","line":576,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":576,"endColumn":60,"suggestions":[{"messageId":"removeVar","data":{"varName":"session"},"fix":{"range":[20490,20519],"text":""},"desc":"Remove unused variable 'session'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'session' is defined but never used.","line":581,"column":33,"nodeType":"Identifier","messageId":"unusedVar","endLine":581,"endColumn":62,"suggestions":[{"messageId":"removeVar","data":{"varName":"session"},"fix":{"range":[20641,20670],"text":""},"desc":"Remove unused variable 'session'."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateCollaborativeOutput' has too many lines (58). Maximum allowed is 50.","line":586,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":643,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":628,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":628,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22806,22809],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22806,22809],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":665,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":665,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24624,24627],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24624,24627],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_session' is defined but never used.","line":673,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":673,"endColumn":70,"suggestions":[{"messageId":"removeVar","data":{"varName":"_session"},"fix":{"range":[24976,25006],"text":""},"desc":"Remove unused variable '_session'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":673,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":673,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25009,25012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25009,25012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_session' is defined but never used.","line":678,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":678,"endColumn":62,"suggestions":[{"messageId":"removeVar","data":{"varName":"_session"},"fix":{"range":[25131,25161],"text":""},"desc":"Remove unused variable '_session'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":678,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":678,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25164,25167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25164,25167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_session' is defined but never used.","line":683,"column":39,"nodeType":"Identifier","messageId":"unusedVar","endLine":683,"endColumn":69,"suggestions":[{"messageId":"removeVar","data":{"varName":"_session"},"fix":{"range":[25293,25323],"text":""},"desc":"Remove unused variable '_session'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":683,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":683,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25326,25329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25326,25329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":737,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":737,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27356,27359],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27356,27359],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":739,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":739,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27431,27434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27431,27434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CollaborativeSessionManager - Main orchestrator for multi-LLM collaboration\r\n * \r\n * This class manages the entire lifecycle of collaborative sessions,\r\n * from initiation through completion, ensuring proper time management,\r\n * consensus building, and quality assurance.\r\n */\r\n\r\n// vscode not required directly in this manager\r\nimport { EventEmitter } from 'events';\r\nimport { \r\n  CollaborativeSession, \r\n  CollaborationRequest, \r\n  LLMParticipant, \r\n  SessionStatus,\r\n  SessionMetrics,\r\n  CollaborationEvent,\r\n  CollaborationError,\r\n  CollaborativeOutput,\r\n  RoundType\r\n} from './types/collaborationTypes';\r\nimport { TimeManager } from './timing/TimeManager';\r\nimport { CollaborationRound } from './rounds/CollaborationRound';\r\nimport { LLMManager } from '../llm/llmManager';\r\nimport { VectorDB } from '../db/vectorDB';\r\nimport { logger } from '../utils/logger';\r\n\r\nexport class CollaborativeSessionManager extends EventEmitter {\r\n  private sessions: Map<string, CollaborativeSession> = new Map();\r\n  private timeManager: TimeManager;\r\n  private sessionIdCounter = 0;\r\n  private testMode: boolean = false;\r\n\r\n  constructor(\r\n    private llmManager: LLMManager,\r\n    private vectorDB: VectorDB,\r\n    testMode: boolean = false\r\n  ) {\r\n    super();\r\n    this.timeManager = new TimeManager();\r\n    this.testMode = testMode || process.env.NODE_ENV === 'test';\r\n    this.setupEventHandlers();\r\n  }\r\n\r\n  /**\r\n   * Start a new collaborative session\r\n   */\r\n  async startSession(request: CollaborationRequest): Promise<CollaborativeSession> {\r\n    const sessionId = `session_${++this.sessionIdCounter}_${Date.now()}`;\r\n    \r\n    logger.info(`🚀 Starting collaborative session ${sessionId}`);\r\n    logger.debug(`📝 Prompt: ${request.prompt.substring(0, 100)}...`);\r\n\r\n    try {\r\n      // Validate request\r\n      this.validateRequest(request);\r\n\r\n      // Select participants\r\n      const participants = await this.selectParticipants(request);\r\n      \r\n      // Create session\r\n      const session: CollaborativeSession = {\r\n        id: sessionId,\r\n        initiator: 'user', // TODO: Get actual user context\r\n        participants,\r\n        rounds: [],\r\n        request,\r\n        timeLimit: request.timeLimit || 300000, // 5 minutes default\r\n        consensusThreshold: request.consensusThreshold || 66, // 66% default\r\n        status: 'initializing',\r\n        startTime: new Date(),\r\n        metrics: this.initializeMetrics()\r\n      };\r\n\r\n      this.sessions.set(sessionId, session);\r\n\r\n      // Set up session timer\r\n      const sessionTimerId = this.timeManager.createSessionTimer(\r\n        sessionId,\r\n        session.timeLimit,\r\n        (remaining) => this.handleSessionWarning(sessionId, remaining),\r\n        () => this.handleSessionTimeout(sessionId)\r\n      );\r\n\r\n      // Update status and emit event\r\n      session.status = 'active';\r\n      this.emitEvent('session_started', sessionId, { session });\r\n\r\n      // Execute collaboration rounds (skip in test mode to allow manual testing)\r\n      if (!this.testMode) {\r\n        await this.executeRounds(session);\r\n      }\r\n\r\n      return session;\r\n\r\n    } catch (error) {\r\n      logger.error(`❌ Failed to start session ${sessionId}:`, error);\r\n      const collaborationError = error instanceof CollaborationError \r\n        ? error \r\n        : new CollaborationError(`Failed to start session: ${error}`, 'SESSION_START_FAILED', sessionId);\r\n      \r\n      this.emitEvent('error', sessionId, { error: collaborationError });\r\n      throw collaborationError;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute collaboration rounds for a session\r\n   */\r\n  private async executeRounds(session: CollaborativeSession): Promise<void> {\r\n    const maxRounds = session.request.maxRounds || 4;\r\n    const roundTypes: RoundType[] = ['propose', 'critique', 'synthesize', 'validate'];\r\n\r\n    logger.info(`🔄 Executing up to ${maxRounds} collaboration rounds`);\r\n\r\n    for (let roundNumber = 1; roundNumber <= maxRounds; roundNumber++) {\r\n      if (session.status !== 'active') {\r\n        logger.warn(`⏹️ Session ${session.id} no longer active, stopping rounds`);\r\n        break;\r\n      }\r\n\r\n      const roundType = roundTypes[Math.min(roundNumber - 1, roundTypes.length - 1)];\r\n      \r\n      try {\r\n        logger.info(`🎯 Starting round ${roundNumber}: ${roundType}`);\r\n        \r\n        const round = new CollaborationRound(\r\n          session.id,\r\n          roundNumber,\r\n          roundType,\r\n          this.getRoundPurpose(roundType, roundNumber),\r\n          this.getRoundTimeLimit(roundType)\r\n        );\r\n\r\n        // Add round to session\r\n        session.rounds.push(round);\r\n        this.emitEvent('round_started', session.id, { round });\r\n\r\n        // Execute the round\r\n        await this.executeRound(session, round);\r\n\r\n        // Check if we've reached consensus\r\n        if (this.hasReachedConsensus(session)) {\r\n          logger.info(`✅ Consensus reached in round ${roundNumber}`);\r\n          session.status = 'consensus_reached';\r\n          break;\r\n        }\r\n\r\n        // Check quality threshold\r\n        if (this.meetsQualityThreshold(session)) {\r\n          logger.info(`🎯 Quality threshold met in round ${roundNumber}`);\r\n          break;\r\n        }\r\n\r\n      } catch (error) {\r\n        logger.error(`❌ Error in round ${roundNumber}:`, error);\r\n        // Continue to next round unless critical error\r\n        if (error instanceof CollaborationError && error.code === 'CRITICAL_FAILURE') {\r\n          throw error;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Finalize session\r\n    await this.finalizeSession(session);\r\n  }\r\n\r\n  /**\r\n   * Execute a single collaboration round\r\n   */\r\n  private async executeRound(session: CollaborativeSession, round: CollaborationRound): Promise<void> {\r\n    // Set up round timer\r\n    const roundTimerId = this.timeManager.createRoundTimer(\r\n      round.type,\r\n      round.timeLimit,\r\n      (remaining) => this.handleRoundWarning(session.id, round.id, remaining),\r\n      () => this.handleRoundTimeout(session.id, round.id)\r\n    );\r\n\r\n    round.status = 'active';\r\n    round.startTime = new Date();\r\n\r\n    try {\r\n      // Execute round based on type\r\n      switch (round.type) {\r\n        case 'propose':\r\n          await this.executeProposalRound(session, round);\r\n          break;\r\n        case 'critique':\r\n          await this.executeCritiqueRound(session, round);\r\n          break;\r\n        case 'synthesize':\r\n          await this.executeSynthesisRound(session, round);\r\n          break;\r\n        case 'validate':\r\n          await this.executeValidationRound(session, round);\r\n          break;\r\n      }\r\n\r\n      round.status = 'completed';\r\n      round.endTime = new Date();\r\n\r\n    } catch (error) {\r\n      logger.error(`❌ Round ${round.id} failed:`, error);\r\n      round.status = 'timeout';\r\n      throw error;\r\n    } finally {\r\n      this.timeManager.stopTimer(roundTimerId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute a proposal round where LLMs generate initial ideas\r\n   */\r\n  private async executeProposalRound(session: CollaborativeSession, round: CollaborationRound): Promise<void> {\r\n    logger.info(`💡 Executing proposal round`);\r\n\r\n    const proposalPrompt = this.buildProposalPrompt(session.request);\r\n    \r\n    // Get proposals from all active participants in parallel\r\n    const proposalPromises = session.participants\r\n      .filter(p => p.isActive)\r\n      .map(async (participant) => {\r\n        try {\r\n          const response = await this.llmManager.generateResponse(\r\n            participant.provider.toLowerCase(),\r\n            proposalPrompt\r\n          );\r\n\r\n          const contribution = {\r\n            id: `contrib_${Date.now()}_${participant.id}`,\r\n            roundId: round.id,\r\n            author: participant,\r\n            content: response,\r\n            confidence: 85, // Default confidence for proposals\r\n            buildUpon: [],\r\n            critiques: [],\r\n            timestamp: new Date(),\r\n            tokenCount: this.estimateTokenCount(response),\r\n            metadata: {\r\n              processingTime: 0, // TODO: Track actual processing time\r\n              retryCount: 0\r\n            }\r\n          };\r\n\r\n          round.contributions.push(contribution);\r\n          this.emitEvent('contribution_received', session.id, { contribution });\r\n          \r\n          return contribution;\r\n\r\n        } catch (error) {\r\n          logger.error(`❌ Error getting proposal from ${participant.provider}:`, error);\r\n          return null;\r\n        }\r\n      });\r\n\r\n    await Promise.all(proposalPromises);\r\n    \r\n    logger.info(`💡 Collected ${round.contributions.length} proposals`);\r\n  }\r\n\r\n  /**\r\n   * Execute a critique round where LLMs review and provide feedback\r\n   */\r\n  private async executeCritiqueRound(session: CollaborativeSession, round: CollaborationRound): Promise<void> {\r\n    logger.info(`🔍 Executing critique round`);\r\n\r\n    // Get previous round's contributions\r\n    const previousRound = session.rounds[session.rounds.length - 2]; // -1 is current round, -2 is previous\r\n    if (!previousRound || previousRound.contributions.length === 0) {\r\n      throw new CollaborationError('No previous contributions to critique', 'NO_PREVIOUS_CONTRIBUTIONS', session.id, round.id);\r\n    }\r\n\r\n    const critiquePrompt = this.buildCritiquePrompt(previousRound.contributions);\r\n\r\n    // Get critiques from participants\r\n    const critiquePromises = session.participants\r\n      .filter(p => p.isActive)\r\n      .map(async (participant) => {\r\n        try {\r\n          const response = await this.llmManager.generateResponse(\r\n            participant.provider.toLowerCase(),\r\n            critiquePrompt\r\n          );\r\n\r\n          const contribution = {\r\n            id: `contrib_${Date.now()}_${participant.id}`,\r\n            roundId: round.id,\r\n            author: participant,\r\n            content: response,\r\n            confidence: 80,\r\n            buildUpon: previousRound.contributions.map(c => c.id),\r\n            critiques: previousRound.contributions.map(c => c.id),\r\n            timestamp: new Date(),\r\n            tokenCount: this.estimateTokenCount(response),\r\n            metadata: {\r\n              processingTime: 0,\r\n              retryCount: 0\r\n            }\r\n          };\r\n\r\n          round.contributions.push(contribution);\r\n          this.emitEvent('contribution_received', session.id, { contribution });\r\n          \r\n          return contribution;\r\n\r\n        } catch (error) {\r\n          logger.error(`❌ Error getting critique from ${participant.provider}:`, error);\r\n          return null;\r\n        }\r\n      });\r\n\r\n    await Promise.all(critiquePromises);\r\n    \r\n    logger.info(`🔍 Collected ${round.contributions.length} critiques`);\r\n  }\r\n\r\n  /**\r\n   * Execute a synthesis round where ideas are combined\r\n   */\r\n  private async executeSynthesisRound(session: CollaborativeSession, round: CollaborationRound): Promise<void> {\r\n    logger.info(`🔀 Executing synthesis round`);\r\n\r\n    // Get all previous contributions\r\n    const allContributions = session.rounds\r\n      .slice(0, -1) // Exclude current round\r\n      .flatMap(r => r.contributions);\r\n\r\n    if (allContributions.length === 0) {\r\n      throw new CollaborationError('No contributions to synthesize', 'NO_CONTRIBUTIONS_TO_SYNTHESIZE', session.id, round.id);\r\n    }\r\n\r\n    const synthesisPrompt = this.buildSynthesisPrompt(allContributions);\r\n\r\n    // Use the most capable participant for synthesis (TODO: Make this intelligent)\r\n    const synthesizer = this.selectSynthesizer(session.participants);\r\n    \r\n    try {\r\n      const response = await this.llmManager.generateResponse(\r\n        synthesizer.provider.toLowerCase(),\r\n        synthesisPrompt\r\n      );\r\n\r\n      const contribution = {\r\n        id: `contrib_${Date.now()}_${synthesizer.id}`,\r\n        roundId: round.id,\r\n        author: synthesizer,\r\n        content: response,\r\n        confidence: 90,\r\n        buildUpon: allContributions.map(c => c.id),\r\n        critiques: [],\r\n        timestamp: new Date(),\r\n        tokenCount: this.estimateTokenCount(response),\r\n        metadata: {\r\n          processingTime: 0,\r\n          retryCount: 0\r\n        }\r\n      };\r\n\r\n      round.contributions.push(contribution);\r\n      this.emitEvent('contribution_received', session.id, { contribution });\r\n      \r\n    } catch (error) {\r\n      logger.error(`❌ Error in synthesis:`, error);\r\n      throw error;\r\n    }\r\n\r\n    logger.info(`🔀 Synthesis completed`);\r\n  }\r\n\r\n  /**\r\n   * Execute a validation round where the synthesized solution is validated\r\n   */\r\n  private async executeValidationRound(session: CollaborativeSession, round: CollaborationRound): Promise<void> {\r\n    logger.info(`✅ Executing validation round`);\r\n\r\n    // Get the synthesis from previous round\r\n    const synthesisRound = session.rounds[session.rounds.length - 2];\r\n    if (!synthesisRound || synthesisRound.contributions.length === 0) {\r\n      throw new CollaborationError('No synthesis to validate', 'NO_SYNTHESIS_TO_VALIDATE', session.id, round.id);\r\n    }\r\n\r\n    const synthesisContribution = synthesisRound.contributions[0]; // Should be only one synthesis\r\n    const validationPrompt = this.buildValidationPrompt(synthesisContribution, session.request);\r\n\r\n    // Get validation from all participants\r\n    const validationPromises = session.participants\r\n      .filter(p => p.isActive && p.id !== synthesisContribution.author.id) // Exclude synthesizer\r\n      .map(async (participant) => {\r\n        try {\r\n          const response = await this.llmManager.generateResponse(\r\n            participant.provider.toLowerCase(),\r\n            validationPrompt\r\n          );\r\n\r\n          const contribution = {\r\n            id: `contrib_${Date.now()}_${participant.id}`,\r\n            roundId: round.id,\r\n            author: participant,\r\n            content: response,\r\n            confidence: 85,\r\n            buildUpon: [synthesisContribution.id],\r\n            critiques: [],\r\n            timestamp: new Date(),\r\n            tokenCount: this.estimateTokenCount(response),\r\n            metadata: {\r\n              processingTime: 0,\r\n              retryCount: 0\r\n            }\r\n          };\r\n\r\n          round.contributions.push(contribution);\r\n          this.emitEvent('contribution_received', session.id, { contribution });\r\n          \r\n          return contribution;\r\n\r\n        } catch (error) {\r\n          logger.error(`❌ Error getting validation from ${participant.provider}:`, error);\r\n          return null;\r\n        }\r\n      });\r\n\r\n    await Promise.all(validationPromises);\r\n    \r\n    logger.info(`✅ Collected ${round.contributions.length} validations`);\r\n  }\r\n\r\n  /**\r\n   * Finalize the collaborative session and generate output\r\n   */\r\n  private async finalizeSession(session: CollaborativeSession): Promise<void> {\r\n    logger.info(`🏁 Finalizing session ${session.id}`);\r\n\r\n    session.endTime = new Date();\r\n    session.status = 'completed';\r\n\r\n    // Generate collaborative output\r\n    session.output = await this.generateCollaborativeOutput(session);\r\n\r\n    // Update metrics\r\n    this.updateSessionMetrics(session);\r\n\r\n    // Store in vector DB for future reference\r\n    await this.storeSessionInVectorDB(session);\r\n\r\n    this.emitEvent('session_completed', session.id, { session });\r\n\r\n    logger.info(`✅ Session ${session.id} completed successfully`);\r\n    logger.info(`📊 Quality Score: ${session.output.qualityScore}`);\r\n    logger.info(`🎯 Consensus Level: ${session.output.consensusLevel}`);\r\n    logger.info(`⚡ Token Usage: ${session.output.tokenUsage.totalTokens}`);\r\n  }\r\n\r\n  // Helper methods would continue here...\r\n  // Due to length constraints, I'll include the key helper method signatures\r\n\r\n  private validateRequest(request: CollaborationRequest): void {\r\n    if (!request.prompt || request.prompt.trim().length === 0) {\r\n      throw new CollaborationError('Request prompt cannot be empty', 'INVALID_REQUEST');\r\n    }\r\n    if (request.priority && !['low', 'medium', 'high', 'critical'].includes(request.priority)) {\r\n      throw new CollaborationError('Invalid priority level', 'INVALID_REQUEST');\r\n    }\r\n    if (request.timeLimit && request.timeLimit < 10000) {\r\n      throw new CollaborationError('Time limit must be at least 10 seconds', 'INVALID_REQUEST');\r\n    }\r\n  }\r\n\r\n  private async selectParticipants(request: CollaborationRequest): Promise<LLMParticipant[]> {\r\n    // Create default participants based on available LLM providers\r\n    const participants: LLMParticipant[] = [\r\n      {\r\n        id: 'openai_participant',\r\n        provider: 'OpenAI',\r\n        model: 'gpt-4',\r\n        role: 'implementer',\r\n        strengths: ['implementation', 'code_quality', 'bug_detection'],\r\n        specializations: ['coding', 'technical_analysis'],\r\n        performanceHistory: [],\r\n        isActive: true,\r\n        currentLoad: 0\r\n      },\r\n      {\r\n        id: 'anthropic_participant', \r\n        provider: 'Anthropic',\r\n        model: 'claude-3-sonnet',\r\n        role: 'reasoner',\r\n        strengths: ['reasoning', 'logic', 'security'],\r\n        specializations: ['architecture', 'analysis'],\r\n        performanceHistory: [],\r\n        isActive: true,\r\n        currentLoad: 0\r\n      },\r\n      {\r\n        id: 'grok_participant',\r\n        provider: 'xAI', \r\n        model: 'grok-beta',\r\n        role: 'innovator',\r\n        strengths: ['creativity', 'innovation', 'ux_design'],\r\n        specializations: ['creative_solutions', 'user_experience'],\r\n        performanceHistory: [],\r\n        isActive: true,\r\n        currentLoad: 0\r\n      }\r\n    ];\r\n\r\n    // Filter by preferred participants if specified\r\n    if (request.preferredParticipants && request.preferredParticipants.length > 0) {\r\n      return participants.filter(p => request.preferredParticipants!.includes(p.provider));\r\n    }\r\n\r\n    return participants;\r\n  }\r\n\r\n  private initializeMetrics(): SessionMetrics {\r\n    return {\r\n      totalDuration: 0,\r\n      roundCount: 0,\r\n      contributionCount: 0,\r\n      consensusAchieved: false,\r\n      qualityImprovement: 0,\r\n      tokenEfficiency: 0,\r\n      participantUtilization: {},\r\n      emergenceScore: 0\r\n    };\r\n  }\r\n\r\n  private getRoundPurpose(type: RoundType, _roundNumber: number): string {\r\n    const purposes = {\r\n      propose: `Generate initial ideas and approaches for the given problem`,\r\n      critique: `Review and provide constructive feedback on previous proposals`,\r\n      synthesize: `Combine the best elements from proposals and critiques into a unified solution`,\r\n      validate: `Validate the synthesized solution for correctness, completeness, and quality`\r\n    };\r\n    return purposes[type];\r\n  }\r\n\r\n  private getRoundTimeLimit(type: RoundType): number {\r\n    const limits = {\r\n      propose: 60000,  // 1 minute\r\n      critique: 45000, // 45 seconds\r\n      synthesize: 90000, // 1.5 minutes\r\n      validate: 30000  // 30 seconds\r\n    };\r\n    return limits[type];\r\n  }\r\n\r\n  private buildProposalPrompt(request: CollaborationRequest): string {\r\n    return `${request.prompt}\\n\\nPlease provide your initial proposal for addressing this request. Focus on your unique strengths and perspective.`;\r\n  }\r\n\r\n  private buildCritiquePrompt(contributions: any[]): string {\r\n    const contributionTexts = contributions.map(c => `${c.author.provider}: ${c.content}`).join('\\n\\n');\r\n    return `Please review these proposals and provide constructive critique:\\n\\n${contributionTexts}\\n\\nIdentify strengths, weaknesses, and suggestions for improvement.`;\r\n  }\r\n\r\n  private buildSynthesisPrompt(contributions: any[]): string {\r\n    const contributionTexts = contributions.map(c => `${c.author.provider}: ${c.content}`).join('\\n\\n');\r\n    return `Please synthesize these contributions into a unified, comprehensive solution:\\n\\n${contributionTexts}\\n\\nCombine the best elements and resolve any conflicts.`;\r\n  }\r\n\r\n  private buildValidationPrompt(synthesis: any, request: CollaborationRequest): string {\r\n    return `Please validate this synthesized solution against the original request:\\n\\nOriginal Request: ${request.prompt}\\n\\nSynthesized Solution: ${synthesis.content}\\n\\nProvide validation feedback and any final improvements.`;\r\n  }\r\n\r\n  private selectSynthesizer(participants: LLMParticipant[]): LLMParticipant {\r\n    // TODO: Implement intelligent synthesizer selection\r\n    return participants.find(p => p.provider === 'Anthropic') || participants[0];\r\n  }\r\n\r\n  private estimateTokenCount(text: string): number {\r\n    // Rough estimation: ~4 characters per token\r\n    return Math.ceil(text.length / 4);\r\n  }\r\n\r\n  private hasReachedConsensus(session: CollaborativeSession): boolean {\r\n    // TODO: Implement consensus detection logic\r\n    return false;\r\n  }\r\n\r\n  private meetsQualityThreshold(session: CollaborativeSession): boolean {\r\n    // TODO: Implement quality threshold checking\r\n    return false;\r\n  }\r\n\r\n  private async generateCollaborativeOutput(session: CollaborativeSession): Promise<CollaborativeOutput> {\r\n    // Get all contributions from all rounds\r\n    const allContributions = session.rounds.flatMap(round => round.contributions);\r\n    \r\n    // Find the final synthesized content (usually from the last synthesis or validation round)\r\n    let finalContent = '';\r\n    const lastRound = session.rounds[session.rounds.length - 1];\r\n    if (lastRound && lastRound.contributions.length > 0) {\r\n      // Use the last contribution as the final content\r\n      finalContent = lastRound.contributions[lastRound.contributions.length - 1].content;\r\n    } else if (allContributions.length > 0) {\r\n      // Fallback: combine all contributions\r\n      finalContent = allContributions.map(c => `**${c.author.provider}**: ${c.content}`).join('\\n\\n');\r\n    } else {\r\n      finalContent = 'No collaborative output generated - session completed without contributions.';\r\n    }\r\n\r\n    // Calculate quality score (average of contribution confidence scores)\r\n    const qualityScore = allContributions.length > 0 \r\n      ? allContributions.reduce((sum, c) => sum + c.confidence, 0) / allContributions.length\r\n      : 0;\r\n\r\n    // Determine consensus level\r\n    const consensusLevel = this.determineSessionConsensus(session);\r\n\r\n    // Calculate total token usage\r\n    const totalTokens = allContributions.reduce((sum, c) => sum + c.tokenCount, 0);\r\n    const tokensPerParticipant: Record<string, number> = {};\r\n    allContributions.forEach(c => {\r\n      const key = c.author.id;\r\n      tokensPerParticipant[key] = (tokensPerParticipant[key] || 0) + c.tokenCount;\r\n    });\r\n\r\n    const tokensPerRound: Record<number, number> = {};\r\n    session.rounds.forEach((round, index) => {\r\n      tokensPerRound[index] = round.contributions.reduce((sum, c) => sum + c.tokenCount, 0);\r\n    });\r\n\r\n    return {\r\n      sessionId: session.id,\r\n      content: finalContent,\r\n      sources: allContributions,\r\n      rounds: session.rounds.map(r => r.roundOutput).filter(Boolean) as any[],\r\n      emergenceIndicators: this.calculateEmergenceIndicators(session),\r\n      qualityScore,\r\n      consensusLevel,\r\n      synthesisLog: this.generateSynthesisLog(session),\r\n      improvementMetrics: this.calculateImprovementMetrics(session),\r\n      tokenUsage: {\r\n        totalTokens,\r\n        tokensPerParticipant,\r\n        tokensPerRound,\r\n        efficiency: totalTokens > 0 ? qualityScore / totalTokens * 1000 : 0, // Quality per 1000 tokens\r\n        budgetUtilization: session.request.costBudget ? (totalTokens / session.request.costBudget) * 100 : 0,\r\n        costEstimate: totalTokens * 0.002 // Rough estimate at $0.002 per token\r\n      }\r\n    };\r\n  }\r\n\r\n  private updateSessionMetrics(session: CollaborativeSession): void {\r\n    const endTime = session.endTime || new Date();\r\n    session.metrics.totalDuration = endTime.getTime() - session.startTime.getTime();\r\n    session.metrics.roundCount = session.rounds.length;\r\n    session.metrics.contributionCount = session.rounds.reduce((sum, round) => sum + round.contributions.length, 0);\r\n    session.metrics.consensusAchieved = session.status === 'consensus_reached';\r\n    \r\n    if (session.metrics.consensusAchieved && session.metrics.totalDuration > 0) {\r\n      session.metrics.consensusTime = session.metrics.totalDuration;\r\n    }\r\n\r\n    // Calculate participant utilization\r\n    const allContributions = session.rounds.flatMap(round => round.contributions);\r\n    session.participants.forEach(participant => {\r\n      const participantContributions = allContributions.filter(c => c.author.id === participant.id);\r\n      session.metrics.participantUtilization[participant.id] = \r\n        (participantContributions.length / Math.max(session.rounds.length, 1)) * 100;\r\n    });\r\n  }\r\n\r\n  private determineSessionConsensus(session: CollaborativeSession): any {\r\n    // Simple implementation - return based on session status\r\n    if (session.status === 'consensus_reached') return 'unanimous';\r\n    if (session.status === 'completed') return 'qualified_majority';\r\n    if (session.status === 'timeout') return 'forced_consensus';\r\n    return 'simple_majority';\r\n  }\r\n\r\n  private calculateEmergenceIndicators(_session: CollaborativeSession): any[] {\r\n    // Simple implementation - return empty array for now\r\n    return [];\r\n  }\r\n\r\n  private generateSynthesisLog(_session: CollaborativeSession): any[] {\r\n    // Simple implementation - return empty array for now\r\n    return [];\r\n  }\r\n\r\n  private calculateImprovementMetrics(_session: CollaborativeSession): any[] {\r\n    // Simple implementation - return empty array for now\r\n    return [];\r\n  }\r\n\r\n  private async storeSessionInVectorDB(session: CollaborativeSession): Promise<void> {\r\n    try {\r\n      if (session.output) {\r\n        const sessionSummary = `Collaborative session: ${session.request.prompt}\\nResult: ${session.output.content.substring(0, 500)}...`;\r\n        await this.vectorDB.addDocument(\r\n          `session_${session.id}`,\r\n          sessionSummary,\r\n          {\r\n            type: 'collaboration_session',\r\n            sessionId: session.id,\r\n            qualityScore: session.output.qualityScore,\r\n            consensusLevel: session.output.consensusLevel,\r\n            participants: session.participants.map(p => p.provider),\r\n            timestamp: session.startTime.toISOString()\r\n          }\r\n        );\r\n      }\r\n    } catch (error) {\r\n      logger.warn(`Failed to store session ${session.id} in VectorDB:`, error);\r\n      // Don't throw - this is not critical for session completion\r\n    }\r\n  }\r\n\r\n  private handleSessionWarning(sessionId: string, remaining: number): void {\r\n    logger.warn(`⚠️ Session ${sessionId} time warning: ${Math.round(remaining/1000)}s remaining`);\r\n    this.emitEvent('timeout_warning', sessionId, { remaining });\r\n  }\r\n\r\n  private handleSessionTimeout(sessionId: string): void {\r\n    logger.warn(`⏰ Session ${sessionId} timeout - forcing completion`);\r\n    const session = this.sessions.get(sessionId);\r\n    if (session) {\r\n      session.status = 'timeout';\r\n      this.finalizeSession(session);\r\n    }\r\n  }\r\n\r\n  private handleRoundWarning(sessionId: string, roundId: string, remaining: number): void {\r\n    logger.warn(`⚠️ Round ${roundId} time warning: ${Math.round(remaining/1000)}s remaining`);\r\n  }\r\n\r\n  private handleRoundTimeout(sessionId: string, roundId: string): void {\r\n    logger.warn(`⏰ Round ${roundId} timeout`);\r\n  }\r\n\r\n  private setupEventHandlers(): void {\r\n    // Set up internal event handling\r\n  }\r\n\r\n  private emitEvent(type: string, sessionId: string, data: any): void {\r\n    const event: CollaborationEvent = {\r\n      type: type as any,\r\n      sessionId,\r\n      timestamp: new Date(),\r\n      data\r\n    };\r\n    this.emit(type, event);\r\n  }\r\n\r\n  /**\r\n   * Get session by ID\r\n   */\r\n  getSession(sessionId: string): CollaborativeSession | undefined {\r\n    return this.sessions.get(sessionId);\r\n  }\r\n\r\n  /**\r\n   * Get all active sessions\r\n   */\r\n  getActiveSessions(): CollaborativeSession[] {\r\n    return Array.from(this.sessions.values()).filter(s => s.status === 'active');\r\n  }\r\n\r\n  /**\r\n   * Complete a session and return final results\r\n   */\r\n  async completeSession(sessionId: string): Promise<CollaborativeOutput> {\r\n    const session = this.sessions.get(sessionId);\r\n    if (!session) {\r\n      throw new CollaborationError(`Session ${sessionId} not found`, 'SESSION_NOT_FOUND');\r\n    }\r\n\r\n    // Generate final synthesis and metrics\r\n    const output = await this.generateCollaborativeOutput(session);\r\n    \r\n    // Update session status\r\n    session.status = 'completed';\r\n    session.endTime = new Date();\r\n    \r\n    // Store results in vector DB\r\n    session.output = output; // Set the output first\r\n    await this.storeSessionInVectorDB(session);\r\n    \r\n    logger.info(`✅ Completed collaborative session ${sessionId}`);\r\n    this.emit('session_completed', { sessionId, output });\r\n    \r\n    return output;\r\n  }\r\n\r\n  /**\r\n   * Manually execute rounds for a session (for testing)\r\n   */\r\n  async executeSessionRounds(sessionId: string): Promise<void> {\r\n    const session = this.sessions.get(sessionId);\r\n    if (!session) {\r\n      throw new Error(`Session ${sessionId} not found`);\r\n    }\r\n    await this.executeRounds(session);\r\n  }\r\n\r\n  /**\r\n   * Dispose of the session manager\r\n   */\r\n  dispose(): void {\r\n    this.timeManager.dispose();\r\n    this.sessions.clear();\r\n    this.removeAllListeners();\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\collaboration\\rounds\\CollaborationRound.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'_index' is defined but never used.","line":189,"column":62,"nodeType":"Identifier","messageId":"unusedVar","endLine":189,"endColumn":68,"suggestions":[{"messageId":"removeVar","data":{"varName":"_index"},"fix":{"range":[5809,5817],"text":""},"desc":"Remove unused variable '_index'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CollaborationRound - Manages individual rounds within a collaborative session\r\n * \r\n * Each round has a specific purpose (propose, critique, synthesize, validate)\r\n * and manages the collection and processing of contributions from LLM participants.\r\n */\r\n\r\nimport { \r\n  CollaborationRound as ICollaborationRound,\r\n  RoundType,\r\n  Contribution,\r\n  RoundOutput,\r\n  LLMParticipant,\r\n  ConsensusLevel\r\n} from '../types/collaborationTypes';\r\nimport { logger } from '../../utils/logger';\r\n\r\nexport class CollaborationRound implements ICollaborationRound {\r\n  public id: string;\r\n  public sessionId: string;\r\n  public roundNumber: number;\r\n  public type: RoundType;\r\n  public purpose: string;\r\n  public timeLimit: number;\r\n  public startTime: Date;\r\n  public endTime?: Date;\r\n  public contributions: Contribution[] = [];\r\n  public roundOutput?: RoundOutput;\r\n  public status: 'pending' | 'active' | 'completed' | 'timeout' = 'pending';\r\n\r\n  constructor(\r\n    sessionId: string,\r\n    roundNumber: number,\r\n    type: RoundType,\r\n    purpose: string,\r\n    timeLimit: number\r\n  ) {\r\n    this.id = `round_${sessionId}_${roundNumber}_${type}`;\r\n    this.sessionId = sessionId;\r\n    this.roundNumber = roundNumber;\r\n    this.type = type;\r\n    this.purpose = purpose;\r\n    this.timeLimit = timeLimit;\r\n    this.startTime = new Date();\r\n  }\r\n\r\n  /**\r\n   * Add a contribution to this round\r\n   */\r\n  addContribution(contribution: Contribution): void {\r\n    if (this.status !== 'active') {\r\n      throw new Error(`Cannot add contribution to round ${this.id} with status ${this.status}`);\r\n    }\r\n\r\n    contribution.roundId = this.id;\r\n    this.contributions.push(contribution);\r\n    \r\n    logger.debug(`📝 Added contribution from ${contribution.author.provider} to round ${this.type}`);\r\n  }\r\n\r\n  /**\r\n   * Get contributions by participant\r\n   */\r\n  getContributionsByParticipant(participantId: string): Contribution[] {\r\n    return this.contributions.filter(c => c.author.id === participantId);\r\n  }\r\n\r\n  /**\r\n   * Get the average confidence score for this round\r\n   */\r\n  getAverageConfidence(): number {\r\n    if (this.contributions.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    const totalConfidence = this.contributions.reduce((sum, c) => sum + c.confidence, 0);\r\n    return totalConfidence / this.contributions.length;\r\n  }\r\n\r\n  /**\r\n   * Get total token count for this round\r\n   */\r\n  getTotalTokenCount(): number {\r\n    return this.contributions.reduce((sum, c) => sum + c.tokenCount, 0);\r\n  }\r\n\r\n  /**\r\n   * Check if all expected participants have contributed\r\n   */\r\n  hasAllContributions(expectedParticipants: LLMParticipant[]): boolean {\r\n    const contributorIds = new Set(this.contributions.map(c => c.author.id));\r\n    return expectedParticipants.every(p => contributorIds.has(p.id));\r\n  }\r\n\r\n  /**\r\n   * Generate round output summary\r\n   */\r\n  generateRoundOutput(): RoundOutput {\r\n    const consensusLevel = this.determineConsensusLevel();\r\n    const qualityScore = this.calculateQualityScore();\r\n    \r\n    this.roundOutput = {\r\n      roundId: this.id,\r\n      type: this.type,\r\n      synthesizedContent: this.synthesizeContributions(),\r\n      participatingContributions: this.contributions.map(c => c.id),\r\n      consensusLevel,\r\n      qualityScore,\r\n      emergenceIndicators: [], // TODO: Implement emergence detection\r\n      nextRoundRecommendation: this.recommendNextRound()\r\n    };\r\n\r\n    return this.roundOutput;\r\n  }\r\n\r\n  /**\r\n   * Determine consensus level based on contribution analysis\r\n   */\r\n  private determineConsensusLevel(): ConsensusLevel {\r\n    if (this.contributions.length === 0) {\r\n      return 'forced_consensus';\r\n    }\r\n\r\n    // Simple implementation - can be enhanced with semantic analysis\r\n    const agreements = this.analyzeAgreements();\r\n    \r\n    if (agreements >= 0.9) {\r\n      return 'unanimous';\r\n    } else if (agreements >= 0.66) {\r\n      return 'qualified_majority';\r\n    } else if (agreements >= 0.51) {\r\n      return 'simple_majority';\r\n    } else {\r\n      return 'forced_consensus';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze agreement levels between contributions\r\n   */\r\n  private analyzeAgreements(): number {\r\n    if (this.contributions.length <= 1) {\r\n      return 1.0; // Single contribution is 100% agreement with itself\r\n    }\r\n\r\n    // Simple implementation: average confidence as proxy for agreement\r\n    // TODO: Implement semantic similarity analysis\r\n    const avgConfidence = this.getAverageConfidence();\r\n    return avgConfidence / 100;\r\n  }\r\n\r\n  /**\r\n   * Calculate quality score for this round\r\n   */\r\n  private calculateQualityScore(): number {\r\n    if (this.contributions.length === 0) {\r\n      return 0;\r\n    }\r\n\r\n    // Factors: average confidence, contribution count, diversity\r\n    const avgConfidence = this.getAverageConfidence();\r\n    const contributionBonus = Math.min(this.contributions.length * 10, 30); // Up to 30 points for participation\r\n    const diversityBonus = this.calculateDiversityBonus();\r\n\r\n    return Math.min(100, avgConfidence + contributionBonus + diversityBonus);\r\n  }\r\n\r\n  /**\r\n   * Calculate diversity bonus based on different providers contributing\r\n   */\r\n  private calculateDiversityBonus(): number {\r\n    const uniqueProviders = new Set(this.contributions.map(c => c.author.provider));\r\n    return uniqueProviders.size * 5; // 5 points per unique provider\r\n  }\r\n\r\n  /**\r\n   * Synthesize contributions into a summary\r\n   */\r\n  private synthesizeContributions(): string {\r\n    if (this.contributions.length === 0) {\r\n      return `No contributions received for ${this.type} round.`;\r\n    }\r\n\r\n    if (this.contributions.length === 1) {\r\n      return this.contributions[0].content;\r\n    }\r\n\r\n    // Simple synthesis - can be enhanced with LLM-powered synthesis\r\n    const contributionSummaries = this.contributions.map((c, _index) => \r\n      `**${c.author.provider}** (Confidence: ${c.confidence}%): ${c.content.substring(0, 200)}...`\r\n    );\r\n\r\n    return `**${this.type.toUpperCase()} ROUND SYNTHESIS**\\n\\n${contributionSummaries.join('\\n\\n')}`;\r\n  }\r\n\r\n  /**\r\n   * Recommend the next round type based on current round results\r\n   */\r\n  private recommendNextRound(): RoundType | undefined {\r\n    const roundSequence: RoundType[] = ['propose', 'critique', 'synthesize', 'validate'];\r\n    const currentIndex = roundSequence.indexOf(this.type);\r\n    \r\n    if (currentIndex < roundSequence.length - 1) {\r\n      return roundSequence[currentIndex + 1];\r\n    }\r\n\r\n    // If we're at the last round, check if we need more iterations\r\n    const qualityScore = this.calculateQualityScore();\r\n    if (qualityScore < 70) {\r\n      return 'propose'; // Start over if quality is too low\r\n    }\r\n\r\n    return undefined; // No more rounds needed\r\n  }\r\n\r\n  /**\r\n   * Get round duration in milliseconds\r\n   */\r\n  getDuration(): number {\r\n    if (!this.endTime) {\r\n      return Date.now() - this.startTime.getTime();\r\n    }\r\n    return this.endTime.getTime() - this.startTime.getTime();\r\n  }\r\n\r\n  /**\r\n   * Check if round is within time limit\r\n   */\r\n  isWithinTimeLimit(): boolean {\r\n    return this.getDuration() <= this.timeLimit;\r\n  }\r\n\r\n  /**\r\n   * Get round statistics\r\n   */\r\n  getStatistics(): {\r\n    duration: number;\r\n    contributionCount: number;\r\n    averageConfidence: number;\r\n    totalTokens: number;\r\n    uniqueProviders: number;\r\n    qualityScore: number;\r\n  } {\r\n    return {\r\n      duration: this.getDuration(),\r\n      contributionCount: this.contributions.length,\r\n      averageConfidence: this.getAverageConfidence(),\r\n      totalTokens: this.getTotalTokenCount(),\r\n      uniqueProviders: new Set(this.contributions.map(c => c.author.provider)).size,\r\n      qualityScore: this.calculateQualityScore()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Complete the round and generate final output\r\n   */\r\n  complete(): RoundOutput {\r\n    this.status = 'completed';\r\n    this.endTime = new Date();\r\n    \r\n    const output = this.generateRoundOutput();\r\n    \r\n    logger.info(`✅ Round ${this.type} completed:`);\r\n    logger.debug(`   Duration: ${Math.round(this.getDuration()/1000)}s`);\r\n    logger.debug(`   Contributions: ${this.contributions.length}`);\r\n    logger.debug(`   Quality Score: ${output.qualityScore}`);\r\n    logger.debug(`   Consensus: ${output.consensusLevel}`);\r\n    \r\n    return output;\r\n  }\r\n\r\n  /**\r\n   * Mark round as timed out\r\n   */\r\n  timeout(): RoundOutput {\r\n    this.status = 'timeout';\r\n    this.endTime = new Date();\r\n    \r\n    const output = this.generateRoundOutput();\r\n    \r\n    logger.warn(`⏰ Round ${this.type} timed out:`);\r\n    logger.debug(`   Partial contributions: ${this.contributions.length}`);\r\n    logger.debug(`   Quality Score: ${output.qualityScore}`);\r\n    \r\n    return output;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\collaboration\\timing\\TimeManager.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'_CollaborationError' is defined but never used.","line":9,"column":77,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":96,"suggestions":[{"messageId":"removeVar","data":{"varName":"_CollaborationError"},"fix":{"range":[338,381],"text":""},"desc":"Remove unused variable '_CollaborationError'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_' is defined but never used.","line":180,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":180,"endColumn":18,"suggestions":[{"messageId":"removeVar","data":{"varName":"_"},"fix":{"range":[4978,4979],"text":""},"desc":"Remove unused variable '_'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_' is defined but never used.","line":181,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":181,"endColumn":19,"suggestions":[{"messageId":"removeVar","data":{"varName":"_"},"fix":{"range":[5025,5028],"text":""},"desc":"Remove unused variable '_'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'remaining' is defined but never used.","line":253,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":253,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"remaining"},"fix":{"range":[7069,7086],"text":""},"desc":"Remove unused variable 'remaining'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'remaining' is defined but never used.","line":281,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":281,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"remaining"},"fix":{"range":[7787,7804],"text":""},"desc":"Remove unused variable 'remaining'."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TimeManager - Handles time limits, timeouts, and warnings for collaborative sessions\r\n * \r\n * This class provides robust timing functionality with countdown warnings,\r\n * graceful timeout handling, and configurable time limits for different\r\n * collaboration scenarios.\r\n */\r\n\r\nimport { TimeManager as ITimeManager, TimerCallbacks, CollaborationError as _CollaborationError } from '../types/collaborationTypes';\r\nimport { logger } from '../../utils/logger';\r\n\r\ninterface ActiveTimer {\r\n  id: string;\r\n  startTime: Date;\r\n  duration: number; // milliseconds\r\n  callbacks?: TimerCallbacks;\r\n  warningsSent: boolean[];\r\n  isActive: boolean;\r\n  timeoutHandle?: NodeJS.Timeout;\r\n  warningHandles: NodeJS.Timeout[];\r\n}\r\n\r\nexport class TimeManager implements ITimeManager {\r\n  private timers: Map<string, ActiveTimer> = new Map();\r\n  private timerIdCounter = 0;\r\n\r\n  // Warning thresholds as percentages of total time\r\n  private readonly WARNING_THRESHOLDS = [0.75, 0.90]; // 75% and 90%\r\n\r\n  /**\r\n   * Start a new timer with specified duration and callbacks\r\n   */\r\n  startTimer(duration: number, callbacks?: TimerCallbacks): string {\r\n    const timerId = `timer_${++this.timerIdCounter}_${Date.now()}`;\r\n    const startTime = new Date();\r\n\r\n    const timer: ActiveTimer = {\r\n      id: timerId,\r\n      startTime,\r\n      duration,\r\n      callbacks,\r\n      warningsSent: new Array(this.WARNING_THRESHOLDS.length).fill(false),\r\n      isActive: true,\r\n      warningHandles: []\r\n    };\r\n\r\n    // Set up warning timers\r\n    this.setupWarningTimers(timer);\r\n\r\n    // Set up timeout timer\r\n    timer.timeoutHandle = setTimeout(() => {\r\n      this.handleTimeout(timerId);\r\n    }, duration);\r\n\r\n    this.timers.set(timerId, timer);\r\n\r\n    logger.debug(`⏰ Timer ${timerId} started for ${duration}ms`);\r\n    return timerId;\r\n  }\r\n\r\n  /**\r\n   * Stop an active timer\r\n   */\r\n  stopTimer(timerId: string): void {\r\n    const timer = this.timers.get(timerId);\r\n    if (!timer) {\r\n      logger.warn(`Timer ${timerId} not found`);\r\n      return;\r\n    }\r\n\r\n    timer.isActive = false;\r\n\r\n    // Clear timeout\r\n    if (timer.timeoutHandle) {\r\n      clearTimeout(timer.timeoutHandle);\r\n    }\r\n\r\n    // Clear warning timers\r\n    timer.warningHandles.forEach(handle => clearTimeout(handle));\r\n\r\n    this.timers.delete(timerId);\r\n    logger.debug(`⏰ Timer ${timerId} stopped`);\r\n  }\r\n\r\n  /**\r\n   * Get remaining time for a timer in milliseconds\r\n   */\r\n  getRemainingTime(timerId: string): number {\r\n    const timer = this.timers.get(timerId);\r\n    if (!timer || !timer.isActive) {\r\n      return 0;\r\n    }\r\n\r\n    const elapsed = Date.now() - timer.startTime.getTime();\r\n    const remaining = Math.max(0, timer.duration - elapsed);\r\n    return remaining;\r\n  }\r\n\r\n  /**\r\n   * Check if a timer has expired\r\n   */\r\n  isExpired(timerId: string): boolean {\r\n    const timer = this.timers.get(timerId);\r\n    if (!timer) {\r\n      return true; // Non-existent timers are considered expired\r\n    }\r\n\r\n    return !timer.isActive || this.getRemainingTime(timerId) <= 0;\r\n  }\r\n\r\n  /**\r\n   * Get timer progress as percentage (0-100)\r\n   */\r\n  getProgress(timerId: string): number {\r\n    const timer = this.timers.get(timerId);\r\n    if (!timer || !timer.isActive) {\r\n      return 100; // Completed or non-existent\r\n    }\r\n\r\n    const elapsed = Date.now() - timer.startTime.getTime();\r\n    const progress = Math.min(100, (elapsed / timer.duration) * 100);\r\n    return progress;\r\n  }\r\n\r\n  /**\r\n   * Extend a timer's duration\r\n   */\r\n  extendTimer(timerId: string, additionalTime: number): boolean {\r\n    const timer = this.timers.get(timerId);\r\n    if (!timer || !timer.isActive) {\r\n      return false;\r\n    }\r\n\r\n    // Clear existing timeout\r\n    if (timer.timeoutHandle) {\r\n      clearTimeout(timer.timeoutHandle);\r\n    }\r\n\r\n    // Clear existing warning timers\r\n    timer.warningHandles.forEach(handle => clearTimeout(handle));\r\n    timer.warningHandles = [];\r\n\r\n    // Update duration\r\n    timer.duration += additionalTime;\r\n\r\n    // Reset warnings\r\n    timer.warningsSent.fill(false);\r\n\r\n    // Set up new timers\r\n    this.setupWarningTimers(timer);\r\n    timer.timeoutHandle = setTimeout(() => {\r\n      this.handleTimeout(timerId);\r\n    }, this.getRemainingTime(timerId));\r\n\r\n    logger.debug(`⏰ Timer ${timerId} extended by ${additionalTime}ms`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get statistics for all active timers\r\n   */\r\n  getActiveTimerStats(): { count: number; timers: { id: string; remaining: number; progress: number }[] } {\r\n    const activeTimers = Array.from(this.timers.values()).filter(t => t.isActive);\r\n    \r\n    return {\r\n      count: activeTimers.length,\r\n      timers: activeTimers.map(timer => ({\r\n        id: timer.id,\r\n        remaining: this.getRemainingTime(timer.id),\r\n        progress: this.getProgress(timer.id)\r\n      }))\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clean up expired timers\r\n   */\r\n  cleanup(): void {\r\n    const expiredTimers = Array.from(this.timers.entries())\r\n      .filter(([_, timer]) => !timer.isActive)\r\n      .map(([id, _]) => id);\r\n\r\n    expiredTimers.forEach(timerId => {\r\n      this.timers.delete(timerId);\r\n    });\r\n\r\n    logger.debug(`⏰ Cleaned up ${expiredTimers.length} expired timers`);\r\n  }\r\n\r\n  /**\r\n   * Set up warning timers based on thresholds\r\n   */\r\n  private setupWarningTimers(timer: ActiveTimer): void {\r\n    if (!timer.callbacks?.onWarning) {\r\n      return; // No warning callback provided\r\n    }\r\n\r\n    this.WARNING_THRESHOLDS.forEach((threshold, index) => {\r\n      const warningTime = timer.duration * threshold;\r\n      \r\n      const warningHandle = setTimeout(() => {\r\n        if (timer.isActive && !timer.warningsSent[index]) {\r\n          timer.warningsSent[index] = true;\r\n          const remainingTime = this.getRemainingTime(timer.id);\r\n          \r\n          logger.warn(`⚠️ Timer ${timer.id} warning: ${remainingTime}ms remaining (${Math.round((1-threshold) * 100)}% left)`);\r\n          \r\n          try {\r\n            timer.callbacks!.onWarning!(remainingTime);\r\n          } catch (error) {\r\n            logger.error(`Error in warning callback for timer ${timer.id}:`, error);\r\n          }\r\n        }\r\n      }, warningTime);\r\n\r\n      timer.warningHandles.push(warningHandle);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle timer timeout\r\n   */\r\n  private handleTimeout(timerId: string): void {\r\n    const timer = this.timers.get(timerId);\r\n    if (!timer || !timer.isActive) {\r\n      return;\r\n    }\r\n\r\n    timer.isActive = false;\r\n\r\n    logger.warn(`⏰ Timer ${timerId} expired`);\r\n\r\n    // Call timeout callback if provided\r\n    if (timer.callbacks?.onTimeout) {\r\n      try {\r\n        timer.callbacks.onTimeout();\r\n      } catch (error) {\r\n        logger.error(`Error in timeout callback for timer ${timerId}:`, error);\r\n      }\r\n    }\r\n\r\n    // Clean up warning timers\r\n    timer.warningHandles.forEach(handle => clearTimeout(handle));\r\n    timer.warningHandles = [];\r\n  }\r\n\r\n  /**\r\n   * Create a timer for a collaboration round with standard settings\r\n   */\r\n  createRoundTimer(\r\n    roundType: string,\r\n    duration: number,\r\n    onWarning?: (remaining: number) => void,\r\n    onTimeout?: () => void\r\n  ): string {\r\n    const callbacks: TimerCallbacks = {};\r\n    \r\n    if (onWarning) {\r\n      callbacks.onWarning = (remaining) => {\r\n        logger.warn(`⚠️ Round ${roundType} time warning: ${Math.round(remaining/1000)}s remaining`);\r\n        onWarning(remaining);\r\n      };\r\n    }\r\n\r\n    if (onTimeout) {\r\n      callbacks.onTimeout = () => {\r\n        logger.warn(`⏰ Round ${roundType} timeout reached`);\r\n        onTimeout();\r\n      };\r\n    }\r\n\r\n    return this.startTimer(duration, callbacks);\r\n  }\r\n\r\n  /**\r\n   * Create a timer for an entire collaboration session\r\n   */\r\n  createSessionTimer(\r\n    sessionId: string,\r\n    duration: number,\r\n    onWarning?: (remaining: number) => void,\r\n    onTimeout?: () => void\r\n  ): string {\r\n    const callbacks: TimerCallbacks = {};\r\n    \r\n    if (onWarning) {\r\n      callbacks.onWarning = (remaining) => {\r\n        logger.warn(`⚠️ Session ${sessionId} time warning: ${Math.round(remaining/1000)}s remaining`);\r\n        onWarning(remaining);\r\n      };\r\n    }\r\n\r\n    if (onTimeout) {\r\n      callbacks.onTimeout = () => {\r\n        logger.warn(`⏰ Session ${sessionId} timeout - forcing consensus`);\r\n        onTimeout();\r\n      };\r\n    }\r\n\r\n    return this.startTimer(duration, callbacks);\r\n  }\r\n\r\n  /**\r\n   * Dispose of all timers and clean up resources\r\n   */\r\n  dispose(): void {\r\n    logger.debug('⏰ TimeManager disposing all timers...');\r\n    \r\n    for (const [timerId] of this.timers) {\r\n      this.stopTimer(timerId);\r\n    }\r\n    \r\n    this.timers.clear();\r\n    this.timerIdCounter = 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton instance for global use\r\n */\r\nexport const timeManager = new TimeManager();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\collaboration\\types\\collaborationTypes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":235,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6400,6403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6400,6403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'code' is defined but never used.","line":244,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":244,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"code"},"fix":{"range":[6568,6580],"text":""},"desc":"Remove unused variable 'code'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'sessionId' is defined but never used.","line":245,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":245,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"sessionId"},"fix":{"range":[6594,6612],"text":""},"desc":"Remove unused variable 'sessionId'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'roundId' is defined but never used.","line":246,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":246,"endColumn":28,"suggestions":[{"messageId":"removeVar","data":{"varName":"roundId"},"fix":{"range":[6626,6642],"text":""},"desc":"Remove unused variable 'roundId'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'duration' is defined but never used.","line":257,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":257,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"duration"},"fix":{"range":[6815,6832],"text":""},"desc":"Remove unused variable 'duration'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'callbacks' is defined but never used.","line":257,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":257,"endColumn":58,"suggestions":[{"messageId":"removeVar","data":{"varName":"callbacks"},"fix":{"range":[6831,6859],"text":""},"desc":"Remove unused variable 'callbacks'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'timerId' is defined but never used.","line":258,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":258,"endColumn":28,"suggestions":[{"messageId":"removeVar","data":{"varName":"timerId"},"fix":{"range":[6883,6898],"text":""},"desc":"Remove unused variable 'timerId'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'timerId' is defined but never used.","line":259,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":259,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"timerId"},"fix":{"range":[6927,6942],"text":""},"desc":"Remove unused variable 'timerId'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'timerId' is defined but never used.","line":260,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":260,"endColumn":28,"suggestions":[{"messageId":"removeVar","data":{"varName":"timerId"},"fix":{"range":[6966,6981],"text":""},"desc":"Remove unused variable 'timerId'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'remainingTime' is defined but never used.","line":264,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":264,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"remainingTime"},"fix":{"range":[7049,7070],"text":""},"desc":"Remove unused variable 'remainingTime'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'remainingTime' is defined but never used.","line":266,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":266,"endColumn":34,"suggestions":[{"messageId":"removeVar","data":{"varName":"remainingTime"},"fix":{"range":[7121,7142],"text":""},"desc":"Remove unused variable 'remainingTime'."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Core type definitions for the True Multi-LLM Collaboration System\r\n * \r\n * This file defines all interfaces, types, and enums used throughout\r\n * the collaboration system to ensure type safety and consistency.\r\n */\r\n\r\nexport type LLMProvider = 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter';\r\nexport type SessionStatus = 'initializing' | 'active' | 'consensus_reached' | 'timeout' | 'completed' | 'failed';\r\nexport type RoundType = 'propose' | 'critique' | 'synthesize' | 'validate';\r\nexport type ConsensusLevel = 'unanimous' | 'qualified_majority' | 'simple_majority' | 'forced_consensus';\r\n\r\n/**\r\n * Core collaboration session interface\r\n */\r\nexport interface CollaborativeSession {\r\n  id: string;\r\n  initiator: string;\r\n  participants: LLMParticipant[];\r\n  rounds: CollaborationRound[];\r\n  request: CollaborationRequest;\r\n  timeLimit: number; // in milliseconds\r\n  consensusThreshold: number; // percentage (0-100)\r\n  status: SessionStatus;\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  metrics: SessionMetrics;\r\n  output?: CollaborativeOutput;\r\n}\r\n\r\n/**\r\n * LLM participant in a collaborative session\r\n */\r\nexport interface LLMParticipant {\r\n  id: string;\r\n  provider: LLMProvider;\r\n  model: string;\r\n  role: string;\r\n  strengths: string[];\r\n  specializations: string[];\r\n  performanceHistory: PerformanceRecord[];\r\n  isActive: boolean;\r\n  currentLoad: number; // 0-100 percentage\r\n}\r\n\r\n/**\r\n * Individual collaboration round\r\n */\r\nexport interface CollaborationRound {\r\n  id: string;\r\n  sessionId: string;\r\n  roundNumber: number;\r\n  type: RoundType;\r\n  purpose: string;\r\n  timeLimit: number;\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  contributions: Contribution[];\r\n  roundOutput?: RoundOutput;\r\n  status: 'pending' | 'active' | 'completed' | 'timeout';\r\n}\r\n\r\n/**\r\n * Individual contribution from an LLM participant\r\n */\r\nexport interface Contribution {\r\n  id: string;\r\n  roundId: string;\r\n  author: LLMParticipant;\r\n  content: string;\r\n  confidence: number; // 0-100\r\n  buildUpon: string[]; // IDs of contributions this builds upon\r\n  critiques: string[]; // IDs of contributions this critiques\r\n  timestamp: Date;\r\n  tokenCount: number;\r\n  metadata: ContributionMetadata;\r\n}\r\n\r\n/**\r\n * Metadata for contributions\r\n */\r\nexport interface ContributionMetadata {\r\n  processingTime: number; // milliseconds\r\n  retryCount: number;\r\n  qualityScore?: number;\r\n  semanticSimilarity?: number;\r\n  innovationScore?: number;\r\n  technicalAccuracy?: number;\r\n}\r\n\r\n/**\r\n * Output from a collaboration round\r\n */\r\nexport interface RoundOutput {\r\n  roundId: string;\r\n  type: RoundType;\r\n  synthesizedContent: string;\r\n  participatingContributions: string[]; // contribution IDs\r\n  consensusLevel: ConsensusLevel;\r\n  qualityScore: number;\r\n  emergenceIndicators: EmergenceMetric[];\r\n  nextRoundRecommendation?: RoundType;\r\n}\r\n\r\n/**\r\n * Final output from a collaborative session\r\n */\r\nexport interface CollaborativeOutput {\r\n  sessionId: string;\r\n  content: string;\r\n  sources: Contribution[];\r\n  rounds: RoundOutput[];\r\n  emergenceIndicators: EmergenceMetric[];\r\n  qualityScore: number;\r\n  consensusLevel: ConsensusLevel;\r\n  synthesisLog: SynthesisStep[];\r\n  improvementMetrics: ImprovementMetric[];\r\n  tokenUsage: TokenUsageMetrics;\r\n}\r\n\r\n/**\r\n * Request to initiate a collaborative session\r\n */\r\nexport interface CollaborationRequest {\r\n  prompt: string;\r\n  context?: string;\r\n  requirements?: string[];\r\n  constraints?: string[];\r\n  preferredParticipants?: LLMProvider[];\r\n  maxRounds?: number;\r\n  timeLimit?: number;\r\n  consensusThreshold?: number;\r\n  qualityThreshold?: number;\r\n  costBudget?: number; // in tokens\r\n  priority: 'low' | 'medium' | 'high' | 'critical';\r\n}\r\n\r\n/**\r\n * Metrics for tracking session performance\r\n */\r\nexport interface SessionMetrics {\r\n  totalDuration: number;\r\n  roundCount: number;\r\n  contributionCount: number;\r\n  consensusAchieved: boolean;\r\n  consensusTime?: number;\r\n  qualityImprovement: number; // percentage vs single-LLM baseline\r\n  tokenEfficiency: number; // quality per token\r\n  participantUtilization: Record<string, number>; // participant ID -> utilization %\r\n  emergenceScore: number; // measure of emergent intelligence\r\n}\r\n\r\n/**\r\n * Performance record for LLM participants\r\n */\r\nexport interface PerformanceRecord {\r\n  sessionId: string;\r\n  taskType: string;\r\n  qualityScore: number;\r\n  contributionValue: number;\r\n  collaborationEffectiveness: number;\r\n  tokenEfficiency: number;\r\n  timestamp: Date;\r\n}\r\n\r\n/**\r\n * Metrics indicating emergent intelligence\r\n */\r\nexport interface EmergenceMetric {\r\n  type: 'novel_solution' | 'synthesis_quality' | 'collective_insight' | 'innovation_leap';\r\n  score: number; // 0-100\r\n  description: string;\r\n  evidence: string[];\r\n  contributingSources: string[]; // contribution IDs\r\n}\r\n\r\n/**\r\n * Step in the synthesis process\r\n */\r\nexport interface SynthesisStep {\r\n  stepNumber: number;\r\n  operation: 'merge' | 'resolve_conflict' | 'enhance' | 'validate';\r\n  inputs: string[]; // contribution IDs\r\n  output: string;\r\n  reasoning: string;\r\n  confidenceScore: number;\r\n}\r\n\r\n/**\r\n * Metrics showing improvement over single-LLM baseline\r\n */\r\nexport interface ImprovementMetric {\r\n  dimension: 'quality' | 'innovation' | 'completeness' | 'accuracy' | 'creativity';\r\n  baselineScore: number;\r\n  collaborativeScore: number;\r\n  improvement: number; // percentage\r\n  significance: 'minor' | 'moderate' | 'major' | 'breakthrough';\r\n}\r\n\r\n/**\r\n * Token usage tracking\r\n */\r\nexport interface TokenUsageMetrics {\r\n  totalTokens: number;\r\n  tokensPerParticipant: Record<string, number>;\r\n  tokensPerRound: Record<number, number>;\r\n  efficiency: number; // quality score per token\r\n  budgetUtilization: number; // percentage of budget used\r\n  costEstimate: number; // in USD\r\n}\r\n\r\n/**\r\n * Configuration for collaboration system\r\n */\r\nexport interface CollaborationConfig {\r\n  defaultTimeLimit: number;\r\n  defaultConsensusThreshold: number;\r\n  maxParticipants: number;\r\n  maxRounds: number;\r\n  qualityThreshold: number;\r\n  tokenBudgetDefault: number;\r\n  enableCaching: boolean;\r\n  enableLearning: boolean;\r\n  debugMode: boolean;\r\n}\r\n\r\n/**\r\n * Events emitted by the collaboration system\r\n */\r\nexport interface CollaborationEvent {\r\n  type: 'session_started' | 'round_started' | 'contribution_received' | \r\n        'consensus_reached' | 'timeout_warning' | 'session_completed' | 'error';\r\n  sessionId: string;\r\n  timestamp: Date;\r\n  data: any;\r\n}\r\n\r\n/**\r\n * Error types specific to collaboration system\r\n */\r\nexport class CollaborationError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public code: string,\r\n    public sessionId?: string,\r\n    public roundId?: string\r\n  ) {\r\n    super(message);\r\n    this.name = 'CollaborationError';\r\n  }\r\n}\r\n\r\n/**\r\n * Time management related interfaces\r\n */\r\nexport interface TimeManager {\r\n  startTimer(duration: number, callbacks?: TimerCallbacks): string;\r\n  stopTimer(timerId: string): void;\r\n  getRemainingTime(timerId: string): number;\r\n  isExpired(timerId: string): boolean;\r\n}\r\n\r\nexport interface TimerCallbacks {\r\n  onWarning?: (remainingTime: number) => void;\r\n  onTimeout?: () => void;\r\n  onTick?: (remainingTime: number) => void;\r\n}\r\n\r\n/**\r\n * Consensus building interfaces\r\n */\r\nexport interface ConsensusResult {\r\n  achieved: boolean;\r\n  level: ConsensusLevel;\r\n  agreement: number; // percentage\r\n  dissent: string[]; // minority opinions\r\n  finalDecision: string;\r\n  votingRecord?: VotingRecord;\r\n}\r\n\r\nexport interface VotingRecord {\r\n  options: string[];\r\n  votes: Record<string, string>; // participant ID -> voted option\r\n  results: Record<string, number>; // option -> vote count\r\n  winner: string;\r\n  margin: number; // percentage\r\n}\r\n\r\n/**\r\n * Task assignment interfaces\r\n */\r\nexport interface TaskAssignment {\r\n  taskId: string;\r\n  assignedParticipant: string; // participant ID\r\n  rationale: string;\r\n  specialization: string;\r\n  priority: number;\r\n  dependencies: string[]; // other task IDs\r\n  estimatedTokens: number;\r\n  estimatedDuration: number; // milliseconds\r\n}\r\n\r\nexport interface StrengthProfile {\r\n  participantId: string;\r\n  strengths: Record<string, number>; // strength category -> score (0-100)\r\n  weaknesses: string[];\r\n  specializations: string[];\r\n  historicalAccuracy: number;\r\n  adaptabilityScore: number;\r\n  collaborationScore: number;\r\n  lastUpdated: Date;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\db\\vectorDB.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[180,183],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[180,183],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":36,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":36,"endColumn":21,"suggestions":[{"fix":{"range":[1074,1129],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1236,1239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1236,1239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":98,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":98,"endColumn":21,"suggestions":[{"fix":{"range":[2805,2871],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":122,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":122,"endColumn":21,"suggestions":[{"fix":{"range":[3571,3630],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":126,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":126,"endColumn":18,"suggestions":[{"fix":{"range":[3694,3817],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3862,3865],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3862,3865],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":131,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":131,"endColumn":19,"suggestions":[{"fix":{"range":[3875,3946],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":138,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":138,"endColumn":16,"suggestions":[{"fix":{"range":[4117,4168],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5496,5499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5496,5499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":179,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":179,"endColumn":21,"suggestions":[{"fix":{"range":[5511,5568],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as path from 'path';\nimport * as fs from 'fs';\nimport { HfInference } from '@huggingface/inference';\n\ninterface VectorItem {\n  id: string;\n  vector: number[];\n  metadata: any;\n}\n\nexport class VectorDB {\n  private items: VectorItem[] = [];\n  private storagePath: string;\n  private hf: HfInference;\n  private embeddingModel = 'sentence-transformers/all-MiniLM-L6-v2';\n\n  constructor(storagePath: string) {\n    this.storagePath = path.join(storagePath, 'vectordb');\n    // Initialize Hugging Face inference - will use public API or user's token if set\n    this.hf = new HfInference(process.env.HUGGINGFACE_API_TOKEN);\n  }\n\n  async init() {\n    // Ensure storage directory exists\n    if (!fs.existsSync(this.storagePath)) {\n      fs.mkdirSync(this.storagePath, { recursive: true });\n    }\n\n    // Load existing data if available\n    const dataPath = path.join(this.storagePath, 'vectors.json');\n    if (fs.existsSync(dataPath)) {\n      try {\n        const data = fs.readFileSync(dataPath, 'utf8');\n        this.items = JSON.parse(data);\n      } catch (error) {\n        console.warn('Failed to load vector database:', error);\n        this.items = [];\n      }\n    }\n  }\n\n  async addEmbedding(key: string, vector: number[], metadata: any) {\n    const existingIndex = this.items.findIndex(item => item.id === key);\n    if (existingIndex >= 0) {\n      this.items[existingIndex] = { id: key, vector, metadata };\n    } else {\n      this.items.push({ id: key, vector, metadata });\n    }\n    await this.save();\n  }\n\n  async queryEmbedding(\n    vector: number[],\n    topK: number = 5\n  ): Promise<(VectorItem & { similarity: number })[]> {\n    // Simple cosine similarity implementation\n    const similarities = this.items.map(item => ({\n      item,\n      similarity: this.cosineSimilarity(vector, item.vector),\n    }));\n\n    similarities.sort((a, b) => b.similarity - a.similarity);\n    return similarities.slice(0, topK).map(s => ({ ...s.item, similarity: s.similarity }));\n  }\n\n  private cosineSimilarity(a: number[], b: number[]): number {\n    if (a.length !== b.length) return 0;\n\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n  }\n\n  async save() {\n    const dataPath = path.join(this.storagePath, 'vectors.json');\n    fs.writeFileSync(dataPath, JSON.stringify(this.items, null, 2));\n  }\n\n  close() {\n    // Cleanup if needed\n  }\n\n  // Real embedding implementation using Hugging Face\n  async getEmbedding(text: string): Promise<number[]> {\n    try {\n      // Clean and prepare text for embedding\n      const cleanText = text.replace(/\\s+/g, ' ').trim();\n\n      if (!cleanText) {\n        console.warn('Empty text provided for embedding, using fallback');\n        return this.getFallbackEmbedding(text);\n      }\n\n      // Use Hugging Face inference for real embeddings\n      const response = await this.hf.featureExtraction({\n        model: this.embeddingModel,\n        inputs: cleanText,\n      });\n\n      // Handle different response formats\n      let embedding: number[];\n      if (Array.isArray(response)) {\n        if (Array.isArray(response[0])) {\n          embedding = response[0] as number[];\n        } else {\n          embedding = response as number[];\n        }\n      } else {\n        throw new Error('Unexpected response format from embedding API');\n      }\n\n      // Validate embedding\n      if (!embedding || embedding.length === 0) {\n        console.warn('Invalid embedding received, using fallback');\n        return this.getFallbackEmbedding(text);\n      }\n\n      console.log(\n        `Generated embedding for \"${cleanText.substring(0, 50)}...\" (${embedding.length} dimensions)`\n      );\n      return embedding;\n    } catch (error: any) {\n      console.warn(`Embedding API failed: ${error.message}, using fallback`);\n      return this.getFallbackEmbedding(text);\n    }\n  }\n\n  // Fallback embedding for when API is unavailable\n  private getFallbackEmbedding(text: string): number[] {\n    console.log('Using fallback embedding generation');\n    const hash = this.simpleHash(text);\n    const embedding = new Array(384).fill(0); // Standard embedding dimension\n\n    // Create a deterministic but distributed embedding based on text\n    for (let i = 0; i < embedding.length; i++) {\n      embedding[i] = Math.sin((hash + i) * 0.1) * Math.cos((hash + i) * 0.2);\n    }\n\n    return embedding;\n  }\n\n  private simpleHash(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n  }\n\n  // Batch embedding for efficiency\n  async getBatchEmbeddings(texts: string[]): Promise<number[][]> {\n    const embeddings: number[][] = [];\n\n    // Process in batches to avoid rate limits\n    const batchSize = 5;\n    for (let i = 0; i < texts.length; i += batchSize) {\n      const batch = texts.slice(i, i + batchSize);\n      const batchPromises = batch.map(text => this.getEmbedding(text));\n\n      try {\n        const batchResults = await Promise.all(batchPromises);\n        embeddings.push(...batchResults);\n\n        // Small delay to respect rate limits\n        if (i + batchSize < texts.length) {\n          await new Promise(resolve => setTimeout(resolve, 100));\n        }\n      } catch (error: any) {\n        console.warn(`Batch embedding failed: ${error.message}`);\n        // Add fallback embeddings for failed batch\n        for (const text of batch) {\n          embeddings.push(this.getFallbackEmbedding(text));\n        }\n      }\n    }\n\n    return embeddings;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\extension.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[184,187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[184,187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[203,206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[203,206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[229,232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[229,232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[250,253],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[250,253],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":15,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":15,"endColumn":14,"suggestions":[{"fix":{"range":[325,401],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":26,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":14,"suggestions":[{"fix":{"range":[644,690],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1534,1537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1534,1537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'context' is defined but never used.","line":122,"column":35,"nodeType":"Identifier","messageId":"unusedVar","endLine":122,"endColumn":67,"suggestions":[{"messageId":"removeVar","data":{"varName":"context"},"fix":{"range":[3979,4011],"text":""},"desc":"Remove unused variable 'context'."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":129,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":129,"endColumn":20,"suggestions":[{"fix":{"range":[4262,4313],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AstraForge IDE Extension Entry Point\n * Optimized for fast activation with lazy loading\n */\n\nimport * as vscode from 'vscode';\n\n// Lazy-loaded module references\nlet llmManager: any;\nlet vectorDB: any;\nlet workflowManager: any;\nlet gitManager: any;\n\nexport async function activate(context: vscode.ExtensionContext) {\n  console.log('AstraForge IDE activated! Launching into the stratosphere...');\n\n  // Register providers immediately but lazy-load heavy modules\n  await registerProviders(context);\n\n  // Register commands\n  registerCommands(context);\n\n  // Initialize heavy modules only when needed\n  await initializeManagers(context);\n\n  console.log('AstraForge IDE fully activated');\n}\n\n/**\n * Register webview providers immediately for UI responsiveness\n */\nasync function registerProviders(context: vscode.ExtensionContext) {\n  // Setup Wizard - lightweight, load immediately\n  const { SetupWizardProvider } = await import('./providers/setupWizard');\n  const setupWizard = new SetupWizardProvider(context.extensionUri);\n  context.subscriptions.push(\n    vscode.window.registerWebviewViewProvider('astraforge.setupWizard', setupWizard)\n  );\n\n  // API Tester - load immediately for testing\n  const { ApiTesterProvider } = await import('./testing/apiTesterProvider');\n  const apiTester = new ApiTesterProvider(context.extensionUri);\n  context.subscriptions.push(\n    vscode.window.registerWebviewViewProvider('astraforge.apiTester', apiTester)\n  );\n\n  // Project Ignition - delay until workflow is needed\n  let projectIgnition: any;\n  const getProjectIgnition = async () => {\n    if (!projectIgnition) {\n      const { ProjectIgnitionProvider } = await import('./providers/projectIgnition');\n      await ensureWorkflowManager(context);\n      projectIgnition = new ProjectIgnitionProvider(context.extensionUri, workflowManager);\n    }\n    return projectIgnition;\n  };\n\n  context.subscriptions.push(\n    vscode.window.registerWebviewViewProvider('astraforge.projectIgnition', {\n      resolveWebviewView: async (webviewView, context, token) => {\n        const provider = await getProjectIgnition();\n        return provider.resolveWebviewView(webviewView, context, token);\n      },\n    })\n  );\n}\n\n/**\n * Register extension commands\n */\nfunction registerCommands(context: vscode.ExtensionContext) {\n  context.subscriptions.push(\n    vscode.commands.registerCommand('astraforge.setupPanel', async () => {\n      await vscode.commands.executeCommand('workbench.action.focusSideBar');\n      await vscode.commands.executeCommand('workbench.view.extension.astraforge-activitybar');\n    })\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand('astraforge.submitIdea', async (idea: string) => {\n      await ensureWorkflowManager(context);\n      workflowManager.startWorkflow(idea);\n    })\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand('astraforge.proceedPhase', async () => {\n      await ensureWorkflowManager(context);\n      workflowManager.proceedToNextPhase();\n    })\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand('astraforge.testAPIs', async () => {\n      await vscode.commands.executeCommand('workbench.action.focusSideBar');\n      await vscode.commands.executeCommand('workbench.view.extension.astraforge-activitybar');\n    })\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand('astraforge.clearCache', async () => {\n      await ensureLLMManager();\n      llmManager.clearCache();\n      vscode.window.showInformationMessage('LLM cache cleared');\n    })\n  );\n\n  context.subscriptions.push(\n    vscode.commands.registerCommand('astraforge.showCacheStats', async () => {\n      await ensureLLMManager();\n      const stats = llmManager.getCacheStats();\n      vscode.window.showInformationMessage(\n        `Cache Stats - Size: ${stats.cacheSize}, Throttled: ${stats.throttleEntries}`\n      );\n    })\n  );\n}\n\n/**\n * Initialize heavy managers only when needed\n */\nasync function initializeManagers(context: vscode.ExtensionContext) {\n  // Auto-init Git if workspace is open (lightweight)\n  if (vscode.workspace.workspaceFolders) {\n    await ensureGitManager();\n    try {\n      await gitManager.initRepo(vscode.workspace.workspaceFolders[0].uri.fsPath);\n    } catch (error) {\n      console.error('Git initialization failed:', error);\n    }\n  }\n}\n\n/**\n * Lazy-load LLM Manager\n */\nasync function ensureLLMManager() {\n  if (!llmManager) {\n    const { LLMManager } = await import('./llm/llmManager');\n    llmManager = new LLMManager();\n  }\n  return llmManager;\n}\n\n/**\n * Lazy-load Vector DB\n */\nasync function ensureVectorDB(context: vscode.ExtensionContext) {\n  if (!vectorDB) {\n    const { VectorDB } = await import('./db/vectorDB');\n    vectorDB = new VectorDB(context.extensionUri.fsPath);\n    await vectorDB.init();\n  }\n  return vectorDB;\n}\n\n/**\n * Lazy-load Git Manager\n */\nasync function ensureGitManager() {\n  if (!gitManager) {\n    const { GitManager } = await import('./git/gitManager');\n    gitManager = new GitManager();\n  }\n  return gitManager;\n}\n\n/**\n * Lazy-load Workflow Manager (depends on other managers)\n */\nasync function ensureWorkflowManager(context: vscode.ExtensionContext) {\n  if (!workflowManager) {\n    await Promise.all([ensureLLMManager(), ensureVectorDB(context), ensureGitManager()]);\n\n    const { WorkflowManager } = await import('./workflow/workflowManager');\n    workflowManager = new WorkflowManager(llmManager, vectorDB, gitManager);\n  }\n  return workflowManager;\n}\n\nexport function deactivate() {\n  if (vectorDB) {\n    vectorDB.close();\n  }\n\n  if (llmManager) {\n    llmManager.clearCache();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\git\\gitManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[610,613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[610,613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1487,1490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1487,1490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2087,2090],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2087,2090],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2570,2573],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2570,2573],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\n\nexport class GitManager {\n  private workspacePath: string | undefined;\n\n  async initRepo(path: string) {\n    this.workspacePath = path;\n    try {\n      // Check if git is already initialized\n      await execAsync('git status', { cwd: path });\n    } catch {\n      // Git not initialized, initialize it\n      try {\n        await execAsync('git init', { cwd: path });\n        vscode.window.showInformationMessage('Git repository initialized');\n      } catch (initError: any) {\n        vscode.window.showErrorMessage(`Failed to initialize Git: ${initError.message}`);\n      }\n    }\n  }\n\n  async commit(message: string) {\n    if (!this.workspacePath) {\n      vscode.window.showWarningMessage('Git workspace not initialized');\n      return;\n    }\n\n    try {\n      // Add all changes\n      await execAsync('git add .', { cwd: this.workspacePath });\n\n      // Check if there are changes to commit\n      const { stdout: status } = await execAsync('git status --porcelain', {\n        cwd: this.workspacePath,\n      });\n\n      if (status.trim()) {\n        // There are changes to commit\n        await execAsync(`git commit -m \"${message}\"`, { cwd: this.workspacePath });\n        vscode.window.showInformationMessage(`Committed: ${message}`);\n      } else {\n        vscode.window.showInformationMessage('No changes to commit');\n      }\n    } catch (error: any) {\n      // Handle case where git user is not configured\n      if (error.message.includes('user.email') || error.message.includes('user.name')) {\n        try {\n          await execAsync('git config user.email \"astraforge@example.com\"', {\n            cwd: this.workspacePath,\n          });\n          await execAsync('git config user.name \"AstraForge\"', { cwd: this.workspacePath });\n          // Retry commit\n          await execAsync(`git commit -m \"${message}\"`, { cwd: this.workspacePath });\n          vscode.window.showInformationMessage(`Committed: ${message}`);\n        } catch (retryError: any) {\n          vscode.window.showErrorMessage(`Git commit failed: ${retryError.message}`);\n        }\n      } else {\n        vscode.window.showErrorMessage(`Git commit failed: ${error.message}`);\n      }\n    }\n  }\n\n  async getStatus(): Promise<string> {\n    if (!this.workspacePath) {\n      return 'Git workspace not initialized';\n    }\n\n    try {\n      const { stdout } = await execAsync('git status --short', { cwd: this.workspacePath });\n      return stdout;\n    } catch (error: any) {\n      return `Git status failed: ${error.message}`;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\interfaces.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[487,490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[487,490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'prompt' is defined but never used.","line":32,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"prompt"},"fix":{"range":[706,721],"text":""},"desc":"Remove unused variable 'prompt'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'config' is defined but never used.","line":32,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":32,"endColumn":42,"suggestions":[{"messageId":"removeVar","data":{"varName":"config"},"fix":{"range":[720,739],"text":""},"desc":"Remove unused variable 'config'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'config' is defined but never used.","line":39,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":39,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"config"},"fix":{"range":[929,946],"text":""},"desc":"Remove unused variable 'config'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'config' is defined but never used.","line":46,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":39,"suggestions":[{"messageId":"removeVar","data":{"varName":"config"},"fix":{"range":[1139,1156],"text":""},"desc":"Remove unused variable 'config'."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LLM Provider Interfaces for AstraForge\n * Provides clean abstraction for different LLM providers\n */\n\nexport interface LLMConfig {\n  provider: 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter';\n  key: string;\n  model: string;\n  role: 'primary' | 'secondary';\n  maxTokens?: number;\n  temperature?: number;\n}\n\nexport interface LLMResponse {\n  content: string;\n  usage?: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n  metadata?: Record<string, any>;\n}\n\nexport interface LLMProvider {\n  /**\n   * Query the LLM with a prompt\n   * @param prompt The input prompt\n   * @param config Provider configuration\n   * @returns Promise resolving to LLM response\n   */\n  query(prompt: string, config: LLMConfig): Promise<LLMResponse>;\n\n  /**\n   * Validate API key and configuration\n   * @param config Provider configuration\n   * @returns Promise resolving to validation result\n   */\n  validateConfig(config: LLMConfig): Promise<boolean>;\n\n  /**\n   * Get available models for this provider\n   * @param config Provider configuration\n   * @returns Promise resolving to available models\n   */\n  getAvailableModels(config: LLMConfig): Promise<string[]>;\n}\n\nexport interface VoteResult {\n  option: string;\n  votes: number;\n  confidence: number;\n}\n\nexport interface ConferenceResult {\n  finalResult: string;\n  discussionHistory: string[];\n  consensus: number; // 0-1 scale\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\llmManager.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'LLMResponse' is defined but never used.","line":7,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":45,"suggestions":[{"messageId":"removeVar","data":{"varName":"LLMResponse"},"fix":{"range":[206,219],"text":""},"desc":"Remove unused variable 'LLMResponse'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'VoteResult' is defined but never used.","line":7,"column":47,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":57,"suggestions":[{"messageId":"removeVar","data":{"varName":"VoteResult"},"fix":{"range":[219,231],"text":""},"desc":"Remove unused variable 'VoteResult'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'ConferenceResult' is defined but never used.","line":7,"column":59,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":75,"suggestions":[{"messageId":"removeVar","data":{"varName":"ConferenceResult"},"fix":{"range":[231,249],"text":""},"desc":"Remove unused variable 'ConferenceResult'."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":41,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":41,"endColumn":24,"suggestions":[{"fix":{"range":[1308,1382],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2406,2409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2406,2409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'voteOnDecision' has too many lines (59). Maximum allowed is 50.","line":94,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":152,"endColumn":4},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":147,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":147,"endColumn":16,"suggestions":[{"fix":{"range":[4510,4637],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6903,6906],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6903,6906],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Refactored LLM Manager with modular provider architecture\n * Supports parallel requests, caching, and clean provider abstraction\n */\n\nimport * as vscode from 'vscode';\nimport { LLMConfig, LLMProvider, LLMResponse, VoteResult, ConferenceResult } from './interfaces';\nimport { createProvider } from './providers';\nimport { LLMCache } from './cache';\n\nexport class LLMManager {\n  private panel: LLMConfig[] = [];\n  private providers = new Map<string, LLMProvider>();\n  private cache: LLMCache;\n  private readonly maxConcurrentRequests: number;\n\n  constructor() {\n    this.panel = vscode.workspace.getConfiguration('astraforge').get('llmPanel', []);\n    this.cache = new LLMCache(\n      3600, // 1 hour TTL\n      60, // 60 requests per minute\n      60000 // 1 minute window\n    );\n    this.maxConcurrentRequests = vscode.workspace\n      .getConfiguration('astraforge')\n      .get('maxConcurrentRequests', 3);\n\n    this.initializeProviders();\n  }\n\n  /**\n   * Initialize providers for all configured LLMs\n   */\n  private initializeProviders(): void {\n    for (const config of this.panel) {\n      if (!this.providers.has(config.provider)) {\n        try {\n          const provider = createProvider(config.provider);\n          this.providers.set(config.provider, provider);\n        } catch (error) {\n          console.error(`Failed to initialize provider ${config.provider}:`, error);\n        }\n      }\n    }\n  }\n\n  /**\n   * Query a specific LLM by index with caching and error handling\n   */\n  async queryLLM(index: number, prompt: string): Promise<string> {\n    const config = this.panel[index];\n    if (!config) {\n      return 'No LLM configured at index ' + index;\n    }\n\n    // Check cache first\n    const cachedResponse = this.cache.get(prompt, config.provider, config.model);\n    if (cachedResponse) {\n      return cachedResponse.response;\n    }\n\n    // Check throttling\n    if (this.cache.isThrottled(config.provider)) {\n      return 'Rate limit exceeded. Please try again later.';\n    }\n\n    try {\n      const provider = this.providers.get(config.provider);\n      if (!provider) {\n        throw new Error(`Provider ${config.provider} not initialized`);\n      }\n\n      const response = await provider.query(prompt, config);\n\n      // Cache the response\n      this.cache.set(prompt, config.provider, config.model, response.content, response.usage);\n\n      return response.content;\n    } catch (error: any) {\n      vscode.window.showErrorMessage(`LLM query failed: ${error.message}. Falling back...`);\n\n      // Fallback to primary LLM\n      if (index !== 0) {\n        return this.queryLLM(0, prompt);\n      }\n\n      return `Error: ${error.message}`;\n    }\n  }\n\n  /**\n   * Parallel voting system with improved accuracy and fuzzy matching\n   */\n  async voteOnDecision(prompt: string, options: string[]): Promise<string> {\n    if (this.panel.length === 0 || options.length === 0) {\n      return options[0] || 'No options provided';\n    }\n\n    const votes = new Map<string, number>(options.map(opt => [opt, 0]));\n\n    // Enhanced voting prompt\n    const votePrompt = `${prompt}\n\nPlease vote on ONE of these options: ${options.join(', ')}\nRespond with ONLY the option you choose, exactly as written.`;\n\n    // Create voting promises with concurrency limit\n    const votePromises = this.panel.map(async (_, i) => {\n      try {\n        const response = await this.queryLLM(i, votePrompt);\n        return { response, success: true, index: i };\n      } catch {\n        return { response: options[0], success: false, index: i };\n      }\n    });\n\n    // Execute with controlled concurrency\n    const results = await this.executeWithConcurrencyLimit(votePromises);\n\n    // Process votes with fuzzy matching\n    results.forEach(result => {\n      const response = result.response.toLowerCase().trim();\n      const voted = options.find(\n        opt =>\n          response.includes(opt.toLowerCase()) ||\n          opt.toLowerCase().includes(response) ||\n          this.calculateSimilarity(response, opt.toLowerCase()) > 0.7\n      );\n\n      if (voted) {\n        votes.set(voted, (votes.get(voted) || 0) + 1);\n      }\n    });\n\n    // Find majority winner with tie-breaking\n    let max = 0;\n    let winner = options[0];\n    votes.forEach((count, opt) => {\n      if (count > max || (count === max && opt === options[0])) {\n        max = count;\n        winner = opt;\n      }\n    });\n\n    // Enhanced logging for audit trail\n    const voteResults = Array.from(votes.entries()).map(([option, count]) => ({ option, count }));\n    console.log(\n      `Vote results for \"${prompt.substring(0, 50)}...\": ${JSON.stringify(voteResults)}, Winner: ${winner}`\n    );\n\n    return winner;\n  }\n\n  /**\n   * Conference system for collaborative discussion\n   */\n  async conference(prompt: string): Promise<string> {\n    if (this.panel.length === 0) {\n      return 'No LLMs configured for conference';\n    }\n\n    let discussion = prompt;\n    const discussionHistory: string[] = [prompt];\n\n    // Sequential discussion with each LLM\n    for (let i = 0; i < this.panel.length; i++) {\n      const config = this.panel[i];\n      const response = await this.queryLLM(i, discussion);\n      const contribution = `\\nLLM ${i + 1} (${config.role} - ${config.provider}): ${response}`;\n      discussion += contribution;\n      discussionHistory.push(contribution);\n    }\n\n    return discussion;\n  }\n\n  /**\n   * Validate all configured LLM providers\n   */\n  async validateAllConfigurations(): Promise<Record<string, boolean>> {\n    const results: Record<string, boolean> = {};\n\n    const validationPromises = this.panel.map(async (config, index) => {\n      const provider = this.providers.get(config.provider);\n      if (!provider) {\n        return { index, valid: false };\n      }\n\n      try {\n        const valid = await provider.validateConfig(config);\n        return { index, valid };\n      } catch {\n        return { index, valid: false };\n      }\n    });\n\n    const validationResults = await Promise.all(validationPromises);\n\n    validationResults.forEach(result => {\n      const config = this.panel[result.index];\n      results[`${config.provider}-${result.index}`] = result.valid;\n    });\n\n    return results;\n  }\n\n  /**\n   * Get available models for all providers\n   */\n  async getAvailableModels(): Promise<Record<string, string[]>> {\n    const models: Record<string, string[]> = {};\n\n    for (const [providerName, provider] of this.providers.entries()) {\n      const config = this.panel.find(c => c.provider === providerName);\n      if (config) {\n        try {\n          models[providerName] = await provider.getAvailableModels(config);\n        } catch {\n          models[providerName] = [];\n        }\n      }\n    }\n\n    return models;\n  }\n\n  /**\n   * Execute promises with concurrency limit\n   */\n  private async executeWithConcurrencyLimit<T>(promises: Promise<T>[]): Promise<T[]> {\n    const results: T[] = [];\n    const executing: Promise<any>[] = [];\n\n    for (const promise of promises) {\n      const p = promise.then(result => {\n        results.push(result);\n        executing.splice(executing.indexOf(p), 1);\n        return result;\n      });\n\n      executing.push(p);\n\n      if (executing.length >= this.maxConcurrentRequests) {\n        await Promise.race(executing);\n      }\n    }\n\n    await Promise.all(executing);\n    return results;\n  }\n\n  /**\n   * Calculate string similarity for fuzzy matching\n   */\n  private calculateSimilarity(str1: string, str2: string): number {\n    const maxLength = Math.max(str1.length, str2.length);\n    if (maxLength === 0) return 1;\n\n    const distance = this.levenshteinDistance(str1, str2);\n    return (maxLength - distance) / maxLength;\n  }\n\n  /**\n   * Calculate Levenshtein distance between two strings\n   */\n  private levenshteinDistance(str1: string, str2: string): number {\n    const matrix = Array(str2.length + 1)\n      .fill(null)\n      .map(() => Array(str1.length + 1).fill(null));\n\n    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;\n    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;\n\n    for (let j = 1; j <= str2.length; j++) {\n      for (let i = 1; i <= str1.length; i++) {\n        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[j][i] = Math.min(\n          matrix[j][i - 1] + 1,\n          matrix[j - 1][i] + 1,\n          matrix[j - 1][i - 1] + indicator\n        );\n      }\n    }\n\n    return matrix[str2.length][str1.length];\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): ReturnType<LLMCache['getStats']> {\n    return this.cache.getStats();\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\providers\\anthropicProvider.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'config' is defined but never used.","line":49,"column":28,"nodeType":"Identifier","messageId":"unusedVar","endLine":49,"endColumn":45,"suggestions":[{"messageId":"removeVar","data":{"varName":"config"},"fix":{"range":[1342,1359],"text":""},"desc":"Remove unused variable 'config'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Anthropic Provider Implementation\n */\n\nimport { BaseLLMProvider } from './baseProvider';\nimport { LLMConfig, LLMResponse } from '../interfaces';\n\nexport class AnthropicProvider extends BaseLLMProvider {\n  private readonly baseUrl = 'https://api.anthropic.com/v1';\n\n  async query(prompt: string, config: LLMConfig): Promise<LLMResponse> {\n    const sanitizedPrompt = this.sanitizePrompt(prompt);\n\n    const response = await this.makeRequest(\n      `${this.baseUrl}/messages`,\n      {\n        model: config.model,\n        max_tokens: config.maxTokens || 1000,\n        messages: [{ role: 'user', content: sanitizedPrompt }],\n        temperature: config.temperature || 0.7,\n      },\n      {\n        'x-api-key': config.key,\n        'Content-Type': 'application/json',\n        'anthropic-version': '2023-06-01',\n      }\n    );\n\n    return {\n      content: response.data.content[0].text,\n      usage: this.extractUsage(response.data),\n      metadata: {\n        model: response.data.model,\n        stopReason: response.data.stop_reason,\n      },\n    };\n  }\n\n  async validateConfig(config: LLMConfig): Promise<boolean> {\n    try {\n      // Anthropic doesn't have a models endpoint, so we test with a minimal query\n      await this.query('Hi', config);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  async getAvailableModels(config: LLMConfig): Promise<string[]> {\n    // Anthropic doesn't provide a models endpoint, return known models\n    return [\n      'claude-3-opus-20240229',\n      'claude-3-sonnet-20240229',\n      'claude-3-haiku-20240307',\n      'claude-2.1',\n      'claude-2.0',\n    ];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\providers\\baseProvider.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'prompt' is defined but never used.","line":13,"column":18,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":32,"suggestions":[{"messageId":"removeVar","data":{"varName":"prompt"},"fix":{"range":[388,403],"text":""},"desc":"Remove unused variable 'prompt'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'config' is defined but never used.","line":13,"column":34,"nodeType":"Identifier","messageId":"unusedVar","endLine":13,"endColumn":51,"suggestions":[{"messageId":"removeVar","data":{"varName":"config"},"fix":{"range":[402,421],"text":""},"desc":"Remove unused variable 'config'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'config' is defined but never used.","line":14,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":44,"suggestions":[{"messageId":"removeVar","data":{"varName":"config"},"fix":{"range":[472,489],"text":""},"desc":"Remove unused variable 'config'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'config' is defined but never used.","line":15,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":48,"suggestions":[{"messageId":"removeVar","data":{"varName":"config"},"fix":{"range":[540,557],"text":""},"desc":"Remove unused variable 'config'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[690,693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[690,693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[931,934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[931,934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1246,1249],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1246,1249],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":62,"column":34,"nodeType":"Literal","messageId":"unexpected","endLine":62,"endColumn":52},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1831,1834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1831,1834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Base LLM Provider Implementation\n * Provides common functionality for all LLM providers\n */\n\nimport axios, { AxiosResponse } from 'axios';\nimport { LLMProvider, LLMConfig, LLMResponse } from '../interfaces';\n\nexport abstract class BaseLLMProvider implements LLMProvider {\n  protected readonly timeout: number = 30000;\n  protected readonly maxRetries: number = 3;\n\n  abstract query(prompt: string, config: LLMConfig): Promise<LLMResponse>;\n  abstract validateConfig(config: LLMConfig): Promise<boolean>;\n  abstract getAvailableModels(config: LLMConfig): Promise<string[]>;\n\n  /**\n   * Make HTTP request with retry logic\n   */\n  protected async makeRequest(\n    url: string,\n    data: any,\n    headers: Record<string, string>,\n    retries: number = this.maxRetries\n  ): Promise<AxiosResponse> {\n    try {\n      return await axios.post(url, data, {\n        headers,\n        timeout: this.timeout,\n      });\n    } catch (error: any) {\n      if (retries > 0 && this.isRetryableError(error)) {\n        await this.delay(1000 * (this.maxRetries - retries + 1));\n        return this.makeRequest(url, data, headers, retries - 1);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Check if error is retryable\n   */\n  protected isRetryableError(error: any): boolean {\n    return (\n      error.code === 'ECONNRESET' ||\n      error.code === 'ETIMEDOUT' ||\n      (error.response && [429, 502, 503, 504].includes(error.response.status))\n    );\n  }\n\n  /**\n   * Delay execution\n   */\n  protected delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Sanitize input prompt\n   */\n  protected sanitizePrompt(prompt: string): string {\n    return prompt.trim().replace(/[\\x00-\\x1F\\x7F]/g, '');\n  }\n\n  /**\n   * Extract usage information from response\n   */\n  protected extractUsage(response: any): LLMResponse['usage'] {\n    if (response.usage) {\n      return {\n        promptTokens: response.usage.prompt_tokens || 0,\n        completionTokens: response.usage.completion_tokens || 0,\n        totalTokens: response.usage.total_tokens || 0,\n      };\n    }\n    return undefined;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\providers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\providers\\openaiProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1705,1708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1705,1708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1760,1763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1760,1763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OpenAI Provider Implementation\n */\n\nimport { BaseLLMProvider } from './baseProvider';\nimport { LLMConfig, LLMResponse } from '../interfaces';\n\nexport class OpenAIProvider extends BaseLLMProvider {\n  private readonly baseUrl = 'https://api.openai.com/v1';\n\n  async query(prompt: string, config: LLMConfig): Promise<LLMResponse> {\n    const sanitizedPrompt = this.sanitizePrompt(prompt);\n\n    const response = await this.makeRequest(\n      `${this.baseUrl}/chat/completions`,\n      {\n        model: config.model,\n        messages: [{ role: 'user', content: sanitizedPrompt }],\n        max_tokens: config.maxTokens || 1000,\n        temperature: config.temperature || 0.7,\n      },\n      {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n      }\n    );\n\n    return {\n      content: response.data.choices[0].message.content,\n      usage: this.extractUsage(response.data),\n      metadata: {\n        model: response.data.model,\n        finishReason: response.data.choices[0].finish_reason,\n      },\n    };\n  }\n\n  async validateConfig(config: LLMConfig): Promise<boolean> {\n    try {\n      const response = await this.makeRequest(`${this.baseUrl}/models`, null, {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n      });\n      return response.status === 200;\n    } catch {\n      return false;\n    }\n  }\n\n  async getAvailableModels(config: LLMConfig): Promise<string[]> {\n    try {\n      const response = await this.makeRequest(`${this.baseUrl}/models`, null, {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n      });\n\n      return response.data.data\n        .filter((model: any) => model.id.includes('gpt'))\n        .map((model: any) => model.id)\n        .sort();\n    } catch {\n      return ['gpt-4', 'gpt-3.5-turbo']; // fallback\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\providers\\openrouterProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1807,1810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1807,1810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OpenRouter Provider Implementation\n */\n\nimport { BaseLLMProvider } from './baseProvider';\nimport { LLMConfig, LLMResponse } from '../interfaces';\n\nexport class OpenRouterProvider extends BaseLLMProvider {\n  private readonly baseUrl = 'https://openrouter.ai/api/v1';\n\n  async query(prompt: string, config: LLMConfig): Promise<LLMResponse> {\n    const sanitizedPrompt = this.sanitizePrompt(prompt);\n\n    const response = await this.makeRequest(\n      `${this.baseUrl}/chat/completions`,\n      {\n        model: config.model,\n        messages: [{ role: 'user', content: sanitizedPrompt }],\n        max_tokens: config.maxTokens || 1000,\n        temperature: config.temperature || 0.7,\n      },\n      {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n        'HTTP-Referer': 'https://github.com/up2itnow/AstraForge',\n        'X-Title': 'AstraForge IDE',\n      }\n    );\n\n    return {\n      content: response.data.choices[0].message.content,\n      usage: this.extractUsage(response.data),\n      metadata: {\n        model: response.data.model,\n        finishReason: response.data.choices[0].finish_reason,\n      },\n    };\n  }\n\n  async validateConfig(config: LLMConfig): Promise<boolean> {\n    try {\n      const response = await this.makeRequest(`${this.baseUrl}/models`, null, {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n      });\n      return response.status === 200;\n    } catch {\n      return false;\n    }\n  }\n\n  async getAvailableModels(config: LLMConfig): Promise<string[]> {\n    try {\n      const response = await this.makeRequest(`${this.baseUrl}/models`, null, {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n      });\n\n      return response.data.data.map((model: any) => model.id).sort();\n    } catch {\n      return ['openai/gpt-4', 'anthropic/claude-3-sonnet']; // fallback\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\llm\\providers\\xaiProvider.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1688,1691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1688,1691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * xAI (Grok) Provider Implementation\n */\n\nimport { BaseLLMProvider } from './baseProvider';\nimport { LLMConfig, LLMResponse } from '../interfaces';\n\nexport class XAIProvider extends BaseLLMProvider {\n  private readonly baseUrl = 'https://api.x.ai/v1';\n\n  async query(prompt: string, config: LLMConfig): Promise<LLMResponse> {\n    const sanitizedPrompt = this.sanitizePrompt(prompt);\n\n    const response = await this.makeRequest(\n      `${this.baseUrl}/chat/completions`,\n      {\n        model: config.model,\n        messages: [{ role: 'user', content: sanitizedPrompt }],\n        max_tokens: config.maxTokens || 1000,\n        temperature: config.temperature || 0.7,\n      },\n      {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n      }\n    );\n\n    return {\n      content: response.data.choices[0].message.content,\n      usage: this.extractUsage(response.data),\n      metadata: {\n        model: response.data.model,\n        finishReason: response.data.choices[0].finish_reason,\n      },\n    };\n  }\n\n  async validateConfig(config: LLMConfig): Promise<boolean> {\n    try {\n      const response = await this.makeRequest(`${this.baseUrl}/models`, null, {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n      });\n      return response.status === 200;\n    } catch {\n      return false;\n    }\n  }\n\n  async getAvailableModels(config: LLMConfig): Promise<string[]> {\n    try {\n      const response = await this.makeRequest(`${this.baseUrl}/models`, null, {\n        Authorization: `Bearer ${config.key}`,\n        'Content-Type': 'application/json',\n      });\n\n      return response.data.data.map((model: any) => model.id).sort();\n    } catch {\n      return ['grok-beta']; // fallback\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\providers\\projectIgnition.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'_extensionUri' is defined but never used.","line":9,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":47,"suggestions":[{"messageId":"removeVar","data":{"varName":"_extensionUri"},"fix":{"range":[312,337],"text":""},"desc":"Remove unused variable '_extensionUri'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_workflowManager' is defined but never used.","line":10,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":55,"suggestions":[{"messageId":"removeVar","data":{"varName":"_workflowManager"},"fix":{"range":[360,393],"text":""},"desc":"Remove unused variable '_workflowManager'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_context' is defined but never used.","line":18,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":18,"endColumn":47,"suggestions":[{"messageId":"removeVar","data":{"varName":"_context"},"fix":{"range":[590,638],"text":""},"desc":"Remove unused variable '_context'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_token' is defined but never used.","line":19,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"_token"},"fix":{"range":[638,676],"text":""},"desc":"Remove unused variable '_token'."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport { WorkflowManager } from '../workflow/workflowManager';\n\nexport class ProjectIgnitionProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'astraforge.projectIgnition';\n  private _view?: vscode.Webview;\n\n  constructor(\n    private readonly _extensionUri: vscode.Uri,\n    private readonly _workflowManager: WorkflowManager\n  ) {\n    // Initialize provider with extension URI and workflow manager\n    // These parameters are used in the class methods\n  }\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    _context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken\n  ) {\n    // _context and _token are required by interface but not used in this implementation\n    this._view = webviewView.webview;\n\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [this._extensionUri],\n    };\n\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\n\n    webviewView.webview.onDidReceiveMessage(async data => {\n      if (data.type === 'submitIdea') {\n        this._workflowManager.startWorkflow(data.idea, data.option);\n      }\n    });\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'ignition.js')\n    );\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css')\n    );\n\n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <link href=\"${styleUri}\" rel=\"stylesheet\">\n</head>\n<body>\n  <h1>Project Ignition</h1>\n  <textarea id=\"ideaInput\" placeholder=\"Enter your project idea...\"></textarea>\n  <select id=\"promptOption\">\n    <option value=\"direct\">Direct Submit</option>\n    <option value=\"letPanelDecide\">Let the panel decide</option>\n    <option value=\"custom\">Custom refinements</option>\n  </select>\n  <div id=\"customBox\" style=\"display:none;\">\n    <textarea id=\"customText\"></textarea>\n  </div>\n  <button onclick=\"submitIdea()\">Submit</button>\n  <div id=\"progressTracker\"></div>\n  <script src=\"${scriptUri}\"></script>\n</body>\n</html>`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\providers\\setupWizard.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'_extensionUri' is defined but never used.","line":7,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":57,"suggestions":[{"messageId":"removeVar","data":{"varName":"_extensionUri"},"fix":{"range":[236,261],"text":""},"desc":"Remove unused variable '_extensionUri'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_context' is defined but never used.","line":14,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":47,"suggestions":[{"messageId":"removeVar","data":{"varName":"_context"},"fix":{"range":[442,490],"text":""},"desc":"Remove unused variable '_context'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_token' is defined but never used.","line":15,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"_token"},"fix":{"range":[490,528],"text":""},"desc":"Remove unused variable '_token'."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\n\nexport class SetupWizardProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'astraforge.setupWizard';\n  private _view?: vscode.Webview;\n\n  constructor(private readonly _extensionUri: vscode.Uri) {\n    // Initialize setup wizard with extension URI\n    // _extensionUri is used in _getHtmlForWebview method\n  }\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    _context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken\n  ) {\n    // _context and _token are required by interface but not used in this implementation\n    this._view = webviewView.webview;\n\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [this._extensionUri],\n    };\n\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\n\n    webviewView.webview.onDidReceiveMessage(async data => {\n      switch (data.type) {\n        case 'savePanel':\n          await vscode.workspace\n            .getConfiguration('astraforge')\n            .update('llmPanel', data.panel, true);\n          vscode.window.showInformationMessage('LLM Panel configured! Ready for ignition.');\n          break;\n      }\n    });\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'setup.js')\n    );\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css')\n    );\n\n    // Basic HTML with form for 3/5 LLMs, providers dropdown (OpenAI, Anthropic, xAI, OpenRouter), API key inputs\n    return `<!DOCTYPE html>\n      <html lang=\"en\">\n      <head><link href=\"${styleUri}\" rel=\"stylesheet\"></head>\n      <body>\n        <h1>Setup LLM Panel</h1>\n        <select id=\"panelSize\">\n          <option value=\"3\">3 LLMs</option>\n          <option value=\"5\">5 LLMs</option>\n        </select>\n        <div id=\"llmForms\"></div>\n        <button onclick=\"savePanel()\">Save Configuration</button>\n        <script src=\"${scriptUri}\"></script>\n      </body>\n      </html>`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\rl\\adaptiveWorkflow.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":75,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":75,"endColumn":16,"suggestions":[{"fix":{"range":[2150,2274],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'updateQValue' has too many lines (61). Maximum allowed is 50.","line":84,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":144,"endColumn":4},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":136,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":136,"endColumn":16,"suggestions":[{"fix":{"range":[3806,3961],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'calculateReward' has too many lines (62). Maximum allowed is 50.","line":149,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":210,"endColumn":4},{"ruleId":"complexity","severity":2,"message":"Method 'calculateReward' has a complexity of 16. Maximum allowed is 10.","line":149,"column":18,"nodeType":"FunctionExpression","messageId":"complex","endLine":210,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7368,7371],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7368,7371],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":255,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":255,"endColumn":18,"suggestions":[{"fix":{"range":[7411,7476],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":257,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":257,"endColumn":19,"suggestions":[{"fix":{"range":[7505,7556],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7640,7643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7640,7643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":280,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":280,"endColumn":18,"suggestions":[{"fix":{"range":[8178,8244],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":282,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":282,"endColumn":19,"suggestions":[{"fix":{"range":[8273,8324],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Reinforcement Learning module for adaptive workflow optimization\n * Uses Q-learning to optimize phase sequencing and decision making\n */\n\ninterface WorkflowState {\n  currentPhase: string;\n  projectComplexity: number; // 0-1 scale\n  userSatisfaction: number; // 0-1 scale from feedback\n  errorRate: number; // 0-1 scale\n  timeSpent: number; // normalized time\n}\n\ninterface WorkflowAction {\n  type: 'continue' | 'skip' | 'repeat' | 'branch' | 'optimize';\n  target?: string; // target phase or optimization\n  confidence: number; // 0-1 scale\n}\n\ninterface QTableEntry {\n  state: string; // serialized state\n  action: string; // serialized action\n  qValue: number;\n  visits: number;\n}\n\nexport class AdaptiveWorkflowRL {\n  private qTable: Map<string, Map<string, QTableEntry>> = new Map();\n  private learningRate = 0.1;\n  private discountFactor = 0.9;\n  private explorationRate = 0.1;\n  private minExplorationRate = 0.01;\n  private explorationDecay = 0.995;\n\n  private readonly phases = ['Planning', 'Prototyping', 'Testing', 'Deployment'];\n  private readonly actions: WorkflowAction[] = [\n    { type: 'continue', confidence: 1.0 },\n    { type: 'skip', confidence: 0.8 },\n    { type: 'repeat', confidence: 0.9 },\n    { type: 'branch', target: 'Testing', confidence: 0.7 },\n    { type: 'optimize', confidence: 0.6 },\n  ];\n\n  constructor() {\n    this.loadQTable();\n  }\n\n  /**\n   * Get the best action for a given state using epsilon-greedy policy\n   */\n  getBestAction(state: WorkflowState): WorkflowAction {\n    const stateKey = this.serializeState(state);\n\n    // Epsilon-greedy exploration\n    if (Math.random() < this.explorationRate) {\n      return this.getRandomAction();\n    }\n\n    // Get best known action\n    const stateActions = this.qTable.get(stateKey);\n    if (!stateActions || stateActions.size === 0) {\n      return this.getRandomAction();\n    }\n\n    let bestAction: WorkflowAction = this.actions[0];\n    let bestQValue = -Infinity;\n\n    for (const [actionKey, entry] of stateActions) {\n      if (entry.qValue > bestQValue) {\n        bestQValue = entry.qValue;\n        bestAction = this.deserializeAction(actionKey);\n      }\n    }\n\n    console.log(\n      `RL: Selected action ${bestAction.type} for state ${stateKey} (Q-value: ${bestQValue.toFixed(3)})`\n    );\n    return bestAction;\n  }\n\n  /**\n   * Update Q-value based on reward received\n   */\n  updateQValue(\n    state: WorkflowState,\n    action: WorkflowAction,\n    reward: number,\n    nextState: WorkflowState\n  ): void {\n    const stateKey = this.serializeState(state);\n    const actionKey = this.serializeAction(action);\n    const nextStateKey = this.serializeState(nextState);\n\n    // Initialize state in Q-table if not exists\n    if (!this.qTable.has(stateKey)) {\n      this.qTable.set(stateKey, new Map());\n    }\n\n    const stateActions = this.qTable.get(stateKey)!;\n\n    // Initialize action if not exists\n    if (!stateActions.has(actionKey)) {\n      stateActions.set(actionKey, {\n        state: stateKey,\n        action: actionKey,\n        qValue: 0,\n        visits: 0,\n      });\n    }\n\n    const entry = stateActions.get(actionKey)!;\n\n    // Get max Q-value for next state\n    const nextStateActions = this.qTable.get(nextStateKey);\n    let maxNextQValue = 0;\n    if (nextStateActions) {\n      for (const nextEntry of nextStateActions.values()) {\n        maxNextQValue = Math.max(maxNextQValue, nextEntry.qValue);\n      }\n    }\n\n    // Q-learning update rule\n    const oldQValue = entry.qValue;\n    const newQValue =\n      oldQValue + this.learningRate * (reward + this.discountFactor * maxNextQValue - oldQValue);\n\n    entry.qValue = newQValue;\n    entry.visits++;\n\n    // Decay exploration rate\n    this.explorationRate = Math.max(\n      this.minExplorationRate,\n      this.explorationRate * this.explorationDecay\n    );\n\n    console.log(\n      `RL: Updated Q(${stateKey}, ${actionKey}) from ${oldQValue.toFixed(3)} to ${newQValue.toFixed(3)} (reward: ${reward.toFixed(3)})`\n    );\n\n    // Save updated Q-table periodically\n    if (entry.visits % 10 === 0) {\n      this.saveQTable();\n    }\n  }\n\n  /**\n   * Calculate reward based on workflow performance\n   */\n  calculateReward(\n    oldState: WorkflowState,\n    action: WorkflowAction,\n    newState: WorkflowState,\n    phaseSuccess: boolean,\n    userFeedback?: number\n  ): number {\n    let reward = 0;\n\n    // Base reward for phase success\n    if (phaseSuccess) {\n      reward += 1.0;\n    } else {\n      reward -= 0.5;\n    }\n\n    // Reward for improving user satisfaction\n    const satisfactionImprovement = newState.userSatisfaction - oldState.userSatisfaction;\n    reward += satisfactionImprovement * 2.0;\n\n    // Penalty for increasing error rate\n    const errorIncrease = newState.errorRate - oldState.errorRate;\n    reward -= errorIncrease * 1.5;\n\n    // Reward for efficient time usage\n    if (newState.timeSpent < oldState.timeSpent && phaseSuccess) {\n      reward += 0.3;\n    }\n\n    // Action-specific rewards\n    switch (action.type) {\n      case 'continue':\n        if (phaseSuccess && newState.userSatisfaction > 0.7) {\n          reward += 0.2;\n        }\n        break;\n      case 'skip':\n        if (oldState.projectComplexity < 0.3 && phaseSuccess) {\n          reward += 0.4; // Good to skip for simple projects\n        } else {\n          reward -= 0.3; // Risky for complex projects\n        }\n        break;\n      case 'repeat':\n        if (oldState.errorRate > 0.5 && newState.errorRate < oldState.errorRate) {\n          reward += 0.5; // Good decision to repeat when there were errors\n        }\n        break;\n      case 'optimize':\n        if (newState.timeSpent < oldState.timeSpent * 0.8) {\n          reward += 0.6; // Significant time improvement\n        }\n        break;\n    }\n\n    // User feedback integration\n    if (userFeedback !== undefined) {\n      reward += (userFeedback - 0.5) * 2.0; // Scale 0-1 feedback to -1 to +1\n    }\n\n    return Math.max(-2.0, Math.min(2.0, reward)); // Clamp reward between -2 and +2\n  }\n\n  private getRandomAction(): WorkflowAction {\n    return this.actions[Math.floor(Math.random() * this.actions.length)];\n  }\n\n  private serializeState(state: WorkflowState): string {\n    return JSON.stringify({\n      phase: state.currentPhase,\n      complexity: Math.round(state.projectComplexity * 10) / 10,\n      satisfaction: Math.round(state.userSatisfaction * 10) / 10,\n      errorRate: Math.round(state.errorRate * 10) / 10,\n      timeNorm: Math.round(state.timeSpent * 10) / 10,\n    });\n  }\n\n  private serializeAction(action: WorkflowAction): string {\n    return JSON.stringify({\n      type: action.type,\n      target: action.target || null,\n    });\n  }\n\n  private deserializeAction(actionKey: string): WorkflowAction {\n    const parsed = JSON.parse(actionKey);\n    return {\n      type: parsed.type,\n      target: parsed.target,\n      confidence: 0.8, // Default confidence for deserialized actions\n    };\n  }\n\n  private saveQTable(): void {\n    try {\n      const serialized = Array.from(this.qTable.entries()).map(([stateKey, actions]) => ({\n        state: stateKey,\n        actions: Array.from(actions.entries()).map(([actionKey, entry]) => ({\n          action: actionKey,\n          qValue: entry.qValue,\n          visits: entry.visits,\n        })),\n      }));\n\n      // Store in memory for now - in VS Code extension, this would use vscode.ExtensionContext.globalState\n      (global as any).astraforge_qtable = serialized;\n      console.log(`RL: Saved Q-table with ${this.qTable.size} states`);\n    } catch (error) {\n      console.warn('RL: Failed to save Q-table:', error);\n    }\n  }\n\n  private loadQTable(): void {\n    try {\n      const saved = (global as any).astraforge_qtable;\n      if (!saved) return;\n\n      const serialized = saved;\n      for (const stateData of serialized) {\n        const stateActions = new Map<string, QTableEntry>();\n        for (const actionData of stateData.actions) {\n          stateActions.set(actionData.action, {\n            state: stateData.state,\n            action: actionData.action,\n            qValue: actionData.qValue,\n            visits: actionData.visits,\n          });\n        }\n        this.qTable.set(stateData.state, stateActions);\n      }\n\n      console.log(`RL: Loaded Q-table with ${this.qTable.size} states`);\n    } catch (error) {\n      console.warn('RL: Failed to load Q-table:', error);\n    }\n  }\n\n  /**\n   * Get learning statistics for monitoring\n   */\n  getStats(): { totalStates: number; totalActions: number; explorationRate: number } {\n    let totalActions = 0;\n    for (const actions of this.qTable.values()) {\n      totalActions += actions.size;\n    }\n\n    return {\n      totalStates: this.qTable.size,\n      totalActions,\n      explorationRate: this.explorationRate,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\server\\collaborationServer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[539,542],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[539,542],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[648,651],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[648,651],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1322,1325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1322,1325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":54,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":54,"endColumn":22,"suggestions":[{"fix":{"range":[1405,1470],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":64,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":64,"endColumn":20,"suggestions":[{"fix":{"range":[1633,1677],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":18,"suggestions":[{"fix":{"range":[1806,1850],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2411,2414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2411,2414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2780,2783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2780,2783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":136,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":136,"endColumn":16,"suggestions":[{"fix":{"range":[3700,3809],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3847,3850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3847,3850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":169,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4672,4675],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4672,4675],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7415,7418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7415,7418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7430,7433],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7430,7433],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8531,8534],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8531,8534],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":295,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":295,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8654,8657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8654,8657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":306,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8893,8896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8893,8896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":322,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":322,"endColumn":18,"suggestions":[{"fix":{"range":[9313,9377],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":342,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9864,9867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9864,9867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":346,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9971,9974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9971,9974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Real-time collaboration server using Socket.IO\n * Handles multi-agent isolation and communication\n */\n\nimport { Server } from 'socket.io';\nimport { createServer } from 'http';\nimport * as vscode from 'vscode';\n\ninterface AgentSession {\n  id: string;\n  type: 'llm' | 'user' | 'system';\n  name: string;\n  capabilities: string[];\n  status: 'active' | 'busy' | 'idle' | 'error';\n  workspaceId: string;\n}\n\ninterface CollaborationMessage {\n  type: 'code_change' | 'discussion' | 'decision' | 'status_update';\n  sender: string;\n  content: any;\n  timestamp: number;\n  targetAgents?: string[];\n}\n\nexport class CollaborationServer {\n  private server: any;\n  private io: Server;\n  private port: number;\n  private agents: Map<string, AgentSession> = new Map();\n  private workspaces: Map<string, Set<string>> = new Map(); // workspace -> agent IDs\n  private messageHistory: Map<string, CollaborationMessage[]> = new Map(); // workspace -> messages\n\n  constructor(port: number = 3000) {\n    this.port = port;\n    this.server = createServer();\n    this.io = new Server(this.server, {\n      cors: {\n        origin: '*',\n        methods: ['GET', 'POST'],\n      },\n    });\n\n    this.setupEventHandlers();\n  }\n\n  async start(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.server.listen(this.port, (error: any) => {\n        if (error) {\n          reject(error);\n        } else {\n          console.log(`Collaboration server started on port ${this.port}`);\n          resolve();\n        }\n      });\n    });\n  }\n\n  async stop(): Promise<void> {\n    return new Promise(resolve => {\n      this.server.close(() => {\n        console.log('Collaboration server stopped');\n        resolve();\n      });\n    });\n  }\n\n  private setupEventHandlers(): void {\n    this.io.on('connection', socket => {\n      console.log(`New connection: ${socket.id}`);\n\n      // Agent registration\n      socket.on('register_agent', (agentData: Partial<AgentSession>) => {\n        this.registerAgent(socket, agentData);\n      });\n\n      // Join workspace\n      socket.on('join_workspace', (workspaceId: string) => {\n        this.joinWorkspace(socket, workspaceId);\n      });\n\n      // Handle collaboration messages\n      socket.on('collaboration_message', (message: CollaborationMessage) => {\n        this.handleMessage(socket, message);\n      });\n\n      // Request agent isolation\n      socket.on('request_isolation', (taskData: any) => {\n        this.createIsolatedAgent(socket, taskData);\n      });\n\n      // Status updates\n      socket.on('status_update', (status: string) => {\n        this.updateAgentStatus(socket, status);\n      });\n\n      // Disconnection\n      socket.on('disconnect', () => {\n        this.handleDisconnection(socket);\n      });\n    });\n  }\n\n  private registerAgent(socket: any, agentData: Partial<AgentSession>): void {\n    const agent: AgentSession = {\n      id: socket.id,\n      type: agentData.type || 'system',\n      name: agentData.name || `Agent-${socket.id.substring(0, 8)}`,\n      capabilities: agentData.capabilities || [],\n      status: 'active',\n      workspaceId: agentData.workspaceId || 'default',\n    };\n\n    this.agents.set(socket.id, agent);\n    socket.join(agent.workspaceId);\n\n    // Add to workspace\n    if (!this.workspaces.has(agent.workspaceId)) {\n      this.workspaces.set(agent.workspaceId, new Set());\n    }\n    this.workspaces.get(agent.workspaceId)!.add(socket.id);\n\n    // Notify other agents in workspace\n    socket.to(agent.workspaceId).emit('agent_joined', {\n      agent: agent,\n      timestamp: Date.now(),\n    });\n\n    socket.emit('registration_complete', {\n      agent: agent,\n      workspace_agents: this.getWorkspaceAgents(agent.workspaceId),\n    });\n\n    console.log(\n      `Agent registered: ${agent.name} (${agent.type}) in workspace ${agent.workspaceId}`\n    );\n  }\n\n  private joinWorkspace(socket: any, workspaceId: string): void {\n    const agent = this.agents.get(socket.id);\n    if (!agent) return;\n\n    // Leave current workspace\n    socket.leave(agent.workspaceId);\n    this.workspaces.get(agent.workspaceId)?.delete(socket.id);\n\n    // Join new workspace\n    agent.workspaceId = workspaceId;\n    socket.join(workspaceId);\n\n    if (!this.workspaces.has(workspaceId)) {\n      this.workspaces.set(workspaceId, new Set());\n    }\n    this.workspaces.get(workspaceId)!.add(socket.id);\n\n    // Send message history\n    const history = this.messageHistory.get(workspaceId) || [];\n    socket.emit('message_history', history.slice(-50)); // Last 50 messages\n\n    // Notify workspace\n    socket.to(workspaceId).emit('agent_joined', {\n      agent: agent,\n      timestamp: Date.now(),\n    });\n  }\n\n  private handleMessage(socket: any, message: CollaborationMessage): void {\n    const agent = this.agents.get(socket.id);\n    if (!agent) return;\n\n    // Add sender info and timestamp\n    message.sender = agent.id;\n    message.timestamp = Date.now();\n\n    // Store message in history\n    if (!this.messageHistory.has(agent.workspaceId)) {\n      this.messageHistory.set(agent.workspaceId, []);\n    }\n    const history = this.messageHistory.get(agent.workspaceId)!;\n    history.push(message);\n\n    // Keep only last 1000 messages\n    if (history.length > 1000) {\n      history.splice(0, history.length - 1000);\n    }\n\n    // Route message based on type and targets\n    if (message.targetAgents && message.targetAgents.length > 0) {\n      // Send to specific agents\n      message.targetAgents.forEach(targetId => {\n        socket.to(targetId).emit('collaboration_message', message);\n      });\n    } else {\n      // Broadcast to all agents in workspace\n      socket.to(agent.workspaceId).emit('collaboration_message', message);\n    }\n\n    // Handle special message types\n    this.processMessageType(message, agent);\n  }\n\n  private processMessageType(message: CollaborationMessage, sender: AgentSession): void {\n    switch (message.type) {\n      case 'decision':\n        this.handleDecisionMessage(message, sender);\n        break;\n      case 'code_change':\n        this.handleCodeChange(message, sender);\n        break;\n      case 'status_update':\n        this.handleStatusUpdate(message, sender);\n        break;\n    }\n  }\n\n  private handleDecisionMessage(message: CollaborationMessage, sender: AgentSession): void {\n    // Implement voting mechanism for multi-agent decisions\n    const decision = message.content;\n\n    // Notify VS Code extension about the decision\n    vscode.window.showInformationMessage(\n      `Agent ${sender.name} made a decision: ${decision.summary || 'Decision pending'}`\n    );\n  }\n\n  private handleCodeChange(message: CollaborationMessage, sender: AgentSession): void {\n    // Handle real-time code synchronization\n    const change = message.content;\n\n    // Broadcast to VS Code extension\n    this.io.to(sender.workspaceId).emit('code_sync', {\n      file: change.file,\n      diff: change.diff,\n      author: sender.name,\n      timestamp: message.timestamp,\n    });\n  }\n\n  private handleStatusUpdate(message: CollaborationMessage, sender: AgentSession): void {\n    const agent = this.agents.get(sender.id);\n    if (agent) {\n      agent.status = message.content.status || agent.status;\n\n      // Notify workspace about status change\n      this.io.to(agent.workspaceId).emit('agent_status_update', {\n        agentId: sender.id,\n        status: agent.status,\n        timestamp: message.timestamp,\n      });\n    }\n  }\n\n  private createIsolatedAgent(socket: any, taskData: any): void {\n    // Create isolated environment for heavy tasks\n    const isolationId = `isolated_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Create isolated workspace\n    this.workspaces.set(isolationId, new Set([socket.id]));\n\n    // Move agent to isolated workspace temporarily\n    const agent = this.agents.get(socket.id);\n    if (agent) {\n      const originalWorkspace = agent.workspaceId;\n\n      socket.leave(originalWorkspace);\n      socket.join(isolationId);\n\n      socket.emit('isolation_created', {\n        isolationId,\n        originalWorkspace,\n        taskData,\n        timestamp: Date.now(),\n      });\n\n      // Set timeout to return agent to original workspace\n      setTimeout(() => {\n        socket.leave(isolationId);\n        socket.join(originalWorkspace);\n        this.workspaces.delete(isolationId);\n\n        socket.emit('isolation_ended', {\n          isolationId,\n          returnedTo: originalWorkspace,\n          timestamp: Date.now(),\n        });\n      }, taskData.timeout || 30000); // Default 30 seconds\n    }\n  }\n\n  private updateAgentStatus(socket: any, status: string): void {\n    const agent = this.agents.get(socket.id);\n    if (agent) {\n      agent.status = status as any;\n\n      // Notify workspace\n      socket.to(agent.workspaceId).emit('agent_status_update', {\n        agentId: socket.id,\n        status: status,\n        timestamp: Date.now(),\n      });\n    }\n  }\n\n  private handleDisconnection(socket: any): void {\n    const agent = this.agents.get(socket.id);\n    if (agent) {\n      // Remove from workspace\n      this.workspaces.get(agent.workspaceId)?.delete(socket.id);\n\n      // Notify other agents\n      socket.to(agent.workspaceId).emit('agent_left', {\n        agentId: socket.id,\n        agentName: agent.name,\n        timestamp: Date.now(),\n      });\n\n      // Cleanup\n      this.agents.delete(socket.id);\n\n      console.log(`Agent disconnected: ${agent.name} (${socket.id})`);\n    }\n  }\n\n  private getWorkspaceAgents(workspaceId: string): AgentSession[] {\n    const agentIds = this.workspaces.get(workspaceId) || new Set();\n    const agents: AgentSession[] = [];\n\n    for (const agentId of agentIds) {\n      const agent = this.agents.get(agentId);\n      if (agent) {\n        agents.push(agent);\n      }\n    }\n\n    return agents;\n  }\n\n  // Public API methods for integration with VS Code extension\n\n  broadcastToWorkspace(workspaceId: string, event: string, data: any): void {\n    this.io.to(workspaceId).emit(event, data);\n  }\n\n  getWorkspaceStats(workspaceId: string): any {\n    const agents = this.getWorkspaceAgents(workspaceId);\n    const messages = this.messageHistory.get(workspaceId) || [];\n\n    return {\n      agentCount: agents.length,\n      messageCount: messages.length,\n      activeAgents: agents.filter(a => a.status === 'active').length,\n      lastActivity: messages.length > 0 ? messages[messages.length - 1].timestamp : null,\n    };\n  }\n\n  getAllWorkspaces(): string[] {\n    return Array.from(this.workspaces.keys());\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\spec-kit\\planGenerator.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'determineTechnicalContext' has too many lines (58). Maximum allowed is 50.","line":193,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":250,"endColumn":4},{"ruleId":"complexity","severity":2,"message":"Async method 'determineTechnicalContext' has a complexity of 30. Maximum allowed is 10.","line":193,"column":42,"nodeType":"FunctionExpression","messageId":"complex","endLine":250,"endColumn":4},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'performConstitutionCheck' has too many lines (79). Maximum allowed is 50.","line":292,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":370,"endColumn":4},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'determineProjectStructure' has too many lines (51). Maximum allowed is 50.","line":372,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":422,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":517,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":517,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16929,16932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16929,16932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"complexity","severity":2,"message":"Method 'formatConstitutionCheck' has a complexity of 12. Maximum allowed is 10.","line":567,"column":34,"nodeType":"FunctionExpression","messageId":"complex","endLine":593,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LLMManager } from '../llm/llmManager';\r\nimport { VectorDB } from '../db/vectorDB';\r\nimport { GeneratedSpec } from './specGenerator';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { logger } from '../utils/logger';\r\n\r\nexport interface TechnicalPlan {\r\n  summary: string;\r\n  technicalContext: TechnicalContext;\r\n  constitutionCheck: ConstitutionCheck;\r\n  projectStructure: ProjectStructure;\r\n  researchTasks: ResearchTask[];\r\n  designPhase: DesignPhase;\r\n  taskPlanningApproach: string;\r\n  content: string;\r\n}\r\n\r\nexport interface TechnicalContext {\r\n  language: string;\r\n  primaryDependencies: string[];\r\n  storage: string;\r\n  testing: string;\r\n  targetPlatform: string;\r\n  projectType: 'single' | 'web' | 'mobile';\r\n  performanceGoals: string[];\r\n  constraints: string[];\r\n  scale: string;\r\n}\r\n\r\nexport interface ConstitutionCheck {\r\n  simplicity: {\r\n    projectCount: number;\r\n    usingFrameworkDirectly: boolean;\r\n    singleDataModel: boolean;\r\n    avoidingPatterns: boolean;\r\n  };\r\n  architecture: {\r\n    everyFeatureAsLibrary: boolean;\r\n    libraries: Array<{ name: string; purpose: string }>;\r\n    cliPerLibrary: string[];\r\n    libraryDocsPlanned: boolean;\r\n  };\r\n  testing: {\r\n    redGreenRefactorEnforced: boolean;\r\n    gitCommitsShowTestsFirst: boolean;\r\n    orderFollowed: boolean;\r\n    realDependenciesUsed: boolean;\r\n    integrationTestsPlanned: boolean;\r\n  };\r\n  observability: {\r\n    structuredLoggingIncluded: boolean;\r\n    frontendToBackendLogs: boolean;\r\n    errorContextSufficient: boolean;\r\n  };\r\n  versioning: {\r\n    versionAssigned: string;\r\n    buildIncrementsPlanned: boolean;\r\n    breakingChangesHandled: boolean;\r\n  };\r\n  violations: string[];\r\n}\r\n\r\nexport interface ProjectStructure {\r\n  type: 'single' | 'web' | 'mobile';\r\n  directories: string[];\r\n  description: string;\r\n}\r\n\r\nexport interface ResearchTask {\r\n  id: string;\r\n  description: string;\r\n  rationale: string;\r\n  alternatives: string[];\r\n  decision?: string;\r\n}\r\n\r\nexport interface DesignPhase {\r\n  dataModel: string;\r\n  apiContracts: string[];\r\n  contractTests: string[];\r\n  testScenarios: string[];\r\n  quickstart: string;\r\n}\r\n\r\nexport class PlanGenerator {\r\n  private llmManager: LLMManager;\r\n  private vectorDB: VectorDB;\r\n  private planTemplate: string = '';\r\n\r\n  constructor(llmManager: LLMManager, vectorDB: VectorDB) {\r\n    this.llmManager = llmManager;\r\n    this.vectorDB = vectorDB;\r\n    this.loadPlanTemplate();\r\n  }\r\n\r\n  private loadPlanTemplate(): void {\r\n    const templatePath = path.join(__dirname, '../../templates/plan-template.md');\r\n    try {\r\n      this.planTemplate = fs.readFileSync(templatePath, 'utf8');\r\n    } catch (error) {\r\n      logger.error('Failed to load plan template:', error);\r\n      this.planTemplate = this.getDefaultPlanTemplate();\r\n    }\r\n  }\r\n\r\n  private getDefaultPlanTemplate(): string {\r\n    return `# Implementation Plan: {{FEATURE_NAME}}\r\n\r\n**Branch**: \\`{{BRANCH_NAME}}\\` | **Date**: {{DATE}} | **Spec**: {{SPEC_LINK}}\r\n**Input**: Feature specification from \\`/specs/{{FEATURE_DIR}}/spec.md\\`\r\n\r\n## Summary\r\n{{SUMMARY}}\r\n\r\n## Technical Context\r\n**Language/Version**: {{LANGUAGE}}\r\n**Primary Dependencies**: {{DEPENDENCIES}}\r\n**Storage**: {{STORAGE}}\r\n**Testing**: {{TESTING}}\r\n**Target Platform**: {{TARGET_PLATFORM}}\r\n**Project Type**: {{PROJECT_TYPE}}\r\n**Performance Goals**: {{PERFORMANCE_GOALS}}\r\n**Constraints**: {{CONSTRAINTS}}\r\n**Scale/Scope**: {{SCALE}}\r\n\r\n## Constitution Check\r\n{{CONSTITUTION_CHECK}}\r\n\r\n## Project Structure\r\n{{PROJECT_STRUCTURE}}\r\n\r\n## Phase 0: Outline & Research\r\n{{RESEARCH_PHASE}}\r\n\r\n## Phase 1: Design & Contracts\r\n{{DESIGN_PHASE}}\r\n\r\n## Phase 2: Task Planning Approach\r\n{{TASK_PLANNING}}\r\n\r\n## Progress Tracking\r\n{{PROGRESS_TRACKING}}\r\n`;\r\n  }\r\n\r\n  public async generatePlan(spec: GeneratedSpec, technicalRequirements?: Partial<TechnicalContext>): Promise<TechnicalPlan> {\r\n    logger.info('🔧 Generating technical implementation plan...');\r\n\r\n    // Phase 0: Research and technical context\r\n    const technicalContext = await this.determineTechnicalContext(spec, technicalRequirements);\r\n    const researchTasks = await this.generateResearchTasks(spec, technicalContext);\r\n\r\n    // Constitution check\r\n    const constitutionCheck = await this.performConstitutionCheck(spec, technicalContext);\r\n\r\n    // Project structure determination\r\n    const projectStructure = await this.determineProjectStructure(technicalContext);\r\n\r\n    // Phase 1: Design phase planning\r\n    const designPhase = await this.planDesignPhase(spec, technicalContext);\r\n\r\n    // Phase 2: Task planning approach\r\n    const taskPlanningApproach = await this.defineTaskPlanningApproach(spec, designPhase);\r\n\r\n    // Generate summary\r\n    const summary = await this.generateSummary(spec, technicalContext);\r\n\r\n    // Assemble the plan\r\n    const content = this.assemblePlan({\r\n      spec,\r\n      summary,\r\n      technicalContext,\r\n      constitutionCheck,\r\n      projectStructure,\r\n      researchTasks,\r\n      designPhase,\r\n      taskPlanningApproach\r\n    });\r\n\r\n    return {\r\n      summary,\r\n      technicalContext,\r\n      constitutionCheck,\r\n      projectStructure,\r\n      researchTasks,\r\n      designPhase,\r\n      taskPlanningApproach,\r\n      content\r\n    };\r\n  }\r\n\r\n  private async determineTechnicalContext(spec: GeneratedSpec, requirements?: Partial<TechnicalContext>): Promise<TechnicalContext> {\r\n    const prompt = `\r\n    Determine the technical context for this feature specification:\r\n    \r\n    Feature: ${spec.title}\r\n    Requirements: ${JSON.stringify(spec.functionalRequirements, null, 2)}\r\n    User Scenarios: ${JSON.stringify(spec.userScenarios, null, 2)}\r\n    Key Entities: ${JSON.stringify(spec.keyEntities, null, 2)}\r\n    \r\n    ${requirements ? `Existing Requirements: ${JSON.stringify(requirements, null, 2)}` : ''}\r\n    \r\n    Determine:\r\n    1. Best programming language and version\r\n    2. Primary dependencies/frameworks\r\n    3. Storage requirements\r\n    4. Testing framework\r\n    5. Target platform\r\n    6. Project type (single/web/mobile)\r\n    7. Performance goals\r\n    8. Constraints\r\n    9. Scale/scope\r\n    \r\n    Consider AstraForge context: This is a VS Code extension environment with Node.js/TypeScript.\r\n    \r\n    Return JSON with technical context structure.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      const context = JSON.parse(response);\r\n      \r\n      // Merge with provided requirements\r\n      return {\r\n        language: requirements?.language || context.language || 'TypeScript 5.1',\r\n        primaryDependencies: requirements?.primaryDependencies || context.primaryDependencies || ['Node.js'],\r\n        storage: requirements?.storage || context.storage || 'File System',\r\n        testing: requirements?.testing || context.testing || 'Jest',\r\n        targetPlatform: requirements?.targetPlatform || context.targetPlatform || 'VS Code Extension',\r\n        projectType: requirements?.projectType || context.projectType || 'single',\r\n        performanceGoals: requirements?.performanceGoals || context.performanceGoals || ['Responsive UI'],\r\n        constraints: requirements?.constraints || context.constraints || ['VS Code API limitations'],\r\n        scale: requirements?.scale || context.scale || 'Single user workspace'\r\n      };\r\n    } catch (error) {\r\n      logger.error('Error determining technical context:', error);\r\n      return {\r\n        language: 'TypeScript 5.1',\r\n        primaryDependencies: ['Node.js', 'VS Code API'],\r\n        storage: 'File System',\r\n        testing: 'Jest',\r\n        targetPlatform: 'VS Code Extension',\r\n        projectType: 'single',\r\n        performanceGoals: ['Responsive UI', '<100ms response time'],\r\n        constraints: ['VS Code API limitations', 'Single workspace context'],\r\n        scale: 'Single user workspace'\r\n      };\r\n    }\r\n  }\r\n\r\n  private async generateResearchTasks(spec: GeneratedSpec, context: TechnicalContext): Promise<ResearchTask[]> {\r\n    const prompt = `\r\n    Generate research tasks for this technical plan:\r\n    \r\n    Specification: ${spec.title}\r\n    Technical Context: ${JSON.stringify(context, null, 2)}\r\n    Clarifications Needed: ${JSON.stringify(spec.clarificationNeeded, null, 2)}\r\n    \r\n    Identify areas that need research:\r\n    1. Unknown technologies or best practices\r\n    2. Integration patterns\r\n    3. Performance optimization techniques\r\n    4. Testing strategies\r\n    5. Architecture decisions\r\n    \r\n    For each research task, provide:\r\n    - Unique ID\r\n    - Clear description\r\n    - Rationale (why needed)\r\n    - Alternative approaches to consider\r\n    \r\n    Return JSON array of research tasks.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('anthropic', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      logger.error('Error generating research tasks:', error);\r\n      return [\r\n        {\r\n          id: 'R001',\r\n          description: 'Research best practices for VS Code extension development',\r\n          rationale: 'Ensure optimal user experience and performance',\r\n          alternatives: ['Basic implementation', 'Advanced optimization', 'Minimal viable product']\r\n        }\r\n      ];\r\n    }\r\n  }\r\n\r\n  private async performConstitutionCheck(spec: GeneratedSpec, context: TechnicalContext): Promise<ConstitutionCheck> {\r\n    const prompt = `\r\n    Perform constitution compliance check for this plan:\r\n    \r\n    Specification: ${spec.title}\r\n    Technical Context: ${JSON.stringify(context, null, 2)}\r\n    Functional Requirements: ${JSON.stringify(spec.functionalRequirements, null, 2)}\r\n    \r\n    Check against AstraForge Constitution:\r\n    \r\n    1. Simplicity:\r\n       - Max 3 projects\r\n       - Using framework directly (no wrapper classes)\r\n       - Single data model (no DTOs unless needed)\r\n       - Avoiding unnecessary patterns\r\n    \r\n    2. Architecture:\r\n       - Every feature as library\r\n       - CLI per library\r\n       - Library documentation planned\r\n    \r\n    3. Testing (NON-NEGOTIABLE):\r\n       - RED-GREEN-Refactor cycle\r\n       - Tests before implementation\r\n       - Contract→Integration→E2E→Unit order\r\n       - Real dependencies used\r\n       - Integration tests for new libraries\r\n    \r\n    4. Observability:\r\n       - Structured logging\r\n       - Error context\r\n    \r\n    5. Versioning:\r\n       - Version number assigned\r\n       - BUILD increments\r\n       - Breaking changes handled\r\n    \r\n    Return detailed constitution check object with violations.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      logger.error('Error performing constitution check:', error);\r\n      return {\r\n        simplicity: {\r\n          projectCount: 1,\r\n          usingFrameworkDirectly: true,\r\n          singleDataModel: true,\r\n          avoidingPatterns: true\r\n        },\r\n        architecture: {\r\n          everyFeatureAsLibrary: true,\r\n          libraries: [{ name: spec.title, purpose: 'Core functionality' }],\r\n          cliPerLibrary: [`${spec.title.toLowerCase()}`],\r\n          libraryDocsPlanned: true\r\n        },\r\n        testing: {\r\n          redGreenRefactorEnforced: true,\r\n          gitCommitsShowTestsFirst: true,\r\n          orderFollowed: true,\r\n          realDependenciesUsed: true,\r\n          integrationTestsPlanned: true\r\n        },\r\n        observability: {\r\n          structuredLoggingIncluded: true,\r\n          frontendToBackendLogs: false,\r\n          errorContextSufficient: true\r\n        },\r\n        versioning: {\r\n          versionAssigned: '1.0.0',\r\n          buildIncrementsPlanned: true,\r\n          breakingChangesHandled: true\r\n        },\r\n        violations: []\r\n      };\r\n    }\r\n  }\r\n\r\n  private async determineProjectStructure(context: TechnicalContext): Promise<ProjectStructure> {\r\n    const structures = {\r\n      single: {\r\n        type: 'single' as const,\r\n        directories: [\r\n          'src/',\r\n          'src/models/',\r\n          'src/services/',\r\n          'src/cli/',\r\n          'src/lib/',\r\n          'tests/',\r\n          'tests/contract/',\r\n          'tests/integration/',\r\n          'tests/unit/'\r\n        ],\r\n        description: 'Single project structure for focused functionality'\r\n      },\r\n      web: {\r\n        type: 'web' as const,\r\n        directories: [\r\n          'backend/',\r\n          'backend/src/',\r\n          'backend/src/models/',\r\n          'backend/src/services/',\r\n          'backend/src/api/',\r\n          'backend/tests/',\r\n          'frontend/',\r\n          'frontend/src/',\r\n          'frontend/src/components/',\r\n          'frontend/src/pages/',\r\n          'frontend/src/services/',\r\n          'frontend/tests/'\r\n        ],\r\n        description: 'Web application with separate frontend and backend'\r\n      },\r\n      mobile: {\r\n        type: 'mobile' as const,\r\n        directories: [\r\n          'api/',\r\n          'api/src/',\r\n          'api/tests/',\r\n          'mobile/',\r\n          'mobile/src/',\r\n          'mobile/tests/'\r\n        ],\r\n        description: 'Mobile application with API backend'\r\n      }\r\n    };\r\n\r\n    return structures[context.projectType] || structures.single;\r\n  }\r\n\r\n  private async planDesignPhase(spec: GeneratedSpec, context: TechnicalContext): Promise<DesignPhase> {\r\n    const prompt = `\r\n    Plan the design phase for this feature:\r\n    \r\n    Specification: ${spec.title}\r\n    Key Entities: ${JSON.stringify(spec.keyEntities, null, 2)}\r\n    Functional Requirements: ${JSON.stringify(spec.functionalRequirements, null, 2)}\r\n    User Scenarios: ${JSON.stringify(spec.userScenarios, null, 2)}\r\n    Technical Context: ${JSON.stringify(context, null, 2)}\r\n    \r\n    Plan:\r\n    1. Data model design (entities, relationships, validation)\r\n    2. API contracts (endpoints, schemas)\r\n    3. Contract tests (one per endpoint)\r\n    4. Test scenarios (from user stories)\r\n    5. Quickstart guide (validation steps)\r\n    \r\n    Return JSON with design phase structure.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('anthropic', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      logger.error('Error planning design phase:', error);\r\n      return {\r\n        dataModel: 'Data model to be defined based on key entities',\r\n        apiContracts: ['API contracts to be generated from functional requirements'],\r\n        contractTests: ['Contract tests to be created for each endpoint'],\r\n        testScenarios: ['Integration test scenarios from user stories'],\r\n        quickstart: 'Quickstart guide with validation steps'\r\n      };\r\n    }\r\n  }\r\n\r\n  private async defineTaskPlanningApproach(spec: GeneratedSpec, designPhase: DesignPhase): Promise<string> {\r\n    const prompt = `\r\n    Define the task planning approach for this feature:\r\n    \r\n    Specification: ${spec.title}\r\n    Design Phase: ${JSON.stringify(designPhase, null, 2)}\r\n    \r\n    Describe how tasks will be generated:\r\n    1. Task generation strategy\r\n    2. Ordering strategy (TDD, dependencies)\r\n    3. Parallel execution opportunities\r\n    4. Estimated task count\r\n    \r\n    Focus on Test-Driven Development and constitutional compliance.\r\n    Return a clear description of the approach.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      return response;\r\n    } catch (error) {\r\n      logger.error('Error defining task planning approach:', error);\r\n      return `Task Generation Strategy:\r\n- Generate tasks from design documents (contracts, data model, quickstart)\r\n- Each contract → contract test task [P]\r\n- Each entity → model creation task [P]\r\n- Each user story → integration test task\r\n- Implementation tasks to make tests pass\r\n\r\nOrdering Strategy:\r\n- TDD order: Tests before implementation\r\n- Dependency order: Models before services before UI\r\n- Mark [P] for parallel execution (independent files)\r\n\r\nEstimated Output: 15-25 numbered, ordered tasks following constitutional principles.`;\r\n    }\r\n  }\r\n\r\n  private async generateSummary(spec: GeneratedSpec, context: TechnicalContext): Promise<string> {\r\n    const prompt = `\r\n    Generate a concise summary for this implementation plan:\r\n    \r\n    Feature: ${spec.title}\r\n    Primary Requirements: ${spec.functionalRequirements.slice(0, 3).join(', ')}\r\n    Technical Approach: ${context.language} using ${context.primaryDependencies.join(', ')}\r\n    \r\n    Create a 1-2 sentence summary capturing the essence of what will be built and how.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      return response.trim();\r\n    } catch (error) {\r\n      logger.error('Error generating summary:', error);\r\n      return `Implement ${spec.title} using ${context.language} with ${context.primaryDependencies.join(', ')} following test-driven development principles.`;\r\n    }\r\n  }\r\n\r\n  private assemblePlan(data: any): string {\r\n    const currentDate = new Date().toISOString().split('T')[0];\r\n    \r\n    let plan = this.planTemplate;\r\n    \r\n    // Replace template variables\r\n    plan = plan.replace(/\\{\\{FEATURE_NAME\\}\\}/g, data.spec.title);\r\n    plan = plan.replace(/\\{\\{BRANCH_NAME\\}\\}/g, `001-${data.spec.title.toLowerCase().replace(/\\s+/g, '-')}`);\r\n    plan = plan.replace(/\\{\\{DATE\\}\\}/g, currentDate);\r\n    plan = plan.replace(/\\{\\{SPEC_LINK\\}\\}/g, `specs/001-${data.spec.title.toLowerCase().replace(/\\s+/g, '-')}/spec.md`);\r\n    plan = plan.replace(/\\{\\{FEATURE_DIR\\}\\}/g, `001-${data.spec.title.toLowerCase().replace(/\\s+/g, '-')}`);\r\n    \r\n    // Replace content sections\r\n    plan = plan.replace('{{SUMMARY}}', data.summary);\r\n    plan = plan.replace('{{LANGUAGE}}', data.technicalContext.language);\r\n    plan = plan.replace('{{DEPENDENCIES}}', data.technicalContext.primaryDependencies.join(', '));\r\n    plan = plan.replace('{{STORAGE}}', data.technicalContext.storage);\r\n    plan = plan.replace('{{TESTING}}', data.technicalContext.testing);\r\n    plan = plan.replace('{{TARGET_PLATFORM}}', data.technicalContext.targetPlatform);\r\n    plan = plan.replace('{{PROJECT_TYPE}}', data.technicalContext.projectType);\r\n    plan = plan.replace('{{PERFORMANCE_GOALS}}', data.technicalContext.performanceGoals.join(', '));\r\n    plan = plan.replace('{{CONSTRAINTS}}', data.technicalContext.constraints.join(', '));\r\n    plan = plan.replace('{{SCALE}}', data.technicalContext.scale);\r\n    \r\n    // Constitution check\r\n    const constitutionSection = this.formatConstitutionCheck(data.constitutionCheck);\r\n    plan = plan.replace('{{CONSTITUTION_CHECK}}', constitutionSection);\r\n    \r\n    // Project structure\r\n    const structureSection = this.formatProjectStructure(data.projectStructure);\r\n    plan = plan.replace('{{PROJECT_STRUCTURE}}', structureSection);\r\n    \r\n    // Research phase\r\n    const researchSection = this.formatResearchPhase(data.researchTasks);\r\n    plan = plan.replace('{{RESEARCH_PHASE}}', researchSection);\r\n    \r\n    // Design phase\r\n    const designSection = this.formatDesignPhase(data.designPhase);\r\n    plan = plan.replace('{{DESIGN_PHASE}}', designSection);\r\n    \r\n    // Task planning\r\n    plan = plan.replace('{{TASK_PLANNING}}', data.taskPlanningApproach);\r\n    \r\n    // Progress tracking\r\n    const progressSection = this.formatProgressTracking();\r\n    plan = plan.replace('{{PROGRESS_TRACKING}}', progressSection);\r\n    \r\n    return plan;\r\n  }\r\n\r\n  private formatConstitutionCheck(check: ConstitutionCheck): string {\r\n    let section = '**Simplicity**:\\n';\r\n    section += `- Projects: ${check.simplicity.projectCount} (max 3)\\n`;\r\n    section += `- Using framework directly: ${check.simplicity.usingFrameworkDirectly ? 'Yes' : 'No'}\\n`;\r\n    section += `- Single data model: ${check.simplicity.singleDataModel ? 'Yes' : 'No'}\\n`;\r\n    section += `- Avoiding patterns: ${check.simplicity.avoidingPatterns ? 'Yes' : 'No'}\\n\\n`;\r\n    \r\n    section += '**Architecture**:\\n';\r\n    section += `- Every feature as library: ${check.architecture.everyFeatureAsLibrary ? 'Yes' : 'No'}\\n`;\r\n    section += `- Libraries: ${check.architecture.libraries.map(l => `${l.name} (${l.purpose})`).join(', ')}\\n`;\r\n    section += `- CLI per library: ${check.architecture.cliPerLibrary.join(', ')}\\n`;\r\n    section += `- Library docs planned: ${check.architecture.libraryDocsPlanned ? 'Yes' : 'No'}\\n\\n`;\r\n    \r\n    section += '**Testing (NON-NEGOTIABLE)**:\\n';\r\n    section += `- RED-GREEN-Refactor enforced: ${check.testing.redGreenRefactorEnforced ? 'Yes' : 'No'}\\n`;\r\n    section += `- Tests before implementation: ${check.testing.gitCommitsShowTestsFirst ? 'Yes' : 'No'}\\n`;\r\n    section += `- Order followed: ${check.testing.orderFollowed ? 'Yes' : 'No'}\\n`;\r\n    section += `- Real dependencies: ${check.testing.realDependenciesUsed ? 'Yes' : 'No'}\\n`;\r\n    section += `- Integration tests: ${check.testing.integrationTestsPlanned ? 'Yes' : 'No'}\\n\\n`;\r\n    \r\n    if (check.violations.length > 0) {\r\n      section += '**Violations**:\\n';\r\n      section += check.violations.map(v => `- ${v}`).join('\\n');\r\n    }\r\n    \r\n    return section;\r\n  }\r\n\r\n  private formatProjectStructure(structure: ProjectStructure): string {\r\n    let section = `**Structure Decision**: ${structure.description}\\n\\n`;\r\n    section += '```\\n';\r\n    structure.directories.forEach(dir => {\r\n      section += `${dir}\\n`;\r\n    });\r\n    section += '```';\r\n    return section;\r\n  }\r\n\r\n  private formatResearchPhase(tasks: ResearchTask[]): string {\r\n    let section = '**Research Tasks**:\\n\\n';\r\n    tasks.forEach(task => {\r\n      section += `**${task.id}**: ${task.description}\\n`;\r\n      section += `- Rationale: ${task.rationale}\\n`;\r\n      section += `- Alternatives: ${task.alternatives.join(', ')}\\n`;\r\n      if (task.decision) {\r\n        section += `- Decision: ${task.decision}\\n`;\r\n      }\r\n      section += '\\n';\r\n    });\r\n    return section;\r\n  }\r\n\r\n  private formatDesignPhase(design: DesignPhase): string {\r\n    let section = '1. **Data Model**: ' + design.dataModel + '\\n\\n';\r\n    section += '2. **API Contracts**:\\n';\r\n    design.apiContracts.forEach(contract => {\r\n      section += `   - ${contract}\\n`;\r\n    });\r\n    section += '\\n3. **Contract Tests**:\\n';\r\n    design.contractTests.forEach(test => {\r\n      section += `   - ${test}\\n`;\r\n    });\r\n    section += '\\n4. **Test Scenarios**:\\n';\r\n    design.testScenarios.forEach(scenario => {\r\n      section += `   - ${scenario}\\n`;\r\n    });\r\n    section += '\\n5. **Quickstart**: ' + design.quickstart;\r\n    return section;\r\n  }\r\n\r\n  private formatProgressTracking(): string {\r\n    return `**Phase Status**:\r\n- [ ] Phase 0: Research complete (/plan command)\r\n- [ ] Phase 1: Design complete (/plan command)\r\n- [ ] Phase 2: Task planning complete (/plan command - describe approach only)\r\n- [ ] Phase 3: Tasks generated (/tasks command)\r\n- [ ] Phase 4: Implementation complete\r\n- [ ] Phase 5: Validation passed\r\n\r\n**Gate Status**:\r\n- [ ] Initial Constitution Check: PASS\r\n- [ ] Post-Design Constitution Check: PASS\r\n- [ ] All NEEDS CLARIFICATION resolved\r\n- [ ] Complexity deviations documented`;\r\n  }\r\n\r\n  public async executeResearch(tasks: ResearchTask[]): Promise<ResearchTask[]> {\r\n    logger.info('🔍 Executing research tasks...');\r\n    \r\n    const completedTasks = await Promise.all(\r\n      tasks.map(async (task) => {\r\n        const prompt = `\r\n        Research this topic:\r\n        \r\n        Task: ${task.description}\r\n        Rationale: ${task.rationale}\r\n        Alternatives to consider: ${task.alternatives.join(', ')}\r\n        \r\n        Provide:\r\n        1. Recommended decision\r\n        2. Reasoning for the decision\r\n        3. Trade-offs considered\r\n        4. Implementation considerations\r\n        \r\n        Focus on practical, actionable insights for VS Code extension development.\r\n        `;\r\n        \r\n        try {\r\n          const research = await this.llmManager.generateResponse('openai', prompt);\r\n          return {\r\n            ...task,\r\n            decision: research\r\n          };\r\n        } catch (error) {\r\n          logger.error(`Error researching task ${task.id}:`, error);\r\n          return {\r\n            ...task,\r\n            decision: 'Research pending - manual investigation required'\r\n          };\r\n        }\r\n      })\r\n    );\r\n    \r\n    return completedTasks;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\spec-kit\\specGenerator.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":20,"suggestions":[{"fix":{"range":[1269,1323],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3784,3787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3784,3787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":150,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":150,"endColumn":20,"suggestions":[{"fix":{"range":[4427,4476],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4785,4788],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4785,4788],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'request' is defined but never used.","line":163,"column":55,"nodeType":"Identifier","messageId":"unusedVar","endLine":163,"endColumn":84,"suggestions":[{"messageId":"removeVar","data":{"varName":"request"},"fix":{"range":[4788,4819],"text":""},"desc":"Remove unused variable 'request'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":95,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":98,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4830,4833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4830,4833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4986,4989],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4986,4989],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5904,5907],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5904,5907],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6707,6710],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6707,6710],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":225,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":225,"endColumn":20,"suggestions":[{"fix":{"range":[7268,7325],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":230,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":230,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7500,7503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7500,7503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":248,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":248,"endColumn":20,"suggestions":[{"fix":{"range":[8099,8162],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":253,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8326,8329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8326,8329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":272,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":272,"endColumn":20,"suggestions":[{"fix":{"range":[8900,8953],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":277,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9129,9132],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9129,9132],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":301,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":301,"endColumn":20,"suggestions":[{"fix":{"range":[9941,10007],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":306,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10195,10198],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10195,10198],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":326,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10997,11000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10997,11000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":328,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":328,"endColumn":20,"suggestions":[{"fix":{"range":[11077,11133],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":333,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11269,11272],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11269,11272],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":359,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":359,"endColumn":20,"suggestions":[{"fix":{"range":[12057,12121],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":369,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":369,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12315,12318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12315,12318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":391,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":391,"endColumn":20,"suggestions":[{"fix":{"range":[13002,13060],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"complexity","severity":2,"message":"Method 'assembleSpecification' has a complexity of 15. Maximum allowed is 10.","line":396,"column":32,"nodeType":"FunctionExpression","messageId":"complex","endLine":416,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":396,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":396,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13167,13170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13167,13170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":449,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":449,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15767,15770],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15767,15770],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":476,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":476,"endColumn":20,"suggestions":[{"fix":{"range":[16563,16618],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LLMManager } from '../llm/llmManager';\r\nimport { VectorDB } from '../db/vectorDB';\r\nimport { logger } from '../utils/logger';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport interface SpecificationRequest {\r\n  userIdea: string;\r\n  projectContext?: string;\r\n  existingRequirements?: string[];\r\n  constraints?: string[];\r\n}\r\n\r\nexport interface GeneratedSpec {\r\n  title: string;\r\n  content: string;\r\n  clarificationNeeded: string[];\r\n  functionalRequirements: string[];\r\n  userScenarios: string[];\r\n  keyEntities: string[];\r\n  constitutionCompliance: ConstitutionCheck;\r\n}\r\n\r\nexport interface ConstitutionCheck {\r\n  passed: boolean;\r\n  violations: string[];\r\n  warnings: string[];\r\n  complexityScore: number;\r\n}\r\n\r\nexport class SpecGenerator {\r\n  private llmManager: LLMManager;\r\n  private vectorDB: VectorDB;\r\n  private specTemplate: string = '';\r\n\r\n  constructor(llmManager: LLMManager, vectorDB: VectorDB) {\r\n    this.llmManager = llmManager;\r\n    this.vectorDB = vectorDB;\r\n    this.loadSpecTemplate();\r\n  }\r\n\r\n  private loadSpecTemplate(): void {\r\n    const templatePath = path.join(__dirname, '../../templates/spec-template.md');\r\n    try {\r\n      this.specTemplate = fs.readFileSync(templatePath, 'utf8');\r\n    } catch (error) {\r\n      console.error('Failed to load spec template:', error);\r\n      this.specTemplate = this.getDefaultSpecTemplate();\r\n    }\r\n  }\r\n\r\n  private getDefaultSpecTemplate(): string {\r\n    return `# Feature Specification: {{FEATURE_NAME}}\r\n\r\n**Feature Branch**: \\`{{BRANCH_NAME}}\\`  \r\n**Created**: {{DATE}}  \r\n**Status**: Draft  \r\n**Input**: User description: \"{{USER_INPUT}}\"\r\n\r\n## User Scenarios & Testing\r\n\r\n### Primary User Story\r\n{{PRIMARY_USER_STORY}}\r\n\r\n### Acceptance Scenarios\r\n{{ACCEPTANCE_SCENARIOS}}\r\n\r\n### Edge Cases\r\n{{EDGE_CASES}}\r\n\r\n## Requirements\r\n\r\n### Functional Requirements\r\n{{FUNCTIONAL_REQUIREMENTS}}\r\n\r\n### Key Entities\r\n{{KEY_ENTITIES}}\r\n\r\n## Review & Acceptance Checklist\r\n\r\n### Content Quality\r\n- [ ] No implementation details (languages, frameworks, APIs)\r\n- [ ] Focused on user value and business needs\r\n- [ ] Written for non-technical stakeholders\r\n- [ ] All mandatory sections completed\r\n\r\n### Requirement Completeness\r\n- [ ] No [NEEDS CLARIFICATION] markers remain\r\n- [ ] Requirements are testable and unambiguous  \r\n- [ ] Success criteria are measurable\r\n- [ ] Scope is clearly bounded\r\n- [ ] Dependencies and assumptions identified\r\n\r\n## Clarifications Needed\r\n{{CLARIFICATIONS_NEEDED}}\r\n`;\r\n  }\r\n\r\n  public async generateSpecification(request: SpecificationRequest): Promise<GeneratedSpec> {\r\n    logger.info('Generating specification from user idea...');\r\n\r\n    // Step 1: Parse and understand the user idea\r\n    const parsedIdea = await this.parseUserIdea(request.userIdea, request.projectContext);\r\n\r\n    // Step 2: Generate specification sections using multi-LLM collaboration\r\n    const specSections = await this.generateSpecSections(parsedIdea, request);\r\n\r\n    // Step 3: Check constitution compliance\r\n    const constitutionCheck = await this.checkConstitutionCompliance(specSections);\r\n\r\n    // Step 4: Identify clarification needs\r\n    const clarifications = await this.identifyClarifications(specSections);\r\n\r\n    // Step 5: Assemble the final specification\r\n    const finalSpec = this.assembleSpecification(request, specSections, clarifications);\r\n\r\n    return {\r\n      title: specSections.featureName,\r\n      content: finalSpec,\r\n      clarificationNeeded: clarifications,\r\n      functionalRequirements: specSections.functionalRequirements,\r\n      userScenarios: specSections.userScenarios,\r\n      keyEntities: specSections.keyEntities,\r\n      constitutionCompliance: constitutionCheck\r\n    };\r\n  }\r\n\r\n  private async parseUserIdea(userIdea: string, context?: string): Promise<any> {\r\n    const prompt = `\r\n    Parse this user idea into structured components:\r\n    \r\n    User Idea: \"${userIdea}\"\r\n    ${context ? `Project Context: ${context}` : ''}\r\n    \r\n    Extract:\r\n    1. Core functionality (what the user wants)\r\n    2. Key actors/users involved\r\n    3. Main actions/workflows\r\n    4. Data entities mentioned\r\n    5. Constraints or requirements\r\n    6. Success criteria (if mentioned)\r\n    \r\n    Return as structured JSON with clear categories.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error parsing user idea:', error);\r\n      // Fallback to simple parsing\r\n      return {\r\n        coreFunctionality: userIdea,\r\n        actors: ['User'],\r\n        actions: ['Use the system'],\r\n        entities: [],\r\n        constraints: [],\r\n        successCriteria: []\r\n      };\r\n    }\r\n  }\r\n\r\n  private async generateSpecSections(parsedIdea: any, request: SpecificationRequest): Promise<any> {\r\n    // Use multi-LLM collaboration for better spec generation\r\n    const llmProviders = ['openai', 'anthropic', 'openrouter'];\r\n    const sections: any = {};\r\n\r\n    // Generate feature name\r\n    sections.featureName = await this.generateFeatureName(parsedIdea);\r\n    sections.branchName = this.generateBranchName(sections.featureName);\r\n\r\n    // Generate user scenarios using different LLMs for diversity\r\n    sections.userScenarios = await this.generateUserScenarios(parsedIdea, llmProviders[0]);\r\n    sections.acceptanceScenarios = await this.generateAcceptanceScenarios(parsedIdea, llmProviders[1]);\r\n    sections.edgeCases = await this.generateEdgeCases(parsedIdea, llmProviders[2]);\r\n\r\n    // Generate functional requirements\r\n    sections.functionalRequirements = await this.generateFunctionalRequirements(parsedIdea, sections.userScenarios);\r\n\r\n    // Identify key entities\r\n    sections.keyEntities = await this.identifyKeyEntities(parsedIdea, sections.functionalRequirements);\r\n\r\n    return sections;\r\n  }\r\n\r\n  private async generateFeatureName(parsedIdea: any): Promise<string> {\r\n    const prompt = `\r\n    Generate a concise, descriptive feature name for this functionality:\r\n    ${JSON.stringify(parsedIdea, null, 2)}\r\n    \r\n    Requirements:\r\n    - 2-5 words maximum\r\n    - Clear and professional\r\n    - Focuses on user value\r\n    - Suitable for branch names\r\n    \r\n    Return only the feature name, no explanation.\r\n    `;\r\n\r\n    const response = await this.llmManager.generateResponse('openai', prompt);\r\n    return response.trim().replace(/[^a-zA-Z0-9\\s-]/g, '').replace(/\\s+/g, '-').toLowerCase();\r\n  }\r\n\r\n  private generateBranchName(featureName: string): string {\r\n    const timestamp = new Date().toISOString().split('T')[0].replace(/-/g, '');\r\n    return `001-${featureName}-${timestamp}`;\r\n  }\r\n\r\n  private async generateUserScenarios(parsedIdea: any, provider: string): Promise<string[]> {\r\n    const prompt = `\r\n    Create primary user scenarios for this feature:\r\n    ${JSON.stringify(parsedIdea, null, 2)}\r\n    \r\n    Generate 1-3 clear user scenarios in this format:\r\n    \"As a [user type], I want to [action] so that [benefit]\"\r\n    \r\n    Focus on the main value propositions and user workflows.\r\n    Return as JSON array of strings.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse(provider, prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error generating user scenarios:', error);\r\n      return [`As a user, I want to ${parsedIdea.coreFunctionality} so that I can achieve my goals`];\r\n    }\r\n  }\r\n\r\n  private async generateAcceptanceScenarios(parsedIdea: any, provider: string): Promise<string[]> {\r\n    const prompt = `\r\n    Create acceptance scenarios in Given-When-Then format for:\r\n    ${JSON.stringify(parsedIdea, null, 2)}\r\n    \r\n    Generate 3-5 scenarios covering:\r\n    1. Happy path (main functionality)\r\n    2. Alternative flows\r\n    3. Error conditions\r\n    \r\n    Format: \"Given [initial state], When [action], Then [expected outcome]\"\r\n    Return as JSON array of strings.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse(provider, prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error generating acceptance scenarios:', error);\r\n      return ['Given initial state, When user performs action, Then system responds appropriately'];\r\n    }\r\n  }\r\n\r\n  private async generateEdgeCases(parsedIdea: any, provider: string): Promise<string[]> {\r\n    const prompt = `\r\n    Identify potential edge cases and error scenarios for:\r\n    ${JSON.stringify(parsedIdea, null, 2)}\r\n    \r\n    Consider:\r\n    1. Invalid inputs\r\n    2. System limitations\r\n    3. Network/connectivity issues\r\n    4. Concurrent usage\r\n    5. Data boundary conditions\r\n    \r\n    Return as JSON array of strings describing each edge case.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse(provider, prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error generating edge cases:', error);\r\n      return ['What happens when invalid input is provided?', 'How does system handle high load?'];\r\n    }\r\n  }\r\n\r\n  private async generateFunctionalRequirements(parsedIdea: any, userScenarios: string[]): Promise<string[]> {\r\n    const prompt = `\r\n    Generate functional requirements from this analysis:\r\n    \r\n    Parsed Idea: ${JSON.stringify(parsedIdea, null, 2)}\r\n    User Scenarios: ${JSON.stringify(userScenarios, null, 2)}\r\n    \r\n    Create 5-10 functional requirements in format:\r\n    \"FR-001: System MUST [specific capability]\"\r\n    \"FR-002: Users MUST be able to [specific action]\"\r\n    \r\n    Requirements should be:\r\n    - Testable and measurable\r\n    - Focused on WHAT, not HOW\r\n    - Cover all major functionality\r\n    - Include validation and error handling\r\n    \r\n    Return as JSON array of strings.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error generating functional requirements:', error);\r\n      return ['FR-001: System MUST provide core functionality', 'FR-002: Users MUST be able to interact with the system'];\r\n    }\r\n  }\r\n\r\n  private async identifyKeyEntities(parsedIdea: any, requirements: string[]): Promise<string[]> {\r\n    const prompt = `\r\n    Identify key data entities from this analysis:\r\n    \r\n    Parsed Idea: ${JSON.stringify(parsedIdea, null, 2)}\r\n    Functional Requirements: ${JSON.stringify(requirements, null, 2)}\r\n    \r\n    For each entity, provide:\r\n    - Entity name\r\n    - Brief description of what it represents\r\n    - Key attributes (conceptual, not technical)\r\n    - Relationships to other entities\r\n    \r\n    Focus on business/domain entities, not technical implementation.\r\n    Return as JSON array of objects with name, description, attributes, relationships.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('anthropic', prompt);\r\n      const entities = JSON.parse(response);\r\n      return entities.map((entity: any) => `${entity.name}: ${entity.description}`);\r\n    } catch (error) {\r\n      console.error('Error identifying key entities:', error);\r\n      return ['User: Person who interacts with the system'];\r\n    }\r\n  }\r\n\r\n  private async checkConstitutionCompliance(specSections: any): Promise<ConstitutionCheck> {\r\n    const prompt = `\r\n    Check this specification against AstraForge development constitution:\r\n    \r\n    Specification: ${JSON.stringify(specSections, null, 2)}\r\n    \r\n    Evaluate:\r\n    1. Simplicity (avoid over-engineering)\r\n    2. Clear scope and boundaries\r\n    3. Testable requirements\r\n    4. User-focused (not tech-focused)\r\n    5. Appropriate complexity level\r\n    \r\n    Return JSON with:\r\n    {\r\n      \"passed\": boolean,\r\n      \"violations\": [\"specific issues\"],\r\n      \"warnings\": [\"potential concerns\"],\r\n      \"complexityScore\": 1-10 (1=simple, 10=very complex)\r\n    }\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error checking constitution compliance:', error);\r\n      return {\r\n        passed: true,\r\n        violations: [],\r\n        warnings: [],\r\n        complexityScore: 5\r\n      };\r\n    }\r\n  }\r\n\r\n  private async identifyClarifications(specSections: any): Promise<string[]> {\r\n    const prompt = `\r\n    Identify areas that need clarification in this specification:\r\n    \r\n    ${JSON.stringify(specSections, null, 2)}\r\n    \r\n    Look for:\r\n    1. Ambiguous requirements\r\n    2. Missing user types/roles\r\n    3. Undefined business rules\r\n    4. Unclear success criteria\r\n    5. Integration assumptions\r\n    6. Performance/scale expectations\r\n    \r\n    Return JSON array of specific questions that need answers.\r\n    Format: \"NEEDS CLARIFICATION: [specific question]\"\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('anthropic', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error identifying clarifications:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  private assembleSpecification(request: SpecificationRequest, sections: any, clarifications: string[]): string {\r\n    const currentDate = new Date().toISOString().split('T')[0];\r\n    \r\n    let spec = this.specTemplate;\r\n    \r\n    // Replace template variables\r\n    spec = spec.replace('{{FEATURE_NAME}}', sections.featureName || 'New Feature');\r\n    spec = spec.replace('{{BRANCH_NAME}}', sections.branchName || '001-new-feature');\r\n    spec = spec.replace('{{DATE}}', currentDate);\r\n    spec = spec.replace('{{USER_INPUT}}', request.userIdea || 'User provided idea');\r\n    \r\n    // Replace content sections\r\n    spec = spec.replace('{{PRIMARY_USER_STORY}}', sections.userScenarios?.join('\\n\\n') || 'User story to be defined');\r\n    spec = spec.replace('{{ACCEPTANCE_SCENARIOS}}', sections.acceptanceScenarios?.map((s: string, i: number) => `${i + 1}. ${s}`).join('\\n') || 'Scenarios to be defined');\r\n    spec = spec.replace('{{EDGE_CASES}}', sections.edgeCases?.map((e: string) => `- ${e}`).join('\\n') || 'Edge cases to be identified');\r\n    spec = spec.replace('{{FUNCTIONAL_REQUIREMENTS}}', sections.functionalRequirements?.map((r: string) => `- **${r}**`).join('\\n') || 'Requirements to be defined');\r\n    spec = spec.replace('{{KEY_ENTITIES}}', sections.keyEntities?.map((e: string) => `- **${e}**`).join('\\n') || 'Entities to be identified');\r\n    spec = spec.replace('{{CLARIFICATIONS_NEEDED}}', clarifications.map(c => `- ${c}`).join('\\n') || 'No clarifications needed');\r\n    \r\n    return spec;\r\n  }\r\n\r\n  public async refineSpecification(existingSpec: string, refinements: string[]): Promise<GeneratedSpec> {\r\n    logger.info('Refining specification...');\r\n    const prompt = `\r\n    Refine this existing specification based on user feedback:\r\n    \r\n    Existing Spec:\r\n    ${existingSpec}\r\n    \r\n    Refinements Requested:\r\n    ${refinements.join('\\n')}\r\n    \r\n    Update the specification to address the refinements while maintaining structure and quality.\r\n    Return the complete refined specification.\r\n    `;\r\n\r\n    const refinedContent = await this.llmManager.generateResponse('openai', prompt);\r\n    \r\n    // Re-analyze the refined specification\r\n    const analysis = await this.analyzeSpecification(refinedContent);\r\n    \r\n    return {\r\n      title: analysis.title,\r\n      content: refinedContent,\r\n      clarificationNeeded: analysis.clarificationNeeded,\r\n      functionalRequirements: analysis.functionalRequirements,\r\n      userScenarios: analysis.userScenarios,\r\n      keyEntities: analysis.keyEntities,\r\n      constitutionCompliance: analysis.constitutionCompliance\r\n    };\r\n  }\r\n\r\n  private async analyzeSpecification(specContent: string): Promise<any> {\r\n    // Extract information from the specification content\r\n    const prompt = `\r\n    Analyze this specification and extract structured information:\r\n    \r\n    ${specContent}\r\n    \r\n    Return JSON with:\r\n    {\r\n      \"title\": \"feature name\",\r\n      \"clarificationNeeded\": [\"list of clarifications\"],\r\n      \"functionalRequirements\": [\"list of requirements\"],\r\n      \"userScenarios\": [\"list of scenarios\"],\r\n      \"keyEntities\": [\"list of entities\"],\r\n      \"constitutionCompliance\": {\r\n        \"passed\": boolean,\r\n        \"violations\": [],\r\n        \"warnings\": [],\r\n        \"complexityScore\": number\r\n      }\r\n    }\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('anthropic', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error analyzing specification:', error);\r\n      return {\r\n        title: 'Analyzed Feature',\r\n        clarificationNeeded: [],\r\n        functionalRequirements: [],\r\n        userScenarios: [],\r\n        keyEntities: [],\r\n        constitutionCompliance: { passed: true, violations: [], warnings: [], complexityScore: 5 }\r\n      };\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\spec-kit\\specKitManager.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'createImplementationPlan' has too many lines (53). Maximum allowed is 50.","line":152,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":204,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5252,5255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5252,5255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'timestamp' is assigned a value but never used.","line":295,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":295,"endColumn":20,"suggestions":[{"messageId":"removeVar","data":{"varName":"timestamp"},"fix":{"range":[10373,10448],"text":""},"desc":"Remove unused variable 'timestamp'."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":325,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":325,"endColumn":20,"suggestions":[{"fix":{"range":[11610,11659],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":368,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":368,"endColumn":20,"suggestions":[{"fix":{"range":[13003,13050],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'createAstraForgeConstitution' has too many lines (95). Maximum allowed is 50.","line":372,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":466,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":468,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":468,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16938,16941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16938,16941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":511,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":514,"endColumn":12,"suggestions":[{"messageId":"addBrackets","fix":{"range":[18509,18873],"text":"{ const refinements = await vscode.window.showInputBox({\r\n          prompt: 'Enter refinements (comma-separated)',\r\n          placeHolder: 'Add more details about user roles, clarify requirements...'\r\n        });\r\n        if (refinements) {\r\n          await this.refineSpecification(workflow.id, refinements.split(',').map(r => r.trim()));\r\n        }\r\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":520,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":520,"endColumn":82,"suggestions":[{"messageId":"addBrackets","fix":{"range":[18908,19053],"text":"{ const specUri = vscode.Uri.file(path.join(workflow.specsDir, 'spec.md'));\r\n        await vscode.window.showTextDocument(specUri);\r\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":548,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":548,"endColumn":82,"suggestions":[{"messageId":"addBrackets","fix":{"range":[20037,20182],"text":"{ const planUri = vscode.Uri.file(path.join(workflow.specsDir, 'plan.md'));\r\n        await vscode.window.showTextDocument(planUri);\r\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":552,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":552,"endColumn":90,"suggestions":[{"messageId":"addBrackets","fix":{"range":[20223,20380],"text":"{ const researchUri = vscode.Uri.file(path.join(workflow.specsDir, 'research.md'));\r\n        await vscode.window.showTextDocument(researchUri);\r\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":583,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":583,"endColumn":84,"suggestions":[{"messageId":"addBrackets","fix":{"range":[21553,21701],"text":"{ const tasksUri = vscode.Uri.file(path.join(workflow.specsDir, 'tasks.md'));\r\n        await vscode.window.showTextDocument(tasksUri);\r\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":600,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":600,"endColumn":20,"suggestions":[{"fix":{"range":[22236,22290],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { LLMManager } from '../llm/llmManager';\r\nimport { VectorDB } from '../db/vectorDB';\r\nimport { GitManager } from '../git/gitManager';\r\nimport { SpecGenerator, GeneratedSpec, SpecificationRequest } from './specGenerator';\r\nimport { PlanGenerator, TechnicalPlan } from './planGenerator';\r\nimport { TaskGenerator, TaskList } from './taskGenerator';\r\nimport { logger } from '../utils/logger';\r\n\r\nexport interface SpecKitWorkflow {\r\n  id: string;\r\n  featureName: string;\r\n  status: 'specification' | 'planning' | 'tasks' | 'implementation' | 'complete';\r\n  spec?: GeneratedSpec;\r\n  plan?: TechnicalPlan;\r\n  tasks?: TaskList;\r\n  workspaceDir: string;\r\n  specsDir: string;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface SpecKitConfig {\r\n  autoCommit: boolean;\r\n  useMultiLLM: boolean;\r\n  enforceConstitution: boolean;\r\n  defaultTechStack: {\r\n    language: string;\r\n    framework: string;\r\n    testing: string;\r\n  };\r\n}\r\n\r\nexport class SpecKitManager {\r\n  private llmManager: LLMManager;\r\n  private vectorDB: VectorDB;\r\n  private gitManager: GitManager;\r\n  private specGenerator: SpecGenerator;\r\n  private planGenerator: PlanGenerator;\r\n  private taskGenerator: TaskGenerator;\r\n  private workflows: Map<string, SpecKitWorkflow> = new Map();\r\n  private config: SpecKitConfig;\r\n\r\n  constructor(\r\n    llmManager: LLMManager,\r\n    vectorDB: VectorDB,\r\n    gitManager: GitManager\r\n  ) {\r\n    this.llmManager = llmManager;\r\n    this.vectorDB = vectorDB;\r\n    this.gitManager = gitManager;\r\n    \r\n    this.specGenerator = new SpecGenerator(llmManager, vectorDB);\r\n    this.planGenerator = new PlanGenerator(llmManager, vectorDB);\r\n    this.taskGenerator = new TaskGenerator(llmManager, vectorDB);\r\n    \r\n    this.config = this.loadConfig();\r\n  }\r\n\r\n  private loadConfig(): SpecKitConfig {\r\n    const workspaceConfig = vscode.workspace.getConfiguration('astraforge.specKit');\r\n    return {\r\n      autoCommit: workspaceConfig.get('autoCommit', true),\r\n      useMultiLLM: workspaceConfig.get('useMultiLLM', true),\r\n      enforceConstitution: workspaceConfig.get('enforceConstitution', true),\r\n      defaultTechStack: {\r\n        language: workspaceConfig.get('defaultLanguage', 'TypeScript'),\r\n        framework: workspaceConfig.get('defaultFramework', 'Node.js'),\r\n        testing: workspaceConfig.get('defaultTesting', 'Jest')\r\n      }\r\n    };\r\n  }\r\n\r\n  public async initializeSpecKit(workspaceDir: string): Promise<void> {\r\n    logger.info('Initializing Spec Kit...');\r\n    \r\n    const specsDir = path.join(workspaceDir, 'specs');\r\n    const templatesDir = path.join(workspaceDir, 'templates');\r\n    const scriptsDir = path.join(workspaceDir, 'scripts');\r\n    const memoryDir = path.join(workspaceDir, 'memory');\r\n\r\n    // Create directory structure\r\n    await this.createDirectoryStructure([specsDir, templatesDir, scriptsDir, memoryDir]);\r\n    \r\n    // Copy templates from spec-kit\r\n    await this.copySpecKitTemplates(templatesDir);\r\n    \r\n    // Copy scripts\r\n    await this.copySpecKitScripts(scriptsDir);\r\n    \r\n    // Create AstraForge constitution\r\n    await this.createAstraForgeConstitution(memoryDir);\r\n    \r\n    // Initialize git if not already initialized\r\n    if (this.config.autoCommit) {\r\n      await this.gitManager.initRepo(workspaceDir);\r\n      await this.gitManager.addAndCommit(['specs/', 'templates/', 'scripts/', 'memory/'], 'Initialize Spec Kit structure');\r\n    }\r\n\r\n    vscode.window.showInformationMessage('✅ Spec Kit initialized successfully!');\r\n  }\r\n\r\n  public async createSpecification(request: SpecificationRequest): Promise<string> {\r\n    logger.info('SpecKit: createSpecification');\r\n    \r\n    // Generate specification\r\n    const spec = await this.specGenerator.generateSpecification(request);\r\n    \r\n    // Create workflow\r\n    const workflowId = this.generateWorkflowId();\r\n    const workspaceDir = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || process.cwd();\r\n    const specsDir = path.join(workspaceDir, 'specs', `${workflowId}-${spec.title.toLowerCase().replace(/\\s+/g, '-')}`);\r\n    \r\n    const workflow: SpecKitWorkflow = {\r\n      id: workflowId,\r\n      featureName: spec.title,\r\n      status: 'specification',\r\n      spec,\r\n      workspaceDir,\r\n      specsDir,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n    \r\n    this.workflows.set(workflowId, workflow);\r\n    \r\n    // Create spec directory and save specification\r\n    await this.createDirectoryStructure([specsDir]);\r\n    const specPath = path.join(specsDir, 'spec.md');\r\n    await fs.promises.writeFile(specPath, spec.content, 'utf8');\r\n    \r\n    // Save to vector DB for context\r\n    await this.vectorDB.addDocument(`spec-${workflowId}`, spec.content, {\r\n      type: 'specification',\r\n      workflowId,\r\n      featureName: spec.title\r\n    });\r\n    \r\n    // Auto-commit if enabled\r\n    if (this.config.autoCommit) {\r\n      await this.gitManager.addAndCommit([specPath], `Add specification: ${spec.title}`);\r\n    }\r\n    \r\n    // Show results to user\r\n    await this.showSpecificationResults(workflow);\r\n    \r\n    return workflowId;\r\n  }\r\n\r\n  public async createImplementationPlan(workflowId: string, technicalRequirements?: any): Promise<void> {\r\n    logger.info('SpecKit: createImplementationPlan');\r\n    const workflow = this.workflows.get(workflowId);\r\n    if (!workflow || !workflow.spec) {\r\n      throw new Error('Workflow or specification not found');\r\n    }\r\n\r\n    // Generate technical plan\r\n    const plan = await this.planGenerator.generatePlan(workflow.spec, technicalRequirements);\r\n    \r\n    // Execute research tasks\r\n    const completedResearch = await this.planGenerator.executeResearch(plan.researchTasks);\r\n    plan.researchTasks = completedResearch;\r\n    \r\n    // Update workflow\r\n    workflow.plan = plan;\r\n    workflow.status = 'planning';\r\n    workflow.updatedAt = new Date();\r\n    \r\n    // Save plan documents\r\n    const planPath = path.join(workflow.specsDir, 'plan.md');\r\n    const researchPath = path.join(workflow.specsDir, 'research.md');\r\n    const dataModelPath = path.join(workflow.specsDir, 'data-model.md');\r\n    const contractsDir = path.join(workflow.specsDir, 'contracts');\r\n    \r\n    await fs.promises.writeFile(planPath, plan.content, 'utf8');\r\n    await fs.promises.writeFile(researchPath, this.formatResearchResults(plan.researchTasks), 'utf8');\r\n    await fs.promises.writeFile(dataModelPath, plan.designPhase.dataModel, 'utf8');\r\n    \r\n    // Create contracts directory and files\r\n    await this.createDirectoryStructure([contractsDir]);\r\n    for (const contract of plan.designPhase.apiContracts) {\r\n      const contractPath = path.join(contractsDir, `${contract.toLowerCase().replace(/\\s+/g, '-')}.json`);\r\n      await fs.promises.writeFile(contractPath, JSON.stringify({ contract }, null, 2), 'utf8');\r\n    }\r\n    \r\n    // Save to vector DB\r\n    await this.vectorDB.addDocument(`plan-${workflowId}`, plan.content, {\r\n      type: 'plan',\r\n      workflowId,\r\n      featureName: workflow.featureName\r\n    });\r\n    \r\n    // Auto-commit if enabled\r\n    if (this.config.autoCommit) {\r\n      await this.gitManager.addAndCommit([\r\n        planPath, researchPath, dataModelPath, contractsDir\r\n      ], `Add implementation plan: ${workflow.featureName}`);\r\n    }\r\n    \r\n    // Show results\r\n    await this.showPlanResults(workflow);\r\n  }\r\n\r\n  public async generateTasks(workflowId: string): Promise<void> {\r\n    logger.info('SpecKit: generateTasks');\r\n    const workflow = this.workflows.get(workflowId);\r\n    if (!workflow || !workflow.plan) {\r\n      throw new Error('Workflow or plan not found');\r\n    }\r\n\r\n    // Generate task list\r\n    const taskList = await this.taskGenerator.generateTasks(workflow.plan);\r\n    \r\n    // Validate tasks\r\n    const validation = await this.taskGenerator.validateTasks(taskList);\r\n    if (!validation.valid) {\r\n      const proceed = await vscode.window.showWarningMessage(\r\n        `Task validation found issues:\\n${validation.issues.join('\\n')}\\n\\nProceed anyway?`,\r\n        'Proceed', 'Fix Issues'\r\n      );\r\n      \r\n      if (proceed !== 'Proceed') {\r\n        return;\r\n      }\r\n    }\r\n    \r\n    // Update workflow\r\n    workflow.tasks = taskList;\r\n    workflow.status = 'tasks';\r\n    workflow.updatedAt = new Date();\r\n    \r\n    // Save tasks\r\n    const tasksPath = path.join(workflow.specsDir, 'tasks.md');\r\n    await fs.promises.writeFile(tasksPath, taskList.content, 'utf8');\r\n    \r\n    // Save to vector DB\r\n    await this.vectorDB.addDocument(`tasks-${workflowId}`, taskList.content, {\r\n      type: 'tasks',\r\n      workflowId,\r\n      featureName: workflow.featureName\r\n    });\r\n    \r\n    // Auto-commit if enabled\r\n    if (this.config.autoCommit) {\r\n      await this.gitManager.addAndCommit([tasksPath], `Add task list: ${workflow.featureName}`);\r\n    }\r\n    \r\n    // Show results\r\n    await this.showTaskResults(workflow);\r\n  }\r\n\r\n  public async refineSpecification(workflowId: string, refinements: string[]): Promise<void> {\r\n    const workflow = this.workflows.get(workflowId);\r\n    if (!workflow || !workflow.spec) {\r\n      throw new Error('Workflow or specification not found');\r\n    }\r\n\r\n    // Refine specification\r\n    const refinedSpec = await this.specGenerator.refineSpecification(workflow.spec.content, refinements);\r\n    \r\n    // Update workflow\r\n    workflow.spec = refinedSpec;\r\n    workflow.updatedAt = new Date();\r\n    \r\n    // Save refined specification\r\n    const specPath = path.join(workflow.specsDir, 'spec.md');\r\n    await fs.promises.writeFile(specPath, refinedSpec.content, 'utf8');\r\n    \r\n    // Update vector DB\r\n    await this.vectorDB.addDocument(`spec-${workflowId}`, refinedSpec.content, {\r\n      type: 'specification',\r\n      workflowId,\r\n      featureName: refinedSpec.title\r\n    });\r\n    \r\n    // Auto-commit if enabled\r\n    if (this.config.autoCommit) {\r\n      await this.gitManager.addAndCommit([specPath], `Refine specification: ${workflow.featureName}`);\r\n    }\r\n    \r\n    vscode.window.showInformationMessage('✅ Specification refined successfully!');\r\n  }\r\n\r\n  public getWorkflows(): SpecKitWorkflow[] {\r\n    return Array.from(this.workflows.values());\r\n  }\r\n\r\n  public getWorkflow(workflowId: string): SpecKitWorkflow | undefined {\r\n    return this.workflows.get(workflowId);\r\n  }\r\n\r\n  private generateWorkflowId(): string {\r\n    const timestamp = new Date().toISOString().split('T')[0].replace(/-/g, '');\r\n    const counter = String(this.workflows.size + 1).padStart(3, '0');\r\n    return `${counter}`;\r\n  }\r\n\r\n  private async createDirectoryStructure(dirs: string[]): Promise<void> {\r\n    for (const dir of dirs) {\r\n      await fs.promises.mkdir(dir, { recursive: true });\r\n    }\r\n  }\r\n\r\n  private async copySpecKitTemplates(templatesDir: string): Promise<void> {\r\n    const sourceTemplatesDir = path.join(__dirname, '../../temp_spec_kit/templates');\r\n    \r\n    try {\r\n      const templates = await fs.promises.readdir(sourceTemplatesDir, { recursive: true });\r\n      \r\n      for (const template of templates) {\r\n        if (typeof template === 'string' && template.endsWith('.md')) {\r\n          const sourcePath = path.join(sourceTemplatesDir, template);\r\n          const destPath = path.join(templatesDir, template);\r\n          \r\n          // Ensure destination directory exists\r\n          await fs.promises.mkdir(path.dirname(destPath), { recursive: true });\r\n          \r\n          const content = await fs.promises.readFile(sourcePath, 'utf8');\r\n          await fs.promises.writeFile(destPath, content, 'utf8');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error copying templates:', error);\r\n      // Create basic templates if copy fails\r\n      await this.createBasicTemplates(templatesDir);\r\n    }\r\n  }\r\n\r\n  private async createBasicTemplates(templatesDir: string): Promise<void> {\r\n    const specTemplate = `# Feature Specification: {{FEATURE_NAME}}\r\n\r\n**Created**: {{DATE}}\r\n**Status**: Draft\r\n\r\n## User Scenarios & Testing\r\n{{USER_SCENARIOS}}\r\n\r\n## Requirements\r\n{{FUNCTIONAL_REQUIREMENTS}}\r\n\r\n## Review & Acceptance Checklist\r\n- [ ] Requirements are testable and unambiguous\r\n- [ ] Success criteria are measurable\r\n- [ ] Scope is clearly bounded\r\n`;\r\n\r\n    await fs.promises.writeFile(path.join(templatesDir, 'spec-template.md'), specTemplate, 'utf8');\r\n  }\r\n\r\n  private async copySpecKitScripts(scriptsDir: string): Promise<void> {\r\n    const sourceScriptsDir = path.join(__dirname, '../../temp_spec_kit/scripts/powershell');\r\n    \r\n    try {\r\n      const scripts = await fs.promises.readdir(sourceScriptsDir);\r\n      \r\n      for (const script of scripts) {\r\n        if (script.endsWith('.ps1')) {\r\n          const sourcePath = path.join(sourceScriptsDir, script);\r\n          const destPath = path.join(scriptsDir, script);\r\n          \r\n          const content = await fs.promises.readFile(sourcePath, 'utf8');\r\n          await fs.promises.writeFile(destPath, content, 'utf8');\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Error copying scripts:', error);\r\n    }\r\n  }\r\n\r\n  private async createAstraForgeConstitution(memoryDir: string): Promise<void> {\r\n    const constitution = `# AstraForge Development Constitution\r\n\r\n## Core Principles\r\n\r\n### I. AI-First Development\r\nEvery feature leverages AI collaboration for design, implementation, and optimization.\r\nMulti-LLM panels provide diverse perspectives and reduce single-point-of-failure in decision making.\r\nVector-based context ensures decisions are informed by project history and best practices.\r\n\r\n### II. Spec-Driven Development\r\nSpecifications are executable and directly generate implementations.\r\nRequirements are validated through multi-agent collaboration before implementation begins.\r\nTest-driven development is mandatory: Red-Green-Refactor cycle strictly enforced.\r\n\r\n### III. Self-Improving Systems\r\nFeedback loops capture user interactions and system performance.\r\nWorkflows adapt based on success patterns and failure analysis.\r\nKnowledge base grows with each project, improving future recommendations.\r\n\r\n### IV. Modular Architecture\r\nEvery feature starts as a standalone, testable library.\r\nClear separation of concerns with defined interfaces.\r\nVS Code extension architecture supports pluggable components.\r\n\r\n### V. Quality Gates (NON-NEGOTIABLE)\r\nConstitution compliance checked at each phase.\r\nTest coverage minimum 85% with real dependencies.\r\nPerformance benchmarks validated before deployment.\r\nSecurity scans mandatory for external integrations.\r\n\r\n## Development Workflow\r\n\r\n### Phase 0: Specification\r\n- Multi-LLM collaboration generates comprehensive specs\r\n- User scenarios validate against real needs\r\n- Constitution compliance verified\r\n- Clarifications resolved before proceeding\r\n\r\n### Phase 1: Technical Planning\r\n- Research tasks executed with web search\r\n- Architecture decisions documented with rationale\r\n- API contracts generated from specifications\r\n- Test strategies planned following TDD principles\r\n\r\n### Phase 2: Task Generation\r\n- Granular, executable tasks with clear dependencies\r\n- Parallel execution opportunities identified\r\n- TDD order enforced: Tests before implementation\r\n- File-level dependency tracking prevents conflicts\r\n\r\n### Phase 3: Implementation\r\n- Automated task execution with AI assistance\r\n- Real-time progress tracking and adaptation\r\n- Continuous integration with quality gates\r\n- Vector DB captures implementation patterns\r\n\r\n### Phase 4: Validation & Deployment\r\n- Comprehensive testing including performance benchmarks\r\n- User acceptance validation against original specifications\r\n- Deployment automation with rollback capabilities\r\n- Post-deployment monitoring and feedback collection\r\n\r\n## Technology Standards\r\n\r\n### Languages & Frameworks\r\n- Primary: TypeScript 5.1+ for VS Code extensions\r\n- Testing: Jest with comprehensive coverage reporting\r\n- Storage: Vector DB (Vectra) + file system for specifications\r\n- Communication: Multi-LLM APIs (OpenAI, Anthropic, xAI, OpenRouter)\r\n\r\n### Architecture Patterns\r\n- Event-driven architecture for extension components\r\n- Provider pattern for UI components\r\n- Manager pattern for system integration\r\n- Repository pattern for data persistence\r\n\r\n### Quality Standards\r\n- Cyclomatic complexity ≤ 10\r\n- Test coverage ≥ 85%\r\n- Code duplication ≤ 3%\r\n- Performance: <100ms response time for UI actions\r\n\r\n## Governance\r\n\r\nThis constitution supersedes all other development practices.\r\nViolations must be explicitly justified with technical rationale.\r\nAmendments require documentation, team approval, and migration plan.\r\nAll code reviews verify constitutional compliance.\r\n\r\n**Version**: 1.0.0 | **Ratified**: ${new Date().toISOString().split('T')[0]} | **Last Amended**: ${new Date().toISOString().split('T')[0]}\r\n`;\r\n\r\n    await fs.promises.writeFile(path.join(memoryDir, 'constitution.md'), constitution, 'utf8');\r\n  }\r\n\r\n  private formatResearchResults(researchTasks: any[]): string {\r\n    let content = '# Research Results\\n\\n';\r\n    \r\n    researchTasks.forEach(task => {\r\n      content += `## ${task.id}: ${task.description}\\n\\n`;\r\n      content += `**Rationale**: ${task.rationale}\\n\\n`;\r\n      content += `**Alternatives Considered**: ${task.alternatives.join(', ')}\\n\\n`;\r\n      if (task.decision) {\r\n        content += `**Decision**: ${task.decision}\\n\\n`;\r\n      }\r\n      content += '---\\n\\n';\r\n    });\r\n    \r\n    return content;\r\n  }\r\n\r\n  private async showSpecificationResults(workflow: SpecKitWorkflow): Promise<void> {\r\n    const spec = workflow.spec!;\r\n    \r\n    let message = `✅ Specification created: ${spec.title}\\n\\n`;\r\n    \r\n    if (spec.clarificationNeeded.length > 0) {\r\n      message += `⚠️  Clarifications needed:\\n${spec.clarificationNeeded.map(c => `• ${c}`).join('\\n')}\\n\\n`;\r\n    }\r\n    \r\n    if (!spec.constitutionCompliance.passed) {\r\n      message += `🚨 Constitution violations:\\n${spec.constitutionCompliance.violations.map(v => `• ${v}`).join('\\n')}\\n\\n`;\r\n    }\r\n    \r\n    message += `📋 ${spec.functionalRequirements.length} functional requirements\\n`;\r\n    message += `👥 ${spec.userScenarios.length} user scenarios\\n`;\r\n    message += `🏗️  ${spec.keyEntities.length} key entities identified`;\r\n    \r\n    const action = await vscode.window.showInformationMessage(\r\n      message,\r\n      'Create Plan', 'Refine Spec', 'View Spec'\r\n    );\r\n    \r\n    switch (action) {\r\n      case 'Create Plan':\r\n        await this.createImplementationPlan(workflow.id);\r\n        break;\r\n      case 'Refine Spec':\r\n        const refinements = await vscode.window.showInputBox({\r\n          prompt: 'Enter refinements (comma-separated)',\r\n          placeHolder: 'Add more details about user roles, clarify requirements...'\r\n        });\r\n        if (refinements) {\r\n          await this.refineSpecification(workflow.id, refinements.split(',').map(r => r.trim()));\r\n        }\r\n        break;\r\n      case 'View Spec':\r\n        const specUri = vscode.Uri.file(path.join(workflow.specsDir, 'spec.md'));\r\n        await vscode.window.showTextDocument(specUri);\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async showPlanResults(workflow: SpecKitWorkflow): Promise<void> {\r\n    const plan = workflow.plan!;\r\n    \r\n    let message = `✅ Implementation plan created: ${workflow.featureName}\\n\\n`;\r\n    message += `🏗️  Project type: ${plan.projectStructure.type}\\n`;\r\n    message += `💻 Tech stack: ${plan.technicalContext.language}, ${plan.technicalContext.primaryDependencies.join(', ')}\\n`;\r\n    message += `🔍 ${plan.researchTasks.length} research tasks completed\\n`;\r\n    \r\n    if (plan.constitutionCheck.violations.length > 0) {\r\n      message += `\\n🚨 Constitution violations:\\n${plan.constitutionCheck.violations.map(v => `• ${v}`).join('\\n')}`;\r\n    }\r\n    \r\n    const action = await vscode.window.showInformationMessage(\r\n      message,\r\n      'Generate Tasks', 'View Plan', 'Review Research'\r\n    );\r\n    \r\n    switch (action) {\r\n      case 'Generate Tasks':\r\n        await this.generateTasks(workflow.id);\r\n        break;\r\n      case 'View Plan':\r\n        const planUri = vscode.Uri.file(path.join(workflow.specsDir, 'plan.md'));\r\n        await vscode.window.showTextDocument(planUri);\r\n        break;\r\n      case 'Review Research':\r\n        const researchUri = vscode.Uri.file(path.join(workflow.specsDir, 'research.md'));\r\n        await vscode.window.showTextDocument(researchUri);\r\n        break;\r\n    }\r\n  }\r\n\r\n  private async showTaskResults(workflow: SpecKitWorkflow): Promise<void> {\r\n    const tasks = workflow.tasks!;\r\n    \r\n    let message = `✅ Task list generated: ${workflow.featureName}\\n\\n`;\r\n    message += `📋 ${tasks.tasks.length} tasks created\\n`;\r\n    message += `⏱️  Estimated duration: ${tasks.estimatedDuration}\\n`;\r\n    message += `🔄 ${tasks.parallelGroups.length} parallel execution groups\\n`;\r\n    \r\n    const testTasks = tasks.tasks.filter(t => t.type === 'test').length;\r\n    const implTasks = tasks.tasks.filter(t => t.type === 'implementation').length;\r\n    \r\n    message += `\\n🧪 ${testTasks} test tasks (TDD enforced)\\n`;\r\n    message += `⚙️ ${implTasks} implementation tasks`;\r\n    \r\n    const action = await vscode.window.showInformationMessage(\r\n      message,\r\n      'Start Implementation', 'View Tasks', 'Export Tasks'\r\n    );\r\n    \r\n    switch (action) {\r\n      case 'Start Implementation':\r\n        // This would integrate with the existing workflow manager\r\n        vscode.window.showInformationMessage('🚀 Ready for implementation! Tasks are available in the workflow manager.');\r\n        break;\r\n      case 'View Tasks':\r\n        const tasksUri = vscode.Uri.file(path.join(workflow.specsDir, 'tasks.md'));\r\n        await vscode.window.showTextDocument(tasksUri);\r\n        break;\r\n      case 'Export Tasks':\r\n        // Export to project management tool or clipboard\r\n        await vscode.env.clipboard.writeText(tasks.content);\r\n        vscode.window.showInformationMessage('📋 Tasks copied to clipboard');\r\n        break;\r\n    }\r\n  }\r\n\r\n  public async cleanupTempFiles(): Promise<void> {\r\n    // Clean up temporary spec-kit repository\r\n    const tempDir = path.join(process.cwd(), 'temp_spec_kit');\r\n    try {\r\n      await fs.promises.rm(tempDir, { recursive: true, force: true });\r\n    } catch (error) {\r\n      console.error('Error cleaning up temp files:', error);\r\n    }\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\spec-kit\\taskGenerator.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":56,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":56,"endColumn":20,"suggestions":[{"fix":{"range":[1452,1506],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateSetupTasks' has too many lines (66). Maximum allowed is 50.","line":139,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":204,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4574,4577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4574,4577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":20,"suggestions":[{"fix":{"range":[5034,5088],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateTestTasks' has too many lines (53). Maximum allowed is 50.","line":206,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":258,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6738,6741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6738,6741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":243,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":243,"endColumn":20,"suggestions":[{"fix":{"range":[7183,7236],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'generateImplementationTasks' has too many lines (56). Maximum allowed is 50.","line":260,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":315,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":288,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8619,8622],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8619,8622],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":300,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":300,"endColumn":20,"suggestions":[{"fix":{"range":[9086,9149],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":338,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":338,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10287,10290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10287,10290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":350,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":350,"endColumn":20,"suggestions":[{"fix":{"range":[10748,10808],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":388,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":388,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11944,11947],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11944,11947],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":400,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":400,"endColumn":20,"suggestions":[{"fix":{"range":[12391,12446],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'plan' is defined but never used.","line":417,"column":53,"nodeType":"Identifier","messageId":"unusedVar","endLine":417,"endColumn":72,"suggestions":[{"messageId":"removeVar","data":{"varName":"plan"},"fix":{"range":[12863,12884],"text":""},"desc":"Remove unused variable 'plan'."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":436,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":436,"endColumn":20,"suggestions":[{"fix":{"range":[13672,13727],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'generateBasicDependencies' has too many lines (59). Maximum allowed is 50.","line":442,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":500,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":577,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":577,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18523,18526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18523,18526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'implementationTasks' is assigned a value but never used.","line":662,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":662,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"implementationTasks"},"fix":{"range":[22477,22561],"text":""},"desc":"Remove unused variable 'implementationTasks'."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LLMManager } from '../llm/llmManager';\r\nimport { VectorDB } from '../db/vectorDB';\r\nimport { logger } from '../utils/logger';\r\nimport { TechnicalPlan } from './planGenerator';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\nexport interface TaskList {\r\n  tasks: Task[];\r\n  dependencies: TaskDependency[];\r\n  parallelGroups: ParallelGroup[];\r\n  estimatedDuration: string;\r\n  content: string;\r\n}\r\n\r\nexport interface Task {\r\n  id: string;\r\n  phase: string;\r\n  description: string;\r\n  filePath: string;\r\n  isParallel: boolean;\r\n  prerequisites: string[];\r\n  estimatedTime: string;\r\n  type: 'setup' | 'test' | 'implementation' | 'integration' | 'polish';\r\n  priority: 'high' | 'medium' | 'low';\r\n}\r\n\r\nexport interface TaskDependency {\r\n  taskId: string;\r\n  dependsOn: string[];\r\n  reason: string;\r\n}\r\n\r\nexport interface ParallelGroup {\r\n  groupId: string;\r\n  tasks: string[];\r\n  description: string;\r\n}\r\n\r\nexport class TaskGenerator {\r\n  private llmManager: LLMManager;\r\n  private vectorDB: VectorDB;\r\n  private taskTemplate: string = '';\r\n\r\n  constructor(llmManager: LLMManager, vectorDB: VectorDB) {\r\n    this.llmManager = llmManager;\r\n    this.vectorDB = vectorDB;\r\n    this.loadTaskTemplate();\r\n  }\r\n\r\n  private loadTaskTemplate(): void {\r\n    const templatePath = path.join(__dirname, '../../templates/tasks-template.md');\r\n    try {\r\n      this.taskTemplate = fs.readFileSync(templatePath, 'utf8');\r\n    } catch (error) {\r\n      console.error('Failed to load task template:', error);\r\n      this.taskTemplate = this.getDefaultTaskTemplate();\r\n    }\r\n  }\r\n\r\n  private getDefaultTaskTemplate(): string {\r\n    return `# Tasks: {{FEATURE_NAME}}\r\n\r\n**Input**: Design documents from \\`/specs/{{FEATURE_DIR}}/\\`\r\n**Prerequisites**: plan.md (required), research.md, data-model.md, contracts/\r\n\r\n## Phase 3.1: Setup\r\n{{SETUP_TASKS}}\r\n\r\n## Phase 3.2: Tests First (TDD) ⚠️ MUST COMPLETE BEFORE 3.3\r\n**CRITICAL: These tests MUST be written and MUST FAIL before ANY implementation**\r\n{{TEST_TASKS}}\r\n\r\n## Phase 3.3: Core Implementation (ONLY after tests are failing)\r\n{{IMPLEMENTATION_TASKS}}\r\n\r\n## Phase 3.4: Integration\r\n{{INTEGRATION_TASKS}}\r\n\r\n## Phase 3.5: Polish\r\n{{POLISH_TASKS}}\r\n\r\n## Dependencies\r\n{{DEPENDENCIES}}\r\n\r\n## Parallel Execution Groups\r\n{{PARALLEL_GROUPS}}\r\n\r\n## Task Validation\r\n{{VALIDATION_CHECKLIST}}\r\n`;\r\n  }\r\n\r\n  public async generateTasks(plan: TechnicalPlan): Promise<TaskList> {\r\n    logger.info('Generating task list from implementation plan...');\r\n\r\n    // Generate tasks by phase\r\n    const setupTasks = await this.generateSetupTasks(plan);\r\n    const testTasks = await this.generateTestTasks(plan);\r\n    const implementationTasks = await this.generateImplementationTasks(plan);\r\n    const integrationTasks = await this.generateIntegrationTasks(plan);\r\n    const polishTasks = await this.generatePolishTasks(plan);\r\n\r\n    // Combine all tasks\r\n    const allTasks = [\r\n      ...setupTasks,\r\n      ...testTasks,\r\n      ...implementationTasks,\r\n      ...integrationTasks,\r\n      ...polishTasks\r\n    ];\r\n\r\n    // Generate dependencies\r\n    const dependencies = await this.generateDependencies(allTasks, plan);\r\n\r\n    // Identify parallel groups\r\n    const parallelGroups = await this.identifyParallelGroups(allTasks, dependencies);\r\n\r\n    // Estimate duration\r\n    const estimatedDuration = this.estimateDuration(allTasks);\r\n\r\n    // Assemble task list content\r\n    const content = this.assembleTaskList({\r\n      tasks: allTasks,\r\n      dependencies,\r\n      parallelGroups,\r\n      plan\r\n    });\r\n\r\n    return {\r\n      tasks: allTasks,\r\n      dependencies,\r\n      parallelGroups,\r\n      estimatedDuration,\r\n      content\r\n    };\r\n  }\r\n\r\n  private async generateSetupTasks(plan: TechnicalPlan): Promise<Task[]> {\r\n    logger.info('Generating setup tasks...');\r\n    const prompt = `\r\n    Generate setup tasks for this technical plan:\r\n    \r\n    Technical Context: ${JSON.stringify(plan.technicalContext, null, 2)}\r\n    Project Structure: ${JSON.stringify(plan.projectStructure, null, 2)}\r\n    \r\n    Generate 3-5 setup tasks covering:\r\n    1. Project structure creation\r\n    2. Dependency installation\r\n    3. Configuration setup\r\n    4. Development environment\r\n    5. Initial tooling\r\n    \r\n    Each task should specify:\r\n    - Exact file paths\r\n    - Clear descriptions\r\n    - Parallel execution potential\r\n    \r\n    Return JSON array of task objects.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      const tasks = JSON.parse(response);\r\n      \r\n      return tasks.map((task: any, index: number) => ({\r\n        id: `T${String(index + 1).padStart(3, '0')}`,\r\n        phase: 'setup',\r\n        description: task.description,\r\n        filePath: task.filePath || 'multiple',\r\n        isParallel: task.isParallel || false,\r\n        prerequisites: task.prerequisites || [],\r\n        estimatedTime: task.estimatedTime || '15-30 min',\r\n        type: 'setup' as const,\r\n        priority: 'high' as const\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error generating setup tasks:', error);\r\n      return [\r\n        {\r\n          id: 'T001',\r\n          phase: 'setup',\r\n          description: 'Create project structure per implementation plan',\r\n          filePath: 'multiple',\r\n          isParallel: false,\r\n          prerequisites: [],\r\n          estimatedTime: '15 min',\r\n          type: 'setup',\r\n          priority: 'high'\r\n        },\r\n        {\r\n          id: 'T002',\r\n          phase: 'setup',\r\n          description: `Initialize ${plan.technicalContext.language} project with dependencies`,\r\n          filePath: 'package.json',\r\n          isParallel: false,\r\n          prerequisites: ['T001'],\r\n          estimatedTime: '10 min',\r\n          type: 'setup',\r\n          priority: 'high'\r\n        }\r\n      ];\r\n    }\r\n  }\r\n\r\n  private async generateTestTasks(plan: TechnicalPlan): Promise<Task[]> {\r\n    const prompt = `\r\n    Generate test tasks following TDD principles for this plan:\r\n    \r\n    Design Phase: ${JSON.stringify(plan.designPhase, null, 2)}\r\n    Technical Context: ${JSON.stringify(plan.technicalContext, null, 2)}\r\n    \r\n    Generate test tasks covering:\r\n    1. Contract tests (one per API endpoint)\r\n    2. Integration tests (one per user scenario)\r\n    3. Unit tests (for core logic)\r\n    \r\n    Requirements:\r\n    - Tests MUST be written before implementation\r\n    - Each test should target a specific file\r\n    - Mark parallel tasks appropriately\r\n    - Include exact file paths\r\n    \r\n    Return JSON array of test task objects.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('anthropic', prompt);\r\n      const tasks = JSON.parse(response);\r\n      \r\n      return tasks.map((task: any, index: number) => ({\r\n        id: `T${String(index + 10).padStart(3, '0')}`,\r\n        phase: 'tests',\r\n        description: task.description,\r\n        filePath: task.filePath,\r\n        isParallel: task.isParallel || true,\r\n        prerequisites: task.prerequisites || [],\r\n        estimatedTime: task.estimatedTime || '20-30 min',\r\n        type: 'test' as const,\r\n        priority: 'high' as const\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error generating test tasks:', error);\r\n      return [\r\n        {\r\n          id: 'T010',\r\n          phase: 'tests',\r\n          description: 'Create contract tests for API endpoints',\r\n          filePath: 'tests/contract/api.test.ts',\r\n          isParallel: true,\r\n          prerequisites: ['T002'],\r\n          estimatedTime: '30 min',\r\n          type: 'test',\r\n          priority: 'high'\r\n        }\r\n      ];\r\n    }\r\n  }\r\n\r\n  private async generateImplementationTasks(plan: TechnicalPlan): Promise<Task[]> {\r\n    const prompt = `\r\n    Generate implementation tasks for this plan:\r\n    \r\n    Design Phase: ${JSON.stringify(plan.designPhase, null, 2)}\r\n    Technical Context: ${JSON.stringify(plan.technicalContext, null, 2)}\r\n    Constitution Check: ${JSON.stringify(plan.constitutionCheck, null, 2)}\r\n    \r\n    Generate implementation tasks covering:\r\n    1. Data models/entities\r\n    2. Service layer\r\n    3. API endpoints\r\n    4. Business logic\r\n    5. CLI commands (if applicable)\r\n    \r\n    Requirements:\r\n    - Implementation ONLY after tests are written\r\n    - Each task targets specific files\r\n    - Follow constitutional principles\r\n    - Mark parallel opportunities\r\n    \r\n    Return JSON array of implementation task objects.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      const tasks = JSON.parse(response);\r\n      \r\n      return tasks.map((task: any, index: number) => ({\r\n        id: `T${String(index + 20).padStart(3, '0')}`,\r\n        phase: 'implementation',\r\n        description: task.description,\r\n        filePath: task.filePath,\r\n        isParallel: task.isParallel || false,\r\n        prerequisites: task.prerequisites || [],\r\n        estimatedTime: task.estimatedTime || '30-45 min',\r\n        type: 'implementation' as const,\r\n        priority: 'medium' as const\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error generating implementation tasks:', error);\r\n      return [\r\n        {\r\n          id: 'T020',\r\n          phase: 'implementation',\r\n          description: 'Implement core data models',\r\n          filePath: 'src/models/index.ts',\r\n          isParallel: true,\r\n          prerequisites: ['T010'],\r\n          estimatedTime: '45 min',\r\n          type: 'implementation',\r\n          priority: 'medium'\r\n        }\r\n      ];\r\n    }\r\n  }\r\n\r\n  private async generateIntegrationTasks(plan: TechnicalPlan): Promise<Task[]> {\r\n    const prompt = `\r\n    Generate integration tasks for this plan:\r\n    \r\n    Technical Context: ${JSON.stringify(plan.technicalContext, null, 2)}\r\n    Project Structure: ${JSON.stringify(plan.projectStructure, null, 2)}\r\n    \r\n    Generate integration tasks covering:\r\n    1. Database/storage integration\r\n    2. External service connections\r\n    3. Middleware setup\r\n    4. Error handling\r\n    5. Logging and monitoring\r\n    \r\n    Return JSON array of integration task objects.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('anthropic', prompt);\r\n      const tasks = JSON.parse(response);\r\n      \r\n      return tasks.map((task: any, index: number) => ({\r\n        id: `T${String(index + 30).padStart(3, '0')}`,\r\n        phase: 'integration',\r\n        description: task.description,\r\n        filePath: task.filePath,\r\n        isParallel: task.isParallel || false,\r\n        prerequisites: task.prerequisites || [],\r\n        estimatedTime: task.estimatedTime || '20-40 min',\r\n        type: 'integration' as const,\r\n        priority: 'medium' as const\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error generating integration tasks:', error);\r\n      return [\r\n        {\r\n          id: 'T030',\r\n          phase: 'integration',\r\n          description: 'Setup error handling and logging',\r\n          filePath: 'src/utils/errorHandler.ts',\r\n          isParallel: true,\r\n          prerequisites: ['T020'],\r\n          estimatedTime: '30 min',\r\n          type: 'integration',\r\n          priority: 'medium'\r\n        }\r\n      ];\r\n    }\r\n  }\r\n\r\n  private async generatePolishTasks(plan: TechnicalPlan): Promise<Task[]> {\r\n    const prompt = `\r\n    Generate polish/finalization tasks for this plan:\r\n    \r\n    Technical Context: ${JSON.stringify(plan.technicalContext, null, 2)}\r\n    Constitution Check: ${JSON.stringify(plan.constitutionCheck, null, 2)}\r\n    \r\n    Generate polish tasks covering:\r\n    1. Performance optimization\r\n    2. Code cleanup and refactoring\r\n    3. Documentation updates\r\n    4. Final testing\r\n    5. Deployment preparation\r\n    \r\n    Return JSON array of polish task objects.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('openai', prompt);\r\n      const tasks = JSON.parse(response);\r\n      \r\n      return tasks.map((task: any, index: number) => ({\r\n        id: `T${String(index + 40).padStart(3, '0')}`,\r\n        phase: 'polish',\r\n        description: task.description,\r\n        filePath: task.filePath,\r\n        isParallel: task.isParallel || true,\r\n        prerequisites: task.prerequisites || [],\r\n        estimatedTime: task.estimatedTime || '15-25 min',\r\n        type: 'polish' as const,\r\n        priority: 'low' as const\r\n      }));\r\n    } catch (error) {\r\n      console.error('Error generating polish tasks:', error);\r\n      return [\r\n        {\r\n          id: 'T040',\r\n          phase: 'polish',\r\n          description: 'Performance optimization and cleanup',\r\n          filePath: 'multiple',\r\n          isParallel: true,\r\n          prerequisites: ['T030'],\r\n          estimatedTime: '20 min',\r\n          type: 'polish',\r\n          priority: 'low'\r\n        }\r\n      ];\r\n    }\r\n  }\r\n\r\n  private async generateDependencies(tasks: Task[], plan: TechnicalPlan): Promise<TaskDependency[]> {\r\n    const prompt = `\r\n    Analyze these tasks and generate dependencies:\r\n    \r\n    Tasks: ${JSON.stringify(tasks.map(t => ({ id: t.id, description: t.description, filePath: t.filePath, type: t.type })), null, 2)}\r\n    \r\n    Identify dependencies based on:\r\n    1. File dependencies (same file can't be modified in parallel)\r\n    2. Logical dependencies (tests before implementation)\r\n    3. Build dependencies (setup before coding)\r\n    4. Integration dependencies (models before services)\r\n    \r\n    Return JSON array of dependency objects with taskId, dependsOn array, and reason.\r\n    `;\r\n\r\n    try {\r\n      const response = await this.llmManager.generateResponse('anthropic', prompt);\r\n      return JSON.parse(response);\r\n    } catch (error) {\r\n      console.error('Error generating dependencies:', error);\r\n      // Generate basic dependencies based on task types\r\n      return this.generateBasicDependencies(tasks);\r\n    }\r\n  }\r\n\r\n  private generateBasicDependencies(tasks: Task[]): TaskDependency[] {\r\n    const dependencies: TaskDependency[] = [];\r\n    \r\n    // Setup tasks come first\r\n    const setupTasks = tasks.filter(t => t.type === 'setup');\r\n    const testTasks = tasks.filter(t => t.type === 'test');\r\n    const implementationTasks = tasks.filter(t => t.type === 'implementation');\r\n    const integrationTasks = tasks.filter(t => t.type === 'integration');\r\n    const polishTasks = tasks.filter(t => t.type === 'polish');\r\n    \r\n    // Tests depend on setup\r\n    testTasks.forEach(task => {\r\n      if (setupTasks.length > 0) {\r\n        dependencies.push({\r\n          taskId: task.id,\r\n          dependsOn: [setupTasks[setupTasks.length - 1].id],\r\n          reason: 'Tests require project setup'\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Implementation depends on tests\r\n    implementationTasks.forEach(task => {\r\n      const relatedTestTask = testTasks.find(t => \r\n        t.filePath.includes(task.filePath.split('/').pop()?.split('.')[0] || '')\r\n      );\r\n      if (relatedTestTask) {\r\n        dependencies.push({\r\n          taskId: task.id,\r\n          dependsOn: [relatedTestTask.id],\r\n          reason: 'TDD: Implementation after tests'\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Integration depends on implementation\r\n    integrationTasks.forEach(task => {\r\n      if (implementationTasks.length > 0) {\r\n        dependencies.push({\r\n          taskId: task.id,\r\n          dependsOn: [implementationTasks[0].id],\r\n          reason: 'Integration requires core implementation'\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Polish depends on integration\r\n    polishTasks.forEach(task => {\r\n      if (integrationTasks.length > 0) {\r\n        dependencies.push({\r\n          taskId: task.id,\r\n          dependsOn: [integrationTasks[integrationTasks.length - 1].id],\r\n          reason: 'Polish after integration complete'\r\n        });\r\n      }\r\n    });\r\n    \r\n    return dependencies;\r\n  }\r\n\r\n  private async identifyParallelGroups(tasks: Task[], dependencies: TaskDependency[]): Promise<ParallelGroup[]> {\r\n    const groups: ParallelGroup[] = [];\r\n    const parallelTasks = tasks.filter(t => t.isParallel);\r\n    \r\n    // Group by phase and file independence\r\n    const phases = ['setup', 'tests', 'implementation', 'integration', 'polish'];\r\n    \r\n    phases.forEach(phase => {\r\n      const phaseTasks = parallelTasks.filter(t => t.phase === phase);\r\n      if (phaseTasks.length > 1) {\r\n        // Check if tasks can truly run in parallel (no file conflicts)\r\n        const independentTasks = this.findIndependentTasks(phaseTasks, dependencies);\r\n        if (independentTasks.length > 1) {\r\n          groups.push({\r\n            groupId: `PG_${phase.toUpperCase()}`,\r\n            tasks: independentTasks.map(t => t.id),\r\n            description: `Parallel ${phase} tasks - independent files`\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    return groups;\r\n  }\r\n\r\n  private findIndependentTasks(tasks: Task[], dependencies: TaskDependency[]): Task[] {\r\n    // Find tasks that don't modify the same files and have no dependencies between them\r\n    const independent: Task[] = [];\r\n    const fileMap = new Map<string, Task[]>();\r\n    \r\n    // Group by file path\r\n    tasks.forEach(task => {\r\n      const file = task.filePath;\r\n      if (!fileMap.has(file)) {\r\n        fileMap.set(file, []);\r\n      }\r\n      fileMap.get(file)!.push(task);\r\n    });\r\n    \r\n    // Only include files with single tasks (no conflicts)\r\n    fileMap.forEach(fileTasks => {\r\n      if (fileTasks.length === 1) {\r\n        const task = fileTasks[0];\r\n        // Check if this task has dependencies on other tasks in the same phase\r\n        const hasPhaseDependency = dependencies.some(dep => \r\n          dep.taskId === task.id && \r\n          tasks.some(t => t.id === dep.dependsOn[0] && t.phase === task.phase)\r\n        );\r\n        \r\n        if (!hasPhaseDependency) {\r\n          independent.push(task);\r\n        }\r\n      }\r\n    });\r\n    \r\n    return independent;\r\n  }\r\n\r\n  private estimateDuration(tasks: Task[]): string {\r\n    const totalMinutes = tasks.reduce((sum, task) => {\r\n      const timeRange = task.estimatedTime.match(/(\\d+)(?:-(\\d+))?\\s*min/);\r\n      if (timeRange) {\r\n        const min = parseInt(timeRange[1]);\r\n        const max = timeRange[2] ? parseInt(timeRange[2]) : min;\r\n        return sum + (min + max) / 2;\r\n      }\r\n      return sum + 30; // Default 30 minutes\r\n    }, 0);\r\n    \r\n    const hours = Math.round(totalMinutes / 60 * 10) / 10;\r\n    const days = Math.round(hours / 8 * 10) / 10;\r\n    \r\n    return `${hours} hours (${days} days at 8h/day)`;\r\n  }\r\n\r\n  private assembleTaskList(data: any): string {\r\n    let content = this.taskTemplate;\r\n    \r\n    const featureName = data.plan.summary.split(' ')[1] || 'Feature';\r\n    const featureDir = `001-${featureName.toLowerCase().replace(/\\s+/g, '-')}`;\r\n    \r\n    // Replace template variables\r\n    content = content.replace(/\\{\\{FEATURE_NAME\\}\\}/g, featureName);\r\n    content = content.replace(/\\{\\{FEATURE_DIR\\}\\}/g, featureDir);\r\n    \r\n    // Format task sections\r\n    const setupSection = this.formatTaskSection(data.tasks.filter((t: Task) => t.type === 'setup'));\r\n    const testSection = this.formatTaskSection(data.tasks.filter((t: Task) => t.type === 'test'));\r\n    const implementationSection = this.formatTaskSection(data.tasks.filter((t: Task) => t.type === 'implementation'));\r\n    const integrationSection = this.formatTaskSection(data.tasks.filter((t: Task) => t.type === 'integration'));\r\n    const polishSection = this.formatTaskSection(data.tasks.filter((t: Task) => t.type === 'polish'));\r\n    \r\n    content = content.replace('{{SETUP_TASKS}}', setupSection);\r\n    content = content.replace('{{TEST_TASKS}}', testSection);\r\n    content = content.replace('{{IMPLEMENTATION_TASKS}}', implementationSection);\r\n    content = content.replace('{{INTEGRATION_TASKS}}', integrationSection);\r\n    content = content.replace('{{POLISH_TASKS}}', polishSection);\r\n    \r\n    // Format dependencies\r\n    const dependencySection = this.formatDependencies(data.dependencies);\r\n    content = content.replace('{{DEPENDENCIES}}', dependencySection);\r\n    \r\n    // Format parallel groups\r\n    const parallelSection = this.formatParallelGroups(data.parallelGroups);\r\n    content = content.replace('{{PARALLEL_GROUPS}}', parallelSection);\r\n    \r\n    // Format validation checklist\r\n    const validationSection = this.formatValidationChecklist(data.tasks);\r\n    content = content.replace('{{VALIDATION_CHECKLIST}}', validationSection);\r\n    \r\n    return content;\r\n  }\r\n\r\n  private formatTaskSection(tasks: Task[]): string {\r\n    return tasks.map(task => {\r\n      const parallel = task.isParallel ? '[P] ' : '';\r\n      const prerequisites = task.prerequisites.length > 0 ? ` (after ${task.prerequisites.join(', ')})` : '';\r\n      return `- [ ] ${task.id} ${parallel}${task.description} in ${task.filePath}${prerequisites}`;\r\n    }).join('\\n');\r\n  }\r\n\r\n  private formatDependencies(dependencies: TaskDependency[]): string {\r\n    if (dependencies.length === 0) {\r\n      return 'No explicit dependencies - follow phase order';\r\n    }\r\n    \r\n    return dependencies.map(dep => {\r\n      return `- ${dep.taskId} depends on ${dep.dependsOn.join(', ')}: ${dep.reason}`;\r\n    }).join('\\n');\r\n  }\r\n\r\n  private formatParallelGroups(groups: ParallelGroup[]): string {\r\n    if (groups.length === 0) {\r\n      return 'No parallel execution groups identified';\r\n    }\r\n    \r\n    return groups.map(group => {\r\n      return `**${group.groupId}**: ${group.description}\\n` +\r\n             `Tasks: ${group.tasks.join(', ')}\\n`;\r\n    }).join('\\n');\r\n  }\r\n\r\n  private formatValidationChecklist(tasks: Task[]): string {\r\n    const contractTests = tasks.filter(t => t.type === 'test' && t.description.includes('contract'));\r\n    const entities = tasks.filter(t => t.type === 'implementation' && t.description.includes('model'));\r\n    const testsFirst = tasks.filter(t => t.type === 'test').length > 0;\r\n    \r\n    return `- [ ] All contracts have corresponding tests (${contractTests.length} found)\r\n- [ ] All entities have model tasks (${entities.length} found)  \r\n- [ ] All tests come before implementation (${testsFirst ? 'Yes' : 'No'})\r\n- [ ] Parallel tasks truly independent\r\n- [ ] Each task specifies exact file path\r\n- [ ] No task modifies same file as another [P] task`;\r\n  }\r\n\r\n  public async validateTasks(taskList: TaskList): Promise<{ valid: boolean; issues: string[] }> {\r\n    const issues: string[] = [];\r\n    \r\n    // Check TDD compliance\r\n    const testTasks = taskList.tasks.filter(t => t.type === 'test');\r\n    const implementationTasks = taskList.tasks.filter(t => t.type === 'implementation');\r\n    \r\n    if (testTasks.length === 0) {\r\n      issues.push('No test tasks found - TDD requires tests first');\r\n    }\r\n    \r\n    // Check parallel task file conflicts\r\n    const parallelTasks = taskList.tasks.filter(t => t.isParallel);\r\n    const fileGroups = new Map<string, Task[]>();\r\n    \r\n    parallelTasks.forEach(task => {\r\n      const file = task.filePath;\r\n      if (!fileGroups.has(file)) {\r\n        fileGroups.set(file, []);\r\n      }\r\n      fileGroups.get(file)!.push(task);\r\n    });\r\n    \r\n    fileGroups.forEach((tasks, file) => {\r\n      if (tasks.length > 1) {\r\n        issues.push(`File conflict: ${file} modified by parallel tasks ${tasks.map(t => t.id).join(', ')}`);\r\n      }\r\n    });\r\n    \r\n    // Check dependency cycles\r\n    const cycles = this.detectDependencyCycles(taskList.dependencies);\r\n    if (cycles.length > 0) {\r\n      issues.push(`Dependency cycles detected: ${cycles.join(', ')}`);\r\n    }\r\n    \r\n    return {\r\n      valid: issues.length === 0,\r\n      issues\r\n    };\r\n  }\r\n\r\n  private detectDependencyCycles(dependencies: TaskDependency[]): string[] {\r\n    const graph = new Map<string, string[]>();\r\n    const cycles: string[] = [];\r\n    \r\n    // Build adjacency list\r\n    dependencies.forEach(dep => {\r\n      dep.dependsOn.forEach(prereq => {\r\n        if (!graph.has(prereq)) {\r\n          graph.set(prereq, []);\r\n        }\r\n        graph.get(prereq)!.push(dep.taskId);\r\n      });\r\n    });\r\n    \r\n    // Simple cycle detection (would need more sophisticated algorithm for complex cases)\r\n    graph.forEach((dependents, task) => {\r\n      dependents.forEach(dependent => {\r\n        if (graph.has(dependent) && graph.get(dependent)!.includes(task)) {\r\n          cycles.push(`${task} ↔ ${dependent}`);\r\n        }\r\n      });\r\n    });\r\n    \r\n    return cycles;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\testing\\apiTester.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'TestResult' is defined but never used.","line":4,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"TestResult"},"fix":{"range":[80,92],"text":""},"desc":"Remove unused variable 'TestResult'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'BatchTestResult' is defined but never used.","line":4,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":52,"suggestions":[{"messageId":"removeVar","data":{"varName":"BatchTestResult"},"fix":{"range":[92,109],"text":""},"desc":"Remove unused variable 'BatchTestResult'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'VectorTestResult' is defined but never used.","line":4,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":4,"endColumn":70,"suggestions":[{"messageId":"removeVar","data":{"varName":"VectorTestResult"},"fix":{"range":[109,127],"text":""},"desc":"Remove unused variable 'VectorTestResult'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":6,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":17,"suggestions":[{"messageId":"removeVar","data":{"varName":"path"},"fix":{"range":[190,205],"text":""},"desc":"Remove unused variable 'path'."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":35,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":35,"endColumn":22,"suggestions":[{"fix":{"range":[1199,1275],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":39,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":39,"endColumn":20,"suggestions":[{"fix":{"range":[1337,1368],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":58,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":58,"endColumn":20,"suggestions":[{"fix":{"range":[1859,1890],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":74,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":74,"endColumn":18,"suggestions":[{"fix":{"range":[2301,2337],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":75,"column":37,"nodeType":"MemberExpression","messageId":"unexpected","endLine":75,"endColumn":48},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":78,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":78,"endColumn":18,"suggestions":[{"fix":{"range":[2510,2555],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":79,"column":31,"nodeType":"MemberExpression","messageId":"unexpected","endLine":79,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":81,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":81,"endColumn":18,"suggestions":[{"fix":{"range":[2635,2722],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2771,2774],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2771,2774],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":86,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":86,"endColumn":14,"suggestions":[{"fix":{"range":[2780,2849],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":89,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":89,"endColumn":18,"suggestions":[{"fix":{"range":[2913,2960],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3045,3048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3045,3048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":16,"suggestions":[{"fix":{"range":[3313,3363],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":110,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":110,"endColumn":16,"suggestions":[{"fix":{"range":[3379,3424],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3474,3477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3474,3477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":115,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":115,"endColumn":14,"suggestions":[{"fix":{"range":[3483,3558],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":118,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":118,"endColumn":18,"suggestions":[{"fix":{"range":[3622,3669],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":123,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":123,"endColumn":18,"suggestions":[{"fix":{"range":[3738,3793],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":134,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":134,"endColumn":18,"suggestions":[{"fix":{"range":[4001,4056],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4141,4144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4141,4144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":149,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":149,"endColumn":16,"suggestions":[{"fix":{"range":[4410,4460],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":151,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":151,"endColumn":16,"suggestions":[{"fix":{"range":[4476,4521],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4566,4569],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4566,4569],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":156,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":156,"endColumn":14,"suggestions":[{"fix":{"range":[4575,4643],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":159,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":159,"endColumn":18,"suggestions":[{"fix":{"range":[4707,4754],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4877,4880],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4877,4880],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":179,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":179,"endColumn":16,"suggestions":[{"fix":{"range":[5162,5212],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":181,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":181,"endColumn":16,"suggestions":[{"fix":{"range":[5228,5273],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5316,5319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5316,5319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":186,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":186,"endColumn":14,"suggestions":[{"fix":{"range":[5325,5381],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":198,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":198,"endColumn":16,"suggestions":[{"fix":{"range":[5672,5722],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":200,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":200,"endColumn":16,"suggestions":[{"fix":{"range":[5738,5783],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5873,5876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5873,5876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":213,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":213,"endColumn":18,"suggestions":[{"fix":{"range":[5955,5992],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":34,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport { ApiTesterCore, TestResult, BatchTestResult, VectorTestResult } from './apiTesterCore.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nconst program = new Command();\nconst tester = new ApiTesterCore();\n\nprogram.name('astraforge').description('AstraForge API Testing Interface').version('0.0.1');\n\n// LLM Testing Commands\nprogram\n  .command('test')\n  .description('Test LLM API functionality')\n  .requiredOption('--api <provider>', 'API provider (OpenAI, Anthropic, xAI, OpenRouter)')\n  .requiredOption('--key <key>', 'API key')\n  .option('--model <model>', 'Model to use', 'gpt-4')\n  .option('--prompt <prompt>', 'Test prompt')\n  .option('--file <file>', 'File containing prompts (one per line)')\n  .option('--output <file>', 'Output file for results')\n  .option('--workflow <idea>', 'Test workflow simulation')\n  .action(async options => {\n    try {\n      await tester.initialize();\n\n      if (options.workflow) {\n        await testWorkflow(options);\n      } else if (options.file) {\n        await testBatchFromFile(options);\n      } else if (options.prompt) {\n        await testSingle(options);\n      } else {\n        console.error('Error: Must provide either --prompt, --file, or --workflow');\n        process.exit(1);\n      }\n    } catch (error) {\n      console.error('Error:', error);\n      process.exit(1);\n    } finally {\n      await tester.cleanup();\n    }\n  });\n\n// Vector Testing Commands\nprogram\n  .command('vector')\n  .description('Test vector database queries')\n  .requiredOption('--query <query>', 'Query text')\n  .option('--topk <number>', 'Number of results to return', '5')\n  .option('--output <file>', 'Output file for results')\n  .action(async options => {\n    try {\n      await tester.initialize();\n      await testVector(options);\n    } catch (error) {\n      console.error('Error:', error);\n      process.exit(1);\n    } finally {\n      await tester.cleanup();\n    }\n  });\n\n// List Commands\nprogram\n  .command('list')\n  .description('List supported providers and models')\n  .option('--providers', 'List supported providers')\n  .option('--models <provider>', 'List models for a provider')\n  .action(options => {\n    if (options.providers) {\n      const providers = tester.getSupportedProviders();\n      console.log('Supported Providers:');\n      providers.forEach(provider => console.log(`  - ${provider}`));\n    } else if (options.models) {\n      const models = tester.getSupportedModels(options.models);\n      console.log(`Models for ${options.models}:`);\n      models.forEach(model => console.log(`  - ${model}`));\n    } else {\n      console.log('Use --providers to list providers or --models <provider> to list models');\n    }\n  });\n\nasync function testSingle(options: any) {\n  console.log(`Testing ${options.api} with model ${options.model}...`);\n\n  if (!tester.validateApiKey(options.api, options.key)) {\n    console.error('Error: Invalid API key format');\n    process.exit(1);\n  }\n\n  const result = await tester.testLLM(\n    options.api as any,\n    options.key,\n    options.model,\n    options.prompt\n  );\n\n  const output = {\n    type: 'single_test',\n    timestamp: new Date().toISOString(),\n    result,\n  };\n\n  if (options.output) {\n    fs.writeFileSync(options.output, JSON.stringify(output, null, 2));\n    console.log(`Results saved to ${options.output}`);\n  } else {\n    console.log(JSON.stringify(output, null, 2));\n  }\n}\n\nasync function testBatchFromFile(options: any) {\n  console.log(`Testing ${options.api} with prompts from ${options.file}...`);\n\n  if (!tester.validateApiKey(options.api, options.key)) {\n    console.error('Error: Invalid API key format');\n    process.exit(1);\n  }\n\n  if (!fs.existsSync(options.file)) {\n    console.error(`Error: File ${options.file} not found`);\n    process.exit(1);\n  }\n\n  const prompts = fs\n    .readFileSync(options.file, 'utf8')\n    .split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0);\n\n  if (prompts.length === 0) {\n    console.error('Error: No valid prompts found in file');\n    process.exit(1);\n  }\n\n  const result = await tester.testBatchLLM(options.api as any, options.key, options.model, prompts);\n\n  const output = {\n    type: 'batch_test',\n    timestamp: new Date().toISOString(),\n    file: options.file,\n    result,\n  };\n\n  if (options.output) {\n    fs.writeFileSync(options.output, JSON.stringify(output, null, 2));\n    console.log(`Results saved to ${options.output}`);\n  } else {\n    console.log(JSON.stringify(output, null, 2));\n  }\n}\n\nasync function testWorkflow(options: any) {\n  console.log(`Testing workflow simulation for: ${options.workflow}`);\n\n  if (!tester.validateApiKey(options.api, options.key)) {\n    console.error('Error: Invalid API key format');\n    process.exit(1);\n  }\n\n  const results = await tester.testWorkflowSimulation(\n    options.workflow,\n    options.api as any,\n    options.key,\n    options.model\n  );\n\n  const output = {\n    type: 'workflow_simulation',\n    timestamp: new Date().toISOString(),\n    idea: options.workflow,\n    results,\n  };\n\n  if (options.output) {\n    fs.writeFileSync(options.output, JSON.stringify(output, null, 2));\n    console.log(`Results saved to ${options.output}`);\n  } else {\n    console.log(JSON.stringify(output, null, 2));\n  }\n}\n\nasync function testVector(options: any) {\n  console.log(`Testing vector query: \"${options.query}\"`);\n\n  const result = await tester.testVectorQuery(options.query, parseInt(options.topk));\n\n  const output = {\n    type: 'vector_test',\n    timestamp: new Date().toISOString(),\n    result,\n  };\n\n  if (options.output) {\n    fs.writeFileSync(options.output, JSON.stringify(output, null, 2));\n    console.log(`Results saved to ${options.output}`);\n  } else {\n    console.log(JSON.stringify(output, null, 2));\n  }\n}\n\n// Error handling\nprogram.exitOverride();\n\ntry {\n  program.parse();\n} catch (err: any) {\n  if (err.code === 'commander.help') {\n    process.exit(0);\n  } else {\n    console.error('Error:', err.message);\n    process.exit(1);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\testing\\apiTesterCLI.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":6,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":17,"suggestions":[{"messageId":"removeVar","data":{"varName":"path"},"fix":{"range":[118,133],"text":""},"desc":"Remove unused variable 'path'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1492,1495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1492,1495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":265,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":265,"endColumn":22,"suggestions":[{"fix":{"range":[7302,7378],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":269,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":269,"endColumn":20,"suggestions":[{"fix":{"range":[7440,7471],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":283,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":283,"endColumn":18,"suggestions":[{"fix":{"range":[7836,7872],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":284,"column":37,"nodeType":"MemberExpression","messageId":"unexpected","endLine":284,"endColumn":48},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":287,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":287,"endColumn":18,"suggestions":[{"fix":{"range":[8045,8090],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":288,"column":31,"nodeType":"MemberExpression","messageId":"unexpected","endLine":288,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":290,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":290,"endColumn":18,"suggestions":[{"fix":{"range":[8170,8257],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8306,8309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8306,8309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":295,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":295,"endColumn":14,"suggestions":[{"fix":{"range":[8315,8384],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":298,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":298,"endColumn":18,"suggestions":[{"fix":{"range":[8448,8495],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8580,8583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8580,8583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":317,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":317,"endColumn":16,"suggestions":[{"fix":{"range":[8848,8898],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":319,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":319,"endColumn":16,"suggestions":[{"fix":{"range":[8914,8959],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":323,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":323,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9009,9012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9009,9012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":324,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":324,"endColumn":14,"suggestions":[{"fix":{"range":[9018,9093],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":327,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":327,"endColumn":18,"suggestions":[{"fix":{"range":[9157,9204],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":332,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":332,"endColumn":18,"suggestions":[{"fix":{"range":[9273,9328],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":343,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":343,"endColumn":18,"suggestions":[{"fix":{"range":[9536,9591],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":347,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":347,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9676,9679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9676,9679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":358,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":358,"endColumn":16,"suggestions":[{"fix":{"range":[9945,9995],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":360,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":360,"endColumn":16,"suggestions":[{"fix":{"range":[10011,10056],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":364,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10101,10104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10101,10104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":365,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":365,"endColumn":14,"suggestions":[{"fix":{"range":[10110,10178],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":368,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":368,"endColumn":18,"suggestions":[{"fix":{"range":[10242,10289],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":374,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":374,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10412,10415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10412,10415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":388,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":388,"endColumn":16,"suggestions":[{"fix":{"range":[10697,10747],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":390,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":390,"endColumn":16,"suggestions":[{"fix":{"range":[10763,10808],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":399,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10898,10901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10898,10901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":403,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":403,"endColumn":18,"suggestions":[{"fix":{"range":[10980,11017],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":30,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport { Command } from 'commander';\nimport axios from 'axios';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface TestResult {\n  success: boolean;\n  response?: string;\n  error?: string;\n  latency: number;\n  timestamp: number;\n  provider: string;\n  model?: string;\n}\n\ninterface BatchTestResult {\n  total: number;\n  successful: number;\n  failed: number;\n  results: TestResult[];\n  averageLatency: number;\n  totalTime: number;\n}\n\nclass ApiTesterCLI {\n  async testLLM(\n    provider: 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter',\n    apiKey: string,\n    model: string,\n    prompt: string\n  ): Promise<TestResult> {\n    const startTime = Date.now();\n\n    try {\n      let response: string;\n\n      switch (provider) {\n        case 'OpenAI':\n          response = await this.queryOpenAI(apiKey, model, prompt);\n          break;\n        case 'Anthropic':\n          response = await this.queryAnthropic(apiKey, model, prompt);\n          break;\n        case 'xAI':\n          response = await this.queryXAI(apiKey, model, prompt);\n          break;\n        case 'OpenRouter':\n          response = await this.queryOpenRouter(apiKey, model, prompt);\n          break;\n        default:\n          throw new Error(`Unsupported provider: ${provider}`);\n      }\n\n      const latency = Date.now() - startTime;\n\n      return {\n        success: true,\n        response,\n        latency,\n        timestamp: Date.now(),\n        provider,\n        model,\n      };\n    } catch (error: any) {\n      const latency = Date.now() - startTime;\n      return {\n        success: false,\n        error: error.message,\n        latency,\n        timestamp: Date.now(),\n        provider,\n        model,\n      };\n    }\n  }\n\n  private async queryOpenAI(apiKey: string, model: string, prompt: string): Promise<string> {\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model,\n        messages: [{ role: 'user', content: prompt }],\n        max_tokens: 1000,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n    return response.data.choices[0].message.content;\n  }\n\n  private async queryAnthropic(apiKey: string, model: string, prompt: string): Promise<string> {\n    const response = await axios.post(\n      'https://api.anthropic.com/v1/messages',\n      {\n        model,\n        max_tokens: 1000,\n        messages: [{ role: 'user', content: prompt }],\n      },\n      {\n        headers: {\n          'x-api-key': apiKey,\n          'Content-Type': 'application/json',\n          'anthropic-version': '2023-06-01',\n        },\n      }\n    );\n    return response.data.content[0].text;\n  }\n\n  private async queryXAI(apiKey: string, model: string, prompt: string): Promise<string> {\n    const response = await axios.post(\n      'https://api.x.ai/v1/chat/completions',\n      {\n        model,\n        messages: [{ role: 'user', content: prompt }],\n        max_tokens: 1000,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n    return response.data.choices[0].message.content;\n  }\n\n  private async queryOpenRouter(apiKey: string, model: string, prompt: string): Promise<string> {\n    const response = await axios.post(\n      'https://openrouter.ai/api/v1/chat/completions',\n      {\n        model,\n        messages: [{ role: 'user', content: prompt }],\n        max_tokens: 1000,\n      },\n      {\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n    return response.data.choices[0].message.content;\n  }\n\n  async testBatchLLM(\n    provider: 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter',\n    apiKey: string,\n    model: string,\n    prompts: string[]\n  ): Promise<BatchTestResult> {\n    const startTime = Date.now();\n\n    // Process prompts in parallel for better performance\n    const testPromises = prompts.map(async (prompt, index) => {\n      const result = await this.testLLM(provider, apiKey, model, prompt);\n      return { ...result, index };\n    });\n\n    const batchResults = await Promise.all(testPromises);\n    const totalTime = Date.now() - startTime;\n\n    const successful = batchResults.filter(r => r.success).length;\n    const failed = batchResults.length - successful;\n    const averageLatency =\n      batchResults.reduce((sum, r) => sum + r.latency, 0) / batchResults.length;\n\n    return {\n      total: batchResults.length,\n      successful,\n      failed,\n      results: batchResults,\n      averageLatency,\n      totalTime,\n    };\n  }\n\n  async testWorkflowSimulation(\n    idea: string,\n    provider: 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter',\n    apiKey: string,\n    model: string\n  ): Promise<TestResult[]> {\n    const results: TestResult[] = [];\n\n    // Simulate the workflow phases\n    const phases = ['Planning', 'Prototyping', 'Testing', 'Deployment'];\n\n    for (const phase of phases) {\n      const prompt = `Execute ${phase} for project: ${idea}. Provide a brief summary.`;\n      const result = await this.testLLM(provider, apiKey, model, prompt);\n      results.push({\n        ...result,\n        response: `Phase: ${phase}\\n${result.response || result.error}`,\n      });\n    }\n\n    return results;\n  }\n\n  validateApiKey(provider: string, apiKey: string): boolean {\n    if (!apiKey || apiKey.trim().length === 0) {\n      return false;\n    }\n\n    // Basic validation patterns\n    const patterns = {\n      OpenAI: /^sk-[a-zA-Z0-9]{32,}$/,\n      Anthropic: /^sk-ant-[a-zA-Z0-9]{32,}$/,\n      xAI: /^xai-[a-zA-Z0-9]{32,}$/,\n      OpenRouter: /^sk-or-[a-zA-Z0-9]{32,}$/,\n    };\n\n    const pattern = patterns[provider as keyof typeof patterns];\n    return pattern ? pattern.test(apiKey) : apiKey.length > 10;\n  }\n\n  getSupportedProviders(): string[] {\n    return ['OpenAI', 'Anthropic', 'xAI', 'OpenRouter'];\n  }\n\n  getSupportedModels(provider: string): string[] {\n    const models = {\n      OpenAI: ['gpt-4', 'gpt-4-turbo', 'gpt-3.5-turbo'],\n      Anthropic: ['claude-3-opus', 'claude-3-sonnet', 'claude-3-haiku'],\n      xAI: ['grok-beta', 'grok-pro'],\n      OpenRouter: ['gpt-4', 'gpt-3.5-turbo', 'claude-3-opus', 'claude-3-sonnet'],\n    };\n\n    return models[provider as keyof typeof models] || [];\n  }\n}\n\nconst program = new Command();\nconst tester = new ApiTesterCLI();\n\nprogram.name('astraforge').description('AstraForge API Testing Interface').version('0.0.1');\n\n// LLM Testing Commands\nprogram\n  .command('test')\n  .description('Test LLM API functionality')\n  .requiredOption('--api <provider>', 'API provider (OpenAI, Anthropic, xAI, OpenRouter)')\n  .requiredOption('--key <key>', 'API key')\n  .option('--model <model>', 'Model to use', 'gpt-4')\n  .option('--prompt <prompt>', 'Test prompt')\n  .option('--file <file>', 'File containing prompts (one per line)')\n  .option('--output <file>', 'Output file for results')\n  .option('--workflow <idea>', 'Test workflow simulation')\n  .action(async options => {\n    try {\n      if (options.workflow) {\n        await testWorkflow(options);\n      } else if (options.file) {\n        await testBatchFromFile(options);\n      } else if (options.prompt) {\n        await testSingle(options);\n      } else {\n        console.error('Error: Must provide either --prompt, --file, or --workflow');\n        process.exit(1);\n      }\n    } catch (error) {\n      console.error('Error:', error);\n      process.exit(1);\n    }\n  });\n\n// List Commands\nprogram\n  .command('list')\n  .description('List supported providers and models')\n  .option('--providers', 'List supported providers')\n  .option('--models <provider>', 'List models for a provider')\n  .action(options => {\n    if (options.providers) {\n      const providers = tester.getSupportedProviders();\n      console.log('Supported Providers:');\n      providers.forEach(provider => console.log(`  - ${provider}`));\n    } else if (options.models) {\n      const models = tester.getSupportedModels(options.models);\n      console.log(`Models for ${options.models}:`);\n      models.forEach(model => console.log(`  - ${model}`));\n    } else {\n      console.log('Use --providers to list providers or --models <provider> to list models');\n    }\n  });\n\nasync function testSingle(options: any) {\n  console.log(`Testing ${options.api} with model ${options.model}...`);\n\n  if (!tester.validateApiKey(options.api, options.key)) {\n    console.error('Error: Invalid API key format');\n    process.exit(1);\n  }\n\n  const result = await tester.testLLM(\n    options.api as any,\n    options.key,\n    options.model,\n    options.prompt\n  );\n\n  const output = {\n    type: 'single_test',\n    timestamp: new Date().toISOString(),\n    result,\n  };\n\n  if (options.output) {\n    fs.writeFileSync(options.output, JSON.stringify(output, null, 2));\n    console.log(`Results saved to ${options.output}`);\n  } else {\n    console.log(JSON.stringify(output, null, 2));\n  }\n}\n\nasync function testBatchFromFile(options: any) {\n  console.log(`Testing ${options.api} with prompts from ${options.file}...`);\n\n  if (!tester.validateApiKey(options.api, options.key)) {\n    console.error('Error: Invalid API key format');\n    process.exit(1);\n  }\n\n  if (!fs.existsSync(options.file)) {\n    console.error(`Error: File ${options.file} not found`);\n    process.exit(1);\n  }\n\n  const prompts = fs\n    .readFileSync(options.file, 'utf8')\n    .split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0);\n\n  if (prompts.length === 0) {\n    console.error('Error: No valid prompts found in file');\n    process.exit(1);\n  }\n\n  const result = await tester.testBatchLLM(options.api as any, options.key, options.model, prompts);\n\n  const output = {\n    type: 'batch_test',\n    timestamp: new Date().toISOString(),\n    file: options.file,\n    result,\n  };\n\n  if (options.output) {\n    fs.writeFileSync(options.output, JSON.stringify(output, null, 2));\n    console.log(`Results saved to ${options.output}`);\n  } else {\n    console.log(JSON.stringify(output, null, 2));\n  }\n}\n\nasync function testWorkflow(options: any) {\n  console.log(`Testing workflow simulation for: ${options.workflow}`);\n\n  if (!tester.validateApiKey(options.api, options.key)) {\n    console.error('Error: Invalid API key format');\n    process.exit(1);\n  }\n\n  const results = await tester.testWorkflowSimulation(\n    options.workflow,\n    options.api as any,\n    options.key,\n    options.model\n  );\n\n  const output = {\n    type: 'workflow_simulation',\n    timestamp: new Date().toISOString(),\n    idea: options.workflow,\n    results,\n  };\n\n  if (options.output) {\n    fs.writeFileSync(options.output, JSON.stringify(output, null, 2));\n    console.log(`Results saved to ${options.output}`);\n  } else {\n    console.log(JSON.stringify(output, null, 2));\n  }\n}\n\n// Error handling\nprogram.exitOverride();\n\ntry {\n  program.parse();\n} catch (err: any) {\n  if (err.code === 'commander.help') {\n    process.exit(0);\n  } else {\n    console.error('Error:', err.message);\n    process.exit(1);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\testing\\apiTesterCore.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'vscode' is defined but never used.","line":3,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":19,"suggestions":[{"messageId":"removeVar","data":{"varName":"vscode"},"fix":{"range":[104,121],"text":""},"desc":"Remove unused variable 'vscode'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[598,601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[598,601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":50,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":50,"endColumn":19,"suggestions":[{"fix":{"range":[1029,1096],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1557,1560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1557,1560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1864,1867],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1864,1867],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'results' is assigned a value but never used.","line":105,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":105,"endColumn":32,"suggestions":[{"messageId":"removeVar","data":{"varName":"results"},"fix":{"range":[2301,2334],"text":""},"desc":"Remove unused variable 'results'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":150,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":150,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3625,3628],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3625,3628],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":220,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":220,"endColumn":19,"suggestions":[{"fix":{"range":[5567,5605],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { LLMManager } from '../llm/llmManager.js';\nimport { VectorDB } from '../db/vectorDB.js';\nimport * as vscode from 'vscode';\n\nexport interface TestResult {\n  success: boolean;\n  response?: string;\n  error?: string;\n  latency: number;\n  timestamp: number;\n  provider: string;\n  model?: string;\n}\n\nexport interface BatchTestResult {\n  total: number;\n  successful: number;\n  failed: number;\n  results: TestResult[];\n  averageLatency: number;\n  totalTime: number;\n}\n\nexport interface VectorTestResult {\n  success: boolean;\n  results: Array<{\n    id: string;\n    similarity: number;\n    metadata: any;\n  }>;\n  query: string;\n  latency: number;\n}\n\nexport class ApiTesterCore {\n  private llmManager: LLMManager;\n  private vectorDB: VectorDB;\n  private testMode: boolean = false;\n\n  constructor() {\n    this.llmManager = new LLMManager();\n    this.vectorDB = new VectorDB(process.cwd());\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      await this.vectorDB.init();\n      this.testMode = true;\n    } catch (error) {\n      console.warn('Failed to initialize vector DB for testing:', error);\n    }\n  }\n\n  async testLLM(\n    provider: 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter',\n    apiKey: string,\n    model: string,\n    prompt: string\n  ): Promise<TestResult> {\n    const startTime = Date.now();\n\n    try {\n      // Configure LLM manager for testing\n      const testConfig = {\n        provider,\n        key: apiKey,\n        model,\n        role: 'primary' as const,\n      };\n\n      // Temporarily set the panel for testing\n      (this.llmManager as any).panel = [testConfig];\n\n      const response = await this.llmManager.queryLLM(0, prompt);\n      const latency = Date.now() - startTime;\n\n      return {\n        success: true,\n        response,\n        latency,\n        timestamp: Date.now(),\n        provider,\n        model,\n      };\n    } catch (error: any) {\n      const latency = Date.now() - startTime;\n      return {\n        success: false,\n        error: error.message,\n        latency,\n        timestamp: Date.now(),\n        provider,\n        model,\n      };\n    }\n  }\n\n  async testBatchLLM(\n    provider: 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter',\n    apiKey: string,\n    model: string,\n    prompts: string[]\n  ): Promise<BatchTestResult> {\n    const startTime = Date.now();\n    const results: TestResult[] = [];\n\n    // Process prompts in parallel for better performance\n    const testPromises = prompts.map(async (prompt, index) => {\n      const result = await this.testLLM(provider, apiKey, model, prompt);\n      return { ...result, index };\n    });\n\n    const batchResults = await Promise.all(testPromises);\n    const totalTime = Date.now() - startTime;\n\n    const successful = batchResults.filter(r => r.success).length;\n    const failed = batchResults.length - successful;\n    const averageLatency =\n      batchResults.reduce((sum, r) => sum + r.latency, 0) / batchResults.length;\n\n    return {\n      total: batchResults.length,\n      successful,\n      failed,\n      results: batchResults,\n      averageLatency,\n      totalTime,\n    };\n  }\n\n  async testVectorQuery(query: string, topK: number = 5): Promise<VectorTestResult> {\n    const startTime = Date.now();\n\n    try {\n      const embedding = await this.vectorDB.getEmbedding(query);\n      const results = await this.vectorDB.queryEmbedding(embedding, topK);\n\n      const latency = Date.now() - startTime;\n\n      return {\n        success: true,\n        results: results.map(r => ({\n          id: r.id,\n          similarity: r.similarity,\n          metadata: r.metadata,\n        })),\n        query,\n        latency,\n      };\n    } catch (error: any) {\n      const latency = Date.now() - startTime;\n      return {\n        success: false,\n        results: [],\n        query,\n        latency,\n      };\n    }\n  }\n\n  async testWorkflowSimulation(\n    idea: string,\n    provider: 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter',\n    apiKey: string,\n    model: string\n  ): Promise<TestResult[]> {\n    const results: TestResult[] = [];\n\n    // Simulate the workflow phases\n    const phases = ['Planning', 'Prototyping', 'Testing', 'Deployment'];\n\n    for (const phase of phases) {\n      const prompt = `Execute ${phase} for project: ${idea}. Provide a brief summary.`;\n      const result = await this.testLLM(provider, apiKey, model, prompt);\n      results.push({\n        ...result,\n        response: `Phase: ${phase}\\n${result.response || result.error}`,\n      });\n    }\n\n    return results;\n  }\n\n  validateApiKey(provider: string, apiKey: string): boolean {\n    if (!apiKey || apiKey.trim().length === 0) {\n      return false;\n    }\n\n    // Basic validation patterns\n    const patterns = {\n      OpenAI: /^sk-[a-zA-Z0-9]{32,}$/,\n      Anthropic: /^sk-ant-[a-zA-Z0-9]{32,}$/,\n      xAI: /^xai-[a-zA-Z0-9]{32,}$/,\n      OpenRouter: /^sk-or-[a-zA-Z0-9]{32,}$/,\n    };\n\n    const pattern = patterns[provider as keyof typeof patterns];\n    return pattern ? pattern.test(apiKey) : apiKey.length > 10;\n  }\n\n  getSupportedProviders(): string[] {\n    return ['OpenAI', 'Anthropic', 'xAI', 'OpenRouter'];\n  }\n\n  getSupportedModels(provider: string): string[] {\n    const models = {\n      OpenAI: ['gpt-4', 'gpt-4-turbo', 'gpt-3.5-turbo'],\n      Anthropic: ['claude-3-opus', 'claude-3-sonnet', 'claude-3-haiku'],\n      xAI: ['grok-beta', 'grok-pro'],\n      OpenRouter: ['gpt-4', 'gpt-3.5-turbo', 'claude-3-opus', 'claude-3-sonnet'],\n    };\n\n    return models[provider as keyof typeof models] || [];\n  }\n\n  async cleanup(): Promise<void> {\n    try {\n      this.vectorDB.close();\n    } catch (error) {\n      console.warn('Cleanup error:', error);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\testing\\apiTesterProvider.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'TestResult' is defined but never used.","line":2,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"TestResult"},"fix":{"range":[56,68],"text":""},"desc":"Remove unused variable 'TestResult'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'BatchTestResult' is defined but never used.","line":2,"column":37,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":52,"suggestions":[{"messageId":"removeVar","data":{"varName":"BatchTestResult"},"fix":{"range":[68,85],"text":""},"desc":"Remove unused variable 'BatchTestResult'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'VectorTestResult' is defined but never used.","line":2,"column":54,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":70,"suggestions":[{"messageId":"removeVar","data":{"varName":"VectorTestResult"},"fix":{"range":[85,103],"text":""},"desc":"Remove unused variable 'VectorTestResult'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_extensionUri' is defined but never used.","line":9,"column":32,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":57,"suggestions":[{"messageId":"removeVar","data":{"varName":"_extensionUri"},"fix":{"range":[362,387],"text":""},"desc":"Remove unused variable '_extensionUri'."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'resolveWebviewView' has too many lines (65). Maximum allowed is 50.","line":13,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":77,"endColumn":4},{"ruleId":"no-unused-vars","severity":2,"message":"'_context' is defined but never used.","line":15,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":47,"suggestions":[{"messageId":"removeVar","data":{"varName":"_context"},"fix":{"range":[500,548],"text":""},"desc":"Remove unused variable '_context'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'_token' is defined but never used.","line":16,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":16,"endColumn":37,"suggestions":[{"messageId":"removeVar","data":{"varName":"_token"},"fix":{"range":[548,586],"text":""},"desc":"Remove unused variable '_token'."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":53,"column":13,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":53,"endColumn":82,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1555,1728],"text":"{ const isValid = this._tester.validateApiKey(data.provider, data.key);\n            this._sendMessage('keyValidated', { isValid, provider: data.provider });\n            break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":58,"column":13,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":58,"endColumn":68,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1773,1910],"text":"{ const providers = this._tester.getSupportedProviders();\n            this._sendMessage('providersList', { providers });\n            break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":63,"column":13,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":63,"endColumn":75,"suggestions":[{"messageId":"addBrackets","fix":{"range":[1952,2115],"text":"{ const models = this._tester.getSupportedModels(data.provider);\n            this._sendMessage('modelsList', { models, provider: data.provider });\n            break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":68,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":68,"endColumn":25,"suggestions":[{"fix":{"range":[2148,2197],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2230,2233],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2230,2233],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2405,2408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2405,2408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2653,2656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2653,2656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2940,2943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2940,2943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3177,3180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3177,3180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3479,3482],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3479,3482],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Method '_getHtmlForWebview' has too many lines (138). Maximum allowed is 50.","line":131,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":268,"endColumn":4}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as vscode from 'vscode';\nimport { ApiTesterCore, TestResult, BatchTestResult, VectorTestResult } from './apiTesterCore';\n\nexport class ApiTesterProvider implements vscode.WebviewViewProvider {\n  public static readonly viewType = 'astraforge.apiTester';\n  private _view?: vscode.Webview;\n  private _tester: ApiTesterCore;\n\n  constructor(private readonly _extensionUri: vscode.Uri) {\n    this._tester = new ApiTesterCore();\n  }\n\n  public resolveWebviewView(\n    webviewView: vscode.WebviewView,\n    _context: vscode.WebviewViewResolveContext,\n    _token: vscode.CancellationToken\n  ) {\n    this._view = webviewView.webview;\n\n    webviewView.webview.options = {\n      enableScripts: true,\n      localResourceRoots: [this._extensionUri],\n    };\n\n    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);\n\n    // Handle messages from the webview\n    webviewView.webview.onDidReceiveMessage(async data => {\n      try {\n        switch (data.type) {\n          case 'initialize':\n            await this._tester.initialize();\n            this._sendMessage('initialized', { success: true });\n            break;\n\n          case 'testLLM':\n            await this._handleLLMTest(data);\n            break;\n\n          case 'testBatch':\n            await this._handleBatchTest(data);\n            break;\n\n          case 'testVector':\n            await this._handleVectorTest(data);\n            break;\n\n          case 'testWorkflow':\n            await this._handleWorkflowTest(data);\n            break;\n\n          case 'validateKey':\n            const isValid = this._tester.validateApiKey(data.provider, data.key);\n            this._sendMessage('keyValidated', { isValid, provider: data.provider });\n            break;\n\n          case 'getProviders':\n            const providers = this._tester.getSupportedProviders();\n            this._sendMessage('providersList', { providers });\n            break;\n\n          case 'getModels':\n            const models = this._tester.getSupportedModels(data.provider);\n            this._sendMessage('modelsList', { models, provider: data.provider });\n            break;\n\n          default:\n            console.warn('Unknown message type:', data.type);\n        }\n      } catch (error: any) {\n        this._sendMessage('error', {\n          message: error.message,\n          type: data.type,\n        });\n      }\n    });\n  }\n\n  private async _handleLLMTest(data: any) {\n    const result = await this._tester.testLLM(data.provider, data.apiKey, data.model, data.prompt);\n\n    this._sendMessage('llmTestResult', {\n      result,\n      requestId: data.requestId,\n    });\n  }\n\n  private async _handleBatchTest(data: any) {\n    const result = await this._tester.testBatchLLM(\n      data.provider,\n      data.apiKey,\n      data.model,\n      data.prompts\n    );\n\n    this._sendMessage('batchTestResult', {\n      result,\n      requestId: data.requestId,\n    });\n  }\n\n  private async _handleVectorTest(data: any) {\n    const result = await this._tester.testVectorQuery(data.query, data.topK || 5);\n\n    this._sendMessage('vectorTestResult', {\n      result,\n      requestId: data.requestId,\n    });\n  }\n\n  private async _handleWorkflowTest(data: any) {\n    const results = await this._tester.testWorkflowSimulation(\n      data.idea,\n      data.provider,\n      data.apiKey,\n      data.model\n    );\n\n    this._sendMessage('workflowTestResult', {\n      results,\n      requestId: data.requestId,\n    });\n  }\n\n  private _sendMessage(type: string, data: any) {\n    if (this._view) {\n      this._view.postMessage({ type, data });\n    }\n  }\n\n  private _getHtmlForWebview(webview: vscode.Webview) {\n    const scriptUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'apiTester.js')\n    );\n    const styleUri = webview.asWebviewUri(\n      vscode.Uri.joinPath(this._extensionUri, 'media', 'styles.css')\n    );\n\n    return `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>AstraForge API Tester</title>\n  <link href=\"${styleUri}\" rel=\"stylesheet\">\n  <style>\n    .api-tester {\n      padding: 16px;\n      font-family: var(--vscode-font-family);\n      color: var(--vscode-foreground);\n    }\n    .form-group {\n      margin-bottom: 12px;\n    }\n    .form-group label {\n      display: block;\n      margin-bottom: 4px;\n      font-weight: 500;\n    }\n    .form-group input, .form-group select, .form-group textarea {\n      width: 100%;\n      padding: 8px;\n      border: 1px solid var(--vscode-input-border);\n      background: var(--vscode-input-background);\n      color: var(--vscode-input-foreground);\n      border-radius: 4px;\n    }\n    .form-group textarea {\n      min-height: 80px;\n      resize: vertical;\n    }\n    .button-group {\n      display: flex;\n      gap: 8px;\n      margin: 16px 0;\n    }\n    .btn {\n      padding: 8px 16px;\n      border: none;\n      border-radius: 4px;\n      cursor: pointer;\n      font-size: 12px;\n    }\n    .btn-primary {\n      background: var(--vscode-button-background);\n      color: var(--vscode-button-foreground);\n    }\n    .btn-secondary {\n      background: var(--vscode-button-secondaryBackground);\n      color: var(--vscode-button-secondaryForeground);\n    }\n    .results {\n      margin-top: 16px;\n      padding: 12px;\n      background: var(--vscode-textBlockQuote-background);\n      border-radius: 4px;\n      max-height: 300px;\n      overflow-y: auto;\n    }\n    .result-item {\n      margin-bottom: 8px;\n      padding: 8px;\n      background: var(--vscode-editor-background);\n      border-radius: 4px;\n    }\n    .status-success {\n      color: var(--vscode-testing-iconPassed);\n    }\n    .status-error {\n      color: var(--vscode-testing-iconFailed);\n    }\n    .loading {\n      opacity: 0.6;\n      pointer-events: none;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"api-tester\">\n    <h2>AstraForge API Tester</h2>\n    \n    <div class=\"form-group\">\n      <label for=\"provider\">API Provider:</label>\n      <select id=\"provider\">\n        <option value=\"OpenAI\">OpenAI</option>\n        <option value=\"Anthropic\">Anthropic</option>\n        <option value=\"xAI\">xAI</option>\n        <option value=\"OpenRouter\">OpenRouter</option>\n      </select>\n    </div>\n\n    <div class=\"form-group\">\n      <label for=\"apiKey\">API Key:</label>\n      <input type=\"password\" id=\"apiKey\" placeholder=\"Enter your API key\">\n      <button class=\"btn btn-secondary\" onclick=\"validateKey()\">Validate Key</button>\n    </div>\n\n    <div class=\"form-group\">\n      <label for=\"model\">Model:</label>\n      <select id=\"model\">\n        <option value=\"gpt-4\">gpt-4</option>\n        <option value=\"gpt-4-turbo\">gpt-4-turbo</option>\n        <option value=\"gpt-3.5-turbo\">gpt-3.5-turbo</option>\n      </select>\n    </div>\n\n    <div class=\"form-group\">\n      <label for=\"prompt\">Test Prompt:</label>\n      <textarea id=\"prompt\" placeholder=\"Enter your test prompt here...\"></textarea>\n    </div>\n\n    <div class=\"button-group\">\n      <button class=\"btn btn-primary\" onclick=\"testLLM()\">Test LLM</button>\n      <button class=\"btn btn-secondary\" onclick=\"testVector()\">Test Vector</button>\n      <button class=\"btn btn-secondary\" onclick=\"testWorkflow()\">Test Workflow</button>\n      <button class=\"btn btn-secondary\" onclick=\"clearResults()\">Clear</button>\n    </div>\n\n    <div id=\"results\" class=\"results\" style=\"display: none;\">\n      <h3>Results:</h3>\n      <div id=\"resultsContent\"></div>\n    </div>\n  </div>\n\n  <script src=\"${scriptUri}\"></script>\n</body>\n</html>`;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\utils\\envLoader.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'projectRoot' is assigned a value but never used.","line":61,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":61,"endColumn":42,"suggestions":[{"messageId":"removeVar","data":{"varName":"projectRoot"},"fix":{"range":[1550,1569],"text":""},"desc":"Remove unused variable 'projectRoot'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Environment variable loader utility for AstraForge API Tester\r\n */\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\nimport { logger } from './logger';\r\n\r\nexport interface EnvConfig {\r\n  // API Keys\r\n  OPENROUTER_API_KEY?: string;\r\n  OPENAI_API_KEY?: string;\r\n  ANTHROPIC_API_KEY?: string;\r\n  XAI_API_KEY?: string;\r\n  HUGGINGFACE_API_TOKEN?: string;\r\n  \r\n  // Model Configuration\r\n  OPENROUTER_MODELS_TO_USE?: string;\r\n  \r\n  // AstraForge Configuration\r\n  DEFAULT_LLM_PROVIDER?: string;\r\n  AUTO_COMMIT_ENABLED?: string;\r\n  VECTOR_DB_PATH?: string;\r\n  DEBUG_MODE?: string;\r\n  \r\n  // Spec-Driven Development\r\n  ENFORCE_CONSTITUTION?: string;\r\n  MIN_TEST_COVERAGE?: string;\r\n  ENABLE_PARALLEL_TASKS?: string;\r\n  \r\n  // Security Settings\r\n  USE_SECURE_STORAGE?: string;\r\n  API_TIMEOUT?: string;\r\n  MAX_TOKENS_PER_REQUEST?: string;\r\n  \r\n  // Usage and Monitoring\r\n  TRACK_API_USAGE?: string;\r\n  DAILY_BUDGET_LIMIT?: string;\r\n  ENABLE_PERFORMANCE_MONITORING?: string;\r\n  \r\n  // Collaboration Server\r\n  ENABLE_COLLABORATION_SERVER?: string;\r\n  COLLABORATION_SERVER_PORT?: string;\r\n  \r\n  // Development Preferences\r\n  DEFAULT_LANGUAGE?: string;\r\n  DEFAULT_TESTING_FRAMEWORK?: string;\r\n  DEFAULT_PROJECT_TYPE?: string;\r\n  AUTO_FORMAT_CODE?: string;\r\n  AUTO_ORGANIZE_IMPORTS?: string;\r\n  \r\n  // UI Preferences\r\n  SHOW_INLINE_SUGGESTIONS?: string;\r\n  ENABLE_SYNTAX_HIGHLIGHTING?: string;\r\n  CODE_THEME?: string;\r\n  SHOW_PROGRESS_NOTIFICATIONS?: string;\r\n}\r\n\r\nexport class EnvLoader {\r\n  private config: EnvConfig = {};\r\n\r\n  constructor(private projectRoot: string = process.cwd()) {\r\n    this.loadEnvFile();\r\n  }\r\n\r\n  private loadEnvFile(): void {\r\n    const envPath = path.join(this.projectRoot, '.env');\r\n    \r\n    if (!fs.existsSync(envPath)) {\r\n      logger.warn('No .env file found. Using system environment variables only.');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const envContent = fs.readFileSync(envPath, 'utf8');\r\n      const lines = envContent.split('\\n');\r\n\r\n      for (const line of lines) {\r\n        const trimmedLine = line.trim();\r\n        \r\n        // Skip empty lines and comments\r\n        if (!trimmedLine || trimmedLine.startsWith('#')) {\r\n          continue;\r\n        }\r\n\r\n        const [key, ...valueParts] = trimmedLine.split('=');\r\n        if (key && valueParts.length > 0) {\r\n          const value = valueParts.join('=').trim();\r\n          this.config[key.trim() as keyof EnvConfig] = value;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      logger.error('Error reading .env file:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get environment variable with fallback to system env\r\n   */\r\n  get(key: keyof EnvConfig): string | undefined {\r\n    return this.config[key] || process.env[key];\r\n  }\r\n\r\n  /**\r\n   * Get OpenRouter API key\r\n   */\r\n  getOpenRouterApiKey(): string | undefined {\r\n    return this.get('OPENROUTER_API_KEY');\r\n  }\r\n\r\n  /**\r\n   * Get OpenRouter models as array\r\n   */\r\n  getOpenRouterModels(): string[] {\r\n    const modelsString = this.get('OPENROUTER_MODELS_TO_USE');\r\n    if (!modelsString) {\r\n      return [];\r\n    }\r\n\r\n    return modelsString\r\n      .split(',')\r\n      .map(model => model.trim())\r\n      .filter(model => model.length > 0);\r\n  }\r\n\r\n  /**\r\n   * Get configuration for 3-LLM panel based on your env\r\n   */\r\n  getLLMPanelConfig(): Array<{\r\n    provider: 'OpenAI' | 'Anthropic' | 'xAI' | 'OpenRouter';\r\n    apiKey: string;\r\n    model: string;\r\n    role: string;\r\n  }> {\r\n    const apiKey = this.getOpenRouterApiKey();\r\n    const models = this.getOpenRouterModels();\r\n\r\n    if (!apiKey) {\r\n      throw new Error('Missing API key in .env file. Please ensure OPENROUTER_API_KEY is set.');\r\n    }\r\n    \r\n    if (models.length < 3) {\r\n      throw new Error(`Insufficient models in .env file. Found ${models.length}, need 3. Please check OPENROUTER_MODELS_TO_USE format.`);\r\n    }\r\n\r\n    return [\r\n      {\r\n        provider: 'OpenRouter' as const,\r\n        apiKey,\r\n        model: models[0], // x-ai/grok-4\r\n        role: 'concept'\r\n      },\r\n      {\r\n        provider: 'OpenRouter' as const, \r\n        apiKey,\r\n        model: models[1], // google/gemini-2.5-pro\r\n        role: 'development'\r\n      },\r\n      {\r\n        provider: 'OpenRouter' as const,\r\n        apiKey,\r\n        model: models[2], // anthropic/claude-sonnet-4\r\n        role: 'coding'\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Validate that all required environment variables are present\r\n   */\r\n  validate(): { valid: boolean; missing: string[] } {\r\n    const required = ['OPENROUTER_API_KEY', 'OPENROUTER_MODELS_TO_USE'];\r\n    const missing: string[] = [];\r\n\r\n    for (const key of required) {\r\n      if (!this.get(key as keyof EnvConfig)) {\r\n        missing.push(key);\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: missing.length === 0,\r\n      missing\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get all loaded configuration\r\n   */\r\n  getConfig(): EnvConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Get boolean value with default\r\n   */\r\n  getBoolean(key: keyof EnvConfig, defaultValue: boolean = false): boolean {\r\n    const value = this.get(key);\r\n    if (!value) return defaultValue;\r\n    return value.toLowerCase() === 'true';\r\n  }\r\n\r\n  /**\r\n   * Get number value with default\r\n   */\r\n  getNumber(key: keyof EnvConfig, defaultValue: number = 0): number {\r\n    const value = this.get(key);\r\n    if (!value) return defaultValue;\r\n    const parsed = parseInt(value, 10);\r\n    return isNaN(parsed) ? defaultValue : parsed;\r\n  }\r\n\r\n  /**\r\n   * Get API key for any provider\r\n   */\r\n  getApiKey(provider: string): string | undefined {\r\n    switch (provider.toLowerCase()) {\r\n      case 'openrouter':\r\n        return this.get('OPENROUTER_API_KEY');\r\n      case 'openai':\r\n        return this.get('OPENAI_API_KEY');\r\n      case 'anthropic':\r\n        return this.get('ANTHROPIC_API_KEY');\r\n      case 'xai':\r\n        return this.get('XAI_API_KEY');\r\n      default:\r\n        return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get default LLM provider\r\n   */\r\n  getDefaultProvider(): string {\r\n    return this.get('DEFAULT_LLM_PROVIDER') || 'openrouter';\r\n  }\r\n\r\n  /**\r\n   * Check if debug mode is enabled\r\n   */\r\n  isDebugMode(): boolean {\r\n    return this.getBoolean('DEBUG_MODE', false);\r\n  }\r\n\r\n  /**\r\n   * Check if auto-commit is enabled\r\n   */\r\n  isAutoCommitEnabled(): boolean {\r\n    return this.getBoolean('AUTO_COMMIT_ENABLED', true);\r\n  }\r\n\r\n  /**\r\n   * Check if constitution enforcement is enabled\r\n   */\r\n  isConstitutionEnforced(): boolean {\r\n    return this.getBoolean('ENFORCE_CONSTITUTION', true);\r\n  }\r\n\r\n  /**\r\n   * Get minimum test coverage requirement\r\n   */\r\n  getMinTestCoverage(): number {\r\n    return this.getNumber('MIN_TEST_COVERAGE', 85);\r\n  }\r\n\r\n  /**\r\n   * Get API timeout in milliseconds\r\n   */\r\n  getApiTimeout(): number {\r\n    return this.getNumber('API_TIMEOUT', 30000);\r\n  }\r\n\r\n  /**\r\n   * Get max tokens per request\r\n   */\r\n  getMaxTokensPerRequest(): number {\r\n    return this.getNumber('MAX_TOKENS_PER_REQUEST', 4000);\r\n  }\r\n\r\n  /**\r\n   * Get daily budget limit\r\n   */\r\n  getDailyBudgetLimit(): number {\r\n    const value = this.get('DAILY_BUDGET_LIMIT');\r\n    if (!value) return 0;\r\n    const parsed = parseFloat(value);\r\n    return isNaN(parsed) ? 0 : parsed;\r\n  }\r\n\r\n  /**\r\n   * Get collaboration server port\r\n   */\r\n  getCollaborationServerPort(): number {\r\n    return this.getNumber('COLLABORATION_SERVER_PORT', 3001);\r\n  }\r\n\r\n  /**\r\n   * Check if usage tracking is enabled\r\n   */\r\n  isUsageTrackingEnabled(): boolean {\r\n    return this.getBoolean('TRACK_API_USAGE', true);\r\n  }\r\n\r\n  /**\r\n   * Get vector database path\r\n   */\r\n  getVectorDbPath(): string {\r\n    return this.get('VECTOR_DB_PATH') || '.astraforge/vectordb';\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive configuration summary for debugging\r\n   */\r\n  getConfigSummary(): {\r\n    providers: string[];\r\n    hasApiKeys: boolean;\r\n    debugMode: boolean;\r\n    autoCommit: boolean;\r\n    constitutionEnforced: boolean;\r\n    testCoverage: number;\r\n  } {\r\n    const providers = [];\r\n    if (this.get('OPENROUTER_API_KEY')) providers.push('OpenRouter');\r\n    if (this.get('OPENAI_API_KEY')) providers.push('OpenAI');\r\n    if (this.get('ANTHROPIC_API_KEY')) providers.push('Anthropic');\r\n    if (this.get('XAI_API_KEY')) providers.push('xAI');\r\n\r\n    return {\r\n      providers,\r\n      hasApiKeys: providers.length > 0,\r\n      debugMode: this.isDebugMode(),\r\n      autoCommit: this.isAutoCommitEnabled(),\r\n      constitutionEnforced: this.isConstitutionEnforced(),\r\n      testCoverage: this.getMinTestCoverage()\r\n    };\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const envLoader = new EnvLoader();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\utils\\httpRetry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\utils\\inputValidation.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'validateLLMInput' has too many lines (84). Maximum allowed is 50.","line":44,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":127,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Function 'validateLLMInput' has a complexity of 18. Maximum allowed is 10.","line":44,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":127,"endColumn":2},{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x1f.","line":69,"column":33,"nodeType":"Literal","messageId":"unexpected","endLine":69,"endColumn":51},{"ruleId":"max-lines-per-function","severity":1,"message":"Function 'validateApiKey' has too many lines (59). Maximum allowed is 50.","line":136,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":194,"endColumn":2},{"ruleId":"complexity","severity":2,"message":"Function 'validateApiKey' has a complexity of 15. Maximum allowed is 10.","line":136,"column":8,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":194,"endColumn":2},{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00, \\x08, \\x0e, \\x1f.","line":234,"column":7,"nodeType":"Literal","messageId":"unexpected","endLine":234,"endColumn":33}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Input Validation and Sanitization Utilities\n * Ensures all user inputs are properly validated before sending to LLMs\n */\n\n/**\n * Validation result interface\n */\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n  sanitized?: string;\n}\n\n/**\n * Validation options\n */\nexport interface ValidationOptions {\n  maxLength?: number;\n  minLength?: number;\n  allowHtml?: boolean;\n  allowScripts?: boolean;\n  customPatterns?: RegExp[];\n}\n\n/**\n * Default validation options for LLM prompts\n */\nconst DEFAULT_PROMPT_OPTIONS: ValidationOptions = {\n  maxLength: 10000,\n  minLength: 1,\n  allowHtml: false,\n  allowScripts: false,\n  customPatterns: [],\n};\n\n/**\n * Sanitize and validate user input for LLM consumption\n *\n * @param input - The user input to validate\n * @param options - Validation options\n * @returns Validation result with sanitized input\n */\nexport function validateLLMInput(\n  input: string,\n  options: ValidationOptions = DEFAULT_PROMPT_OPTIONS\n): ValidationResult {\n  const errors: string[] = [];\n  let sanitized = input;\n\n  // Basic null/undefined check\n  if (!input || typeof input !== 'string') {\n    return {\n      isValid: false,\n      errors: ['Input must be a non-empty string'],\n    };\n  }\n\n  // Length validation\n  if (options.maxLength && input.length > options.maxLength) {\n    errors.push(`Input exceeds maximum length of ${options.maxLength} characters`);\n  }\n\n  if (options.minLength && input.length < options.minLength) {\n    errors.push(`Input must be at least ${options.minLength} characters long`);\n  }\n\n  // Remove control characters and potentially dangerous content\n  sanitized = sanitized.replace(/[\\x00-\\x1F\\x7F]/g, '');\n\n  // HTML/Script sanitization\n  if (!options.allowHtml) {\n    sanitized = sanitized.replace(/<[^>]*>/g, '');\n  }\n\n  if (!options.allowScripts) {\n    sanitized = sanitized.replace(/<script[^>]*>.*?<\\/script>/gi, '');\n    sanitized = sanitized.replace(/javascript:/gi, '');\n    sanitized = sanitized.replace(/on\\w+\\s*=/gi, '');\n  }\n\n  // Check for suspicious patterns\n  const suspiciousPatterns = [\n    /system\\s*:/gi,\n    /(?:ignore|disregard|forget).*(?:instructions|prompt|rules)/gi,\n    /(?:act|pretend|roleplay)\\s+as/gi,\n    /(?:you\\s+are|you're)\\s+(?:now|a)/gi,\n  ];\n\n  for (const pattern of suspiciousPatterns) {\n    if (pattern.test(sanitized)) {\n      errors.push('Input contains potentially suspicious content');\n      break;\n    }\n  }\n\n  // Custom pattern validation\n  if (options.customPatterns) {\n    for (const pattern of options.customPatterns) {\n      if (pattern.test(sanitized)) {\n        errors.push('Input violates custom validation pattern');\n        break;\n      }\n    }\n  }\n\n  // Check for potential injection attempts\n  const injectionPatterns = [\n    /\\${.*}/g, // Template literals\n    /<%.*%>/g, // Template tags\n    /{{.*}}/g, // Handlebars/Mustache\n    /\\[\\[.*\\]\\]/g, // Wiki/Markdown links that could be exploited\n  ];\n\n  for (const pattern of injectionPatterns) {\n    if (pattern.test(sanitized)) {\n      errors.push('Input contains potentially unsafe template syntax');\n      break;\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    sanitized: errors.length === 0 ? sanitized.trim() : undefined,\n  };\n}\n\n/**\n * Validate API key format\n *\n * @param apiKey - The API key to validate\n * @param provider - The provider name for specific validation rules\n * @returns Validation result\n */\nexport function validateApiKey(apiKey: string, provider: string): ValidationResult {\n  const errors: string[] = [];\n\n  if (!apiKey || typeof apiKey !== 'string') {\n    return {\n      isValid: false,\n      errors: ['API key must be a non-empty string'],\n    };\n  }\n\n  // Remove whitespace\n  const cleanKey = apiKey.trim();\n\n  // Basic length validation\n  if (cleanKey.length < 10) {\n    errors.push('API key appears to be too short');\n  }\n\n  // Provider-specific validation\n  switch (provider.toLowerCase()) {\n    case 'openai':\n      if (!cleanKey.startsWith('sk-')) {\n        errors.push('OpenAI API keys should start with \"sk-\"');\n      }\n      if (cleanKey.length < 51) {\n        errors.push('OpenAI API key appears to be invalid length');\n      }\n      break;\n\n    case 'anthropic':\n      if (!cleanKey.startsWith('sk-ant-')) {\n        errors.push('Anthropic API keys should start with \"sk-ant-\"');\n      }\n      break;\n\n    case 'xai':\n      if (!cleanKey.startsWith('xai-')) {\n        errors.push('xAI API keys should start with \"xai-\"');\n      }\n      break;\n\n    case 'openrouter':\n      if (!cleanKey.startsWith('sk-or-')) {\n        errors.push('OpenRouter API keys should start with \"sk-or-\"');\n      }\n      break;\n  }\n\n  // Check for suspicious characters\n  if (!/^[a-zA-Z0-9\\-_]+$/.test(cleanKey)) {\n    errors.push('API key contains invalid characters');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    sanitized: errors.length === 0 ? cleanKey : undefined,\n  };\n}\n\n/**\n * Validate project idea input\n *\n * @param idea - The project idea to validate\n * @returns Validation result\n */\nexport function validateProjectIdea(idea: string): ValidationResult {\n  return validateLLMInput(idea, {\n    maxLength: 5000,\n    minLength: 10,\n    allowHtml: false,\n    allowScripts: false,\n  });\n}\n\n/**\n * Validate file content before processing\n *\n * @param content - File content to validate\n * @param filename - Optional filename for context\n * @returns Validation result\n */\nexport function validateFileContent(content: string, filename?: string): ValidationResult {\n  const errors: string[] = [];\n\n  if (!content || typeof content !== 'string') {\n    return {\n      isValid: false,\n      errors: ['File content must be a string'],\n    };\n  }\n\n  // Check file size (10MB limit)\n  if (content.length > 10 * 1024 * 1024) {\n    errors.push('File content exceeds 10MB limit');\n  }\n\n  // Check for binary content\n  if (/[\\x00-\\x08\\x0E-\\x1F\\x7F]/.test(content)) {\n    errors.push('File appears to contain binary data');\n  }\n\n  // Filename validation\n  if (filename) {\n    const dangerousExtensions = ['.exe', '.bat', '.cmd', '.scr', '.com'];\n    const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));\n\n    if (dangerousExtensions.includes(ext)) {\n      errors.push('File type not allowed');\n    }\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    sanitized: errors.length === 0 ? content : undefined,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\utils\\logger.ts","messages":[],"suppressedMessages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":26,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":20,"suggestions":[{"fix":{"range":[774,832],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[799,802],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[799,802],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[825,828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[825,828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":32,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":32,"endColumn":19,"suggestions":[{"fix":{"range":[1030,1087],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1054,1057],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1054,1057],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1080,1083],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1080,1083],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":38,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":38,"endColumn":18,"suggestions":[{"fix":{"range":[1285,1341],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1308,1311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1308,1311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1334,1337],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1334,1337],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":44,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":44,"endColumn":20,"suggestions":[{"fix":{"range":[1541,1599],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1566,1569],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1566,1569],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1592,1595],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1592,1595],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\up2it\\Desktop\\AstraForge\\src\\workflow\\workflowManager.ts","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'llmManager' is defined but never used.","line":81,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":81,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"llmManager"},"fix":{"range":[2594,2616],"text":""},"desc":"Remove unused variable 'llmManager'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'vectorDB' is defined but never used.","line":82,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":82,"endColumn":31,"suggestions":[{"messageId":"removeVar","data":{"varName":"vectorDB"},"fix":{"range":[2630,2648],"text":""},"desc":"Remove unused variable 'vectorDB'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'gitManager' is defined but never used.","line":83,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":83,"endColumn":35,"suggestions":[{"messageId":"removeVar","data":{"varName":"gitManager"},"fix":{"range":[2662,2684],"text":""},"desc":"Remove unused variable 'gitManager'."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4880,4883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4880,4883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'executePhase' has too many lines (98). Maximum allowed is 50.","line":158,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":255,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":252,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8315,8318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8315,8318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":269,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":269,"endColumn":18,"suggestions":[{"fix":{"range":[8727,8775],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":271,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":271,"endColumn":19,"suggestions":[{"fix":{"range":[8804,8865],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":275,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":275,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8914,8917],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8914,8917],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":314,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":314,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10187,10190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10187,10190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":488,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":488,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16152,16155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16152,16155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":491,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":491,"endColumn":18,"suggestions":[{"fix":{"range":[16221,16267],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"max-lines-per-function","severity":1,"message":"Async method 'completeProject' has too many lines (69). Maximum allowed is 50.","line":518,"column":3,"nodeType":"MethodDefinition","messageId":"exceed","endLine":586,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":583,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":583,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19314,19317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19314,19317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * AstraForge Workflow Manager\n *\n * Manages the complete software development workflow from idea to deployment.\n * Integrates LLM collaboration, vector-based context retrieval, Git version control,\n * and reinforcement learning for workflow optimization.\n *\n * @author AstraForge Team\n * @version 1.0.0\n */\n\nimport * as vscode from 'vscode';\nimport { LLMManager } from '../llm/llmManager';\nimport { VectorDB } from '../db/vectorDB';\nimport { GitManager } from '../git/gitManager';\nimport { AdaptiveWorkflowRL } from '../rl/adaptiveWorkflow';\nimport { CollaborationServer } from '../server/collaborationServer';\nimport * as path from 'path';\n\n/**\n * Metrics tracking for workflow performance and user engagement\n */\ninterface WorkflowMetrics {\n  /** Timestamp when workflow started */\n  startTime: number;\n  /** Timestamp when current phase started */\n  phaseStartTime: number;\n  /** Number of errors encountered */\n  errors: number;\n  /** Array of user feedback scores (0-1) */\n  userFeedback: number[];\n  /** Number of iterations performed */\n  iterations: number;\n}\n\n/**\n * Main workflow orchestrator that manages the complete development lifecycle\n *\n * Features:\n * - Phase-based development (Planning → Prototyping → Testing → Deployment)\n * - Multi-LLM collaboration and consensus voting\n * - Vector-based context retrieval for consistency\n * - Reinforcement learning for workflow optimization\n * - Real-time collaboration support\n * - Git integration for version control\n * - User oversight and feedback integration\n */\nexport class WorkflowManager {\n  /** Current phase index in the workflow */\n  private currentPhase = 0;\n\n  /** Ordered list of workflow phases */\n  private phases = ['Planning', 'Prototyping', 'Testing', 'Deployment'];\n\n  /** User's project idea/description */\n  private projectIdea: string = '';\n\n  /** Generated project plan */\n  private buildPlan: string = '';\n\n  /** Reinforcement learning system for workflow optimization */\n  private workflowRL: AdaptiveWorkflowRL;\n\n  /** Optional collaboration server for multi-user workflows */\n  private collaborationServer?: CollaborationServer;\n\n  /** Performance and engagement metrics */\n  private metrics: WorkflowMetrics;\n\n  /** Unique identifier for this workspace session */\n  private workspaceId: string;\n\n  /**\n   * Initialize the WorkflowManager with required dependencies\n   *\n   * @param llmManager - Manager for LLM provider interactions\n   * @param vectorDB - Vector database for context storage and retrieval\n   * @param gitManager - Git integration for version control\n   */\n  constructor(\n    private llmManager: LLMManager,\n    private vectorDB: VectorDB,\n    private gitManager: GitManager\n  ) {\n    this.workflowRL = new AdaptiveWorkflowRL();\n    this.workspaceId = `workspace_${Date.now()}`;\n    this.metrics = {\n      startTime: Date.now(),\n      phaseStartTime: Date.now(),\n      errors: 0,\n      userFeedback: [],\n      iterations: 0,\n    };\n\n    this.initializeCollaboration();\n  }\n\n  /**\n   * Start a new development workflow from a project idea\n   *\n   * @param idea - The user's project description or idea\n   * @param option - Optional workflow configuration or starting phase\n   * @returns Promise that resolves when workflow initialization is complete\n   *\n   * @example\n   * ```typescript\n   * await workflowManager.startWorkflow(\n   *   \"Create a task management app with React and TypeScript\"\n   * );\n   * ```\n   */\n  async startWorkflow(idea: string, option?: string): Promise<void> {\n    this.projectIdea = idea;\n    this.currentPhase = 0;\n\n    try {\n      let prompt = idea;\n      if (option === 'letPanelDecide') {\n        prompt = await this.llmManager.conference(`Refine this project idea: ${idea}`);\n      }\n\n      // Step 2: Conferencing\n      const discussion = await this.llmManager.conference(\n        `Discuss project: ${prompt}. Propose tech stack, estimates, plan.`\n      );\n\n      this.buildPlan = await this.llmManager.voteOnDecision(discussion, [\n        'Approve Plan',\n        'Need Questions',\n      ]);\n\n      if (this.buildPlan === 'Need Questions') {\n        const questions = await this.llmManager.queryLLM(\n          0,\n          `Generate 5-10 questions for clarification on ${prompt}`\n        );\n        const answers = await vscode.window.showInputBox({\n          prompt: `Please answer these questions: ${questions}`,\n        });\n        if (answers) {\n          this.buildPlan = await this.llmManager.conference(\n            `Incorporate answers: ${answers}. Finalize plan.`\n          );\n        }\n      }\n\n      // Store in vector DB\n      const embedding = await this.vectorDB.getEmbedding(this.buildPlan);\n      await this.vectorDB.addEmbedding('buildPlan', embedding, { plan: this.buildPlan });\n\n      vscode.window.showInformationMessage('Build Plan ready! Proceeding to phases.');\n      await this.executePhase();\n    } catch (error: any) {\n      vscode.window.showErrorMessage(`Workflow failed: ${error.message}`);\n    }\n  }\n\n  async executePhase() {\n    const phase = this.phases[this.currentPhase];\n    this.metrics.phaseStartTime = Date.now();\n\n    try {\n      // Get current workflow state for RL\n      const currentState = this.getCurrentWorkflowState();\n\n      // Get RL recommendation for next action\n      const recommendedAction = this.workflowRL.getBestAction(currentState);\n\n      // Apply RL action if not 'continue'\n      if (recommendedAction.type !== 'continue') {\n        const actionResult = await this.applyRLAction(recommendedAction, phase);\n        if (actionResult.shouldReturn) {\n          return;\n        }\n      }\n\n      // Notify collaboration server about phase start\n      this.collaborationServer?.broadcastToWorkspace(this.workspaceId, 'phase_started', {\n        phase,\n        timestamp: Date.now(),\n        projectIdea: this.projectIdea,\n      });\n\n      // Enhanced context retrieval using vector DB\n      const contextQuery = `${phase} for ${this.projectIdea}`;\n      const contextEmbedding = await this.vectorDB.getEmbedding(contextQuery);\n      const relevantContext = await this.vectorDB.queryEmbedding(contextEmbedding, 3);\n\n      const contextText = relevantContext\n        .map(item => item.metadata)\n        .filter(meta => meta && typeof meta === 'object')\n        .map(meta => meta.plan || meta.content || '')\n        .join('\\n');\n\n      // Generate phase content with enhanced prompting\n      const phasePrompt = this.buildEnhancedPrompt(phase, contextText);\n      const output = await this.llmManager.conference(phasePrompt);\n\n      // Process and validate output\n      const processedOutput = await this.processPhaseOutput(output, phase);\n\n      // Write output to file with better organization\n      await this.writePhaseOutput(processedOutput, phase);\n\n      // Git commit with detailed message\n      await this.gitManager.commit(`Phase ${phase} complete - ${this.getPhaseMetrics()}`);\n\n      // Enhanced review with multiple perspectives\n      const review = await this.conductPhaseReview(processedOutput, phase);\n\n      // Intelligent suggestions using context\n      const suggestions = await this.generateIntelligentSuggestions(\n        phase,\n        processedOutput,\n        contextText\n      );\n\n      // User interaction with better UX\n      const userDecision = await this.getUserDecision(suggestions, review);\n      const userFeedback = await this.processUserDecision(\n        userDecision,\n        suggestions,\n        processedOutput,\n        phase\n      );\n\n      // Update RL with feedback\n      const newState = this.getCurrentWorkflowState();\n      const reward = this.workflowRL.calculateReward(\n        currentState,\n        recommendedAction,\n        newState,\n        true, // Phase succeeded\n        userFeedback\n      );\n\n      this.workflowRL.updateQValue(currentState, recommendedAction, reward, newState);\n\n      // Store phase results in vector DB for future context\n      await this.storePhaseContext(phase, processedOutput, review);\n\n      this.metrics.iterations++;\n      this.currentPhase++;\n\n      if (this.currentPhase < this.phases.length) {\n        vscode.window.showInformationMessage(\n          `Phase ${phase} complete! Next: ${this.phases[this.currentPhase]}. Click \"Acknowledge & Proceed\".`\n        );\n      } else {\n        await this.completeProject();\n      }\n    } catch (error: any) {\n      await this.handlePhaseError(error, phase);\n    }\n  }\n\n  proceedToNextPhase() {\n    if (this.currentPhase < this.phases.length) {\n      this.executePhase();\n    }\n  }\n\n  // Supporting methods for enhanced workflow\n\n  private async initializeCollaboration(): Promise<void> {\n    try {\n      this.collaborationServer = new CollaborationServer(3001);\n      await this.collaborationServer.start();\n      console.log('Collaboration server initialized');\n    } catch (error) {\n      console.warn('Failed to start collaboration server:', error);\n    }\n  }\n\n  private getCurrentWorkflowState(): any {\n    const totalTime = Date.now() - this.metrics.startTime;\n\n    return {\n      currentPhase: this.phases[this.currentPhase],\n      projectComplexity: this.estimateProjectComplexity(),\n      userSatisfaction: this.calculateUserSatisfaction(),\n      errorRate: this.metrics.errors / Math.max(1, this.metrics.iterations),\n      timeSpent: Math.min(1, totalTime / (1000 * 60 * 60)), // Normalize to hours\n    };\n  }\n\n  private estimateProjectComplexity(): number {\n    // Simple heuristic based on project description and phases\n    const ideaLength = this.projectIdea.length;\n    const complexityKeywords = [\n      'api',\n      'database',\n      'authentication',\n      'real-time',\n      'machine learning',\n      'ai',\n      'blockchain',\n    ];\n    const matches = complexityKeywords.filter(keyword =>\n      this.projectIdea.toLowerCase().includes(keyword)\n    ).length;\n\n    return Math.min(1, (ideaLength / 500 + matches / complexityKeywords.length) / 2);\n  }\n\n  private calculateUserSatisfaction(): number {\n    if (this.metrics.userFeedback.length === 0) return 0.7; // Default neutral\n    return (\n      this.metrics.userFeedback.reduce((sum, rating) => sum + rating, 0) /\n      this.metrics.userFeedback.length\n    );\n  }\n\n  private async applyRLAction(action: any, phase: string): Promise<{ shouldReturn: boolean }> {\n    switch (action.type) {\n      case 'skip':\n        vscode.window.showInformationMessage(`RL suggests skipping ${phase} phase`);\n        this.currentPhase++;\n        return { shouldReturn: true };\n\n      case 'repeat':\n        vscode.window.showInformationMessage(`RL suggests repeating ${phase} phase`);\n        // Phase will be re-executed\n        return { shouldReturn: false };\n\n      case 'optimize':\n        vscode.window.showInformationMessage(`RL suggests optimizing ${phase} phase`);\n        // Continue with optimization hints\n        return { shouldReturn: false };\n\n      default:\n        return { shouldReturn: false };\n    }\n  }\n\n  private buildEnhancedPrompt(phase: string, contextText: string): string {\n    const basePrompt = `Execute ${phase} for project: ${this.projectIdea}. Plan: ${this.buildPlan}`;\n\n    if (contextText) {\n      return `${basePrompt}\\n\\nRelevant context from previous work:\\n${contextText}\\n\\nPlease build upon this context and ensure consistency.`;\n    }\n\n    return basePrompt;\n  }\n\n  private async processPhaseOutput(output: string, phase: string): Promise<string> {\n    // Add phase-specific processing\n    let processed = output;\n\n    // Add timestamp and phase info\n    processed = `# ${phase} Phase Output\\n\\n*Generated: ${new Date().toISOString()}*\\n\\n${processed}`;\n\n    // Validate output based on phase\n    if (phase === 'Planning' && !processed.includes('architecture')) {\n      processed +=\n        '\\n\\n## Architecture Notes\\n*Architecture details should be included in planning phase.*';\n    }\n\n    return processed;\n  }\n\n  private async writePhaseOutput(output: string, phase: string): Promise<void> {\n    if (!vscode.workspace.workspaceFolders) return;\n\n    const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;\n    const timestamp = new Date().toISOString().split('T')[0];\n    const fileName = `${phase.toLowerCase()}_${timestamp}.md`;\n    const filePath = vscode.Uri.file(path.join(workspaceRoot, 'astraforge_output', fileName));\n\n    // Ensure directory exists\n    const dirPath = path.join(workspaceRoot, 'astraforge_output');\n    try {\n      await vscode.workspace.fs.createDirectory(vscode.Uri.file(dirPath));\n    } catch {\n      // Directory might already exist\n    }\n\n    await vscode.workspace.fs.writeFile(filePath, Buffer.from(output));\n\n    // Also update the latest version\n    const latestPath = vscode.Uri.file(\n      path.join(workspaceRoot, 'astraforge_output', `${phase.toLowerCase()}_latest.md`)\n    );\n    await vscode.workspace.fs.writeFile(latestPath, Buffer.from(output));\n  }\n\n  private getPhaseMetrics(): string {\n    const phaseTime = Date.now() - this.metrics.phaseStartTime;\n    return `Time: ${Math.round(phaseTime / 1000)}s, Iteration: ${this.metrics.iterations + 1}`;\n  }\n\n  private async conductPhaseReview(output: string, phase: string): Promise<string> {\n    const reviewPrompt = `Review this ${phase} phase output for quality, completeness, and potential issues:\\n\\n${output}`;\n    return await this.llmManager.conference(reviewPrompt);\n  }\n\n  private async generateIntelligentSuggestions(\n    phase: string,\n    output: string,\n    contextText: string\n  ): Promise<string> {\n    const suggestionPrompt = `Based on the ${phase} output and context, suggest 3-5 specific improvements or innovations:\\n\\nOutput:\\n${output}\\n\\nContext:\\n${contextText}`;\n    return await this.llmManager.queryLLM(0, suggestionPrompt);\n  }\n\n  private async getUserDecision(suggestions: string, review: string): Promise<string> {\n    const options = [\n      'Proceed as planned',\n      'Apply suggestions',\n      'Request modifications',\n      'Get more details',\n    ];\n\n    const choice = await vscode.window.showQuickPick(options, {\n      placeHolder: `Review: ${review.substring(0, 100)}... | Suggestions: ${suggestions.substring(0, 100)}...`,\n      canPickMany: false,\n    });\n\n    return choice || 'Proceed as planned';\n  }\n\n  private async processUserDecision(\n    decision: string,\n    suggestions: string,\n    output: string,\n    phase: string\n  ): Promise<number> {\n    let feedback = 0.7; // Default neutral feedback\n\n    switch (decision) {\n      case 'Proceed as planned':\n        feedback = 0.8;\n        break;\n\n      case 'Apply suggestions': {\n        feedback = 0.9;\n        const improvedOutput = await this.llmManager.conference(\n          `Apply these suggestions: ${suggestions} to improve: ${output}`\n        );\n        await this.writePhaseOutput(improvedOutput, `${phase}_improved`);\n        break;\n      }\n\n      case 'Request modifications': {\n        feedback = 0.5;\n        const modification = await vscode.window.showInputBox({\n          prompt: 'What modifications would you like?',\n        });\n        if (modification) {\n          const modifiedOutput = await this.llmManager.conference(\n            `Apply these modifications: ${modification} to: ${output}`\n          );\n          await this.writePhaseOutput(modifiedOutput, `${phase}_modified`);\n        }\n        break;\n      }\n\n      case 'Get more details': {\n        feedback = 0.6;\n        const details = await this.llmManager.queryLLM(\n          0,\n          `Provide more detailed explanation for: ${output}`\n        );\n        vscode.window.showInformationMessage(`Details: ${details.substring(0, 200)}...`);\n        break;\n      }\n    }\n\n    this.metrics.userFeedback.push(feedback);\n    return feedback;\n  }\n\n  private async storePhaseContext(phase: string, output: string, review: string): Promise<void> {\n    const contextData = {\n      phase,\n      content: output,\n      review,\n      timestamp: Date.now(),\n      projectIdea: this.projectIdea,\n    };\n\n    const embedding = await this.vectorDB.getEmbedding(\n      `${phase} ${this.projectIdea} ${output.substring(0, 500)}`\n    );\n    await this.vectorDB.addEmbedding(`phase_${phase}_${Date.now()}`, embedding, contextData);\n  }\n\n  private async handlePhaseError(error: any, phase: string): Promise<void> {\n    this.metrics.errors++;\n\n    console.error(`Phase ${phase} error:`, error);\n\n    const errorMessage = `Phase ${phase} encountered an error: ${error.message}`;\n    const options = ['Retry phase', 'Skip phase', 'Abort workflow'];\n\n    const choice = await vscode.window.showErrorMessage(errorMessage, ...options);\n\n    switch (choice) {\n      case 'Retry phase':\n        await this.executePhase();\n        break;\n\n      case 'Skip phase':\n        this.currentPhase++;\n        if (this.currentPhase < this.phases.length) {\n          await this.executePhase();\n        } else {\n          await this.completeProject();\n        }\n        break;\n\n      case 'Abort workflow':\n        vscode.window.showErrorMessage('Workflow aborted by user');\n        break;\n    }\n  }\n\n  private async completeProject() {\n    try {\n      // Generate comprehensive final report with metrics\n      const totalTime = Date.now() - this.metrics.startTime;\n      const rlStats = this.workflowRL.getStats();\n\n      const report = await this.llmManager.queryLLM(\n        0,\n        `Generate a comprehensive final report for ${this.projectIdea}. Include project summary, key achievements, and lessons learned.`\n      );\n\n      const bonuses = await this.llmManager.queryLLM(\n        0,\n        `Suggest 5 innovative A+ enhancements for ${this.projectIdea}, considering cutting-edge technologies like AI, blockchain, and real-time collaboration.`\n      );\n\n      const finalReport = `# AstraForge Project Completion Report\n\n## Project: ${this.projectIdea}\n\n### Execution Metrics\n- **Total Time**: ${Math.round(totalTime / 1000 / 60)} minutes\n- **Phases Completed**: ${this.currentPhase} / ${this.phases.length}\n- **Iterations**: ${this.metrics.iterations}\n- **Errors Encountered**: ${this.metrics.errors}\n- **Average User Satisfaction**: ${this.calculateUserSatisfaction().toFixed(2)}\n\n### AI Learning Metrics\n- **RL States Explored**: ${rlStats.totalStates}\n- **Actions Learned**: ${rlStats.totalActions}\n- **Current Exploration Rate**: ${rlStats.explorationRate.toFixed(3)}\n\n## Project Report\n${report}\n\n## Enhancement Suggestions\n${bonuses}\n\n---\n*Generated by AstraForge IDE - ${new Date().toISOString()}*\n`;\n\n      vscode.window.showInformationMessage(\n        '🎉 Project Complete! Check the final report for details and enhancements.'\n      );\n\n      // Save comprehensive final report\n      if (vscode.workspace.workspaceFolders) {\n        const workspaceRoot = vscode.workspace.workspaceFolders[0].uri.fsPath;\n        const reportPath = vscode.Uri.file(\n          path.join(workspaceRoot, 'astraforge_output', 'FINAL_REPORT.md')\n        );\n        await vscode.workspace.fs.writeFile(reportPath, Buffer.from(finalReport));\n\n        // Open the report\n        const doc = await vscode.workspace.openTextDocument(reportPath);\n        await vscode.window.showTextDocument(doc);\n      }\n\n      // Notify collaboration server\n      this.collaborationServer?.broadcastToWorkspace(this.workspaceId, 'project_completed', {\n        projectIdea: this.projectIdea,\n        metrics: this.metrics,\n        timestamp: Date.now(),\n      });\n    } catch (error: any) {\n      vscode.window.showErrorMessage(`Project completion failed: ${error.message}`);\n    }\n  }\n}\n","usedDeprecatedRules":[]}]